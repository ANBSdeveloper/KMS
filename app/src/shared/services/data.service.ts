
import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class DataServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAppSetting(id: number): Observable<AppSettingDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/appsettings/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppSetting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppSetting(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AppSettingDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AppSettingDtoApiResultObject>;
        }));
    }

    protected processGetAppSetting(response: HttpResponseBase): Observable<AppSettingDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppSettingDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppSettingDtoApiResultObject>(null as any);
    }

    /**
     * @return Success
     */
    deleteAppSetting(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/appsettings/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAppSetting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAppSetting(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteAppSetting(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateAppSetting(id: number, body: UpsertAppSettingCommand | undefined): Observable<AppSettingDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/appsettings/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAppSetting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAppSetting(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AppSettingDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AppSettingDtoApiResultObject>;
        }));
    }

    protected processUpdateAppSetting(response: HttpResponseBase): Observable<AppSettingDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppSettingDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppSettingDtoApiResultObject>(null as any);
    }

    /**
     * @return Success
     */
    getShopAppSettings(): Observable<ShopAppSettingDtoListApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/appsettings/shop";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetShopAppSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetShopAppSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ShopAppSettingDtoListApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ShopAppSettingDtoListApiResultObject>;
        }));
    }

    protected processGetShopAppSettings(response: HttpResponseBase): Observable<ShopAppSettingDtoListApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ShopAppSettingDtoListApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ShopAppSettingDtoListApiResultObject>(null as any);
    }

    /**
     * @return Success
     */
    getSalesAppSettings(): Observable<SalesAppSettingDtoListApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/appsettings/sales";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSalesAppSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSalesAppSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SalesAppSettingDtoListApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SalesAppSettingDtoListApiResultObject>;
        }));
    }

    protected processGetSalesAppSettings(response: HttpResponseBase): Observable<SalesAppSettingDtoListApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SalesAppSettingDtoListApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SalesAppSettingDtoListApiResultObject>(null as any);
    }

    /**
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getAppSettings(maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<AppSettingDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/appsettings?";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AppSettingDtoPagingResultApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AppSettingDtoPagingResultApiResultObject>;
        }));
    }

    protected processGetAppSettings(response: HttpResponseBase): Observable<AppSettingDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppSettingDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppSettingDtoPagingResultApiResultObject>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createAppSetting(body: UpsertAppSettingCommand | undefined): Observable<AppSettingDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/appsettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateAppSetting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateAppSetting(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AppSettingDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AppSettingDtoApiResultObject>;
        }));
    }

    protected processCreateAppSetting(response: HttpResponseBase): Observable<AppSettingDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppSettingDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppSettingDtoApiResultObject>(null as any);
    }

    /**
     * @return Success
     */
    getBranch(id: number): Observable<BranchDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/branches/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBranch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBranch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BranchDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BranchDtoApiResultObject>;
        }));
    }

    protected processGetBranch(response: HttpResponseBase): Observable<BranchDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BranchDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BranchDtoApiResultObject>(null as any);
    }

    /**
     * @param isActive (optional) 
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getBranches(isActive: boolean | undefined, maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<BranchListItemDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/branches?";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBranches(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBranches(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BranchListItemDtoPagingResultApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BranchListItemDtoPagingResultApiResultObject>;
        }));
    }

    protected processGetBranches(response: HttpResponseBase): Observable<BranchListItemDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BranchListItemDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BranchListItemDtoPagingResultApiResultObject>(null as any);
    }

    /**
     * @return Success
     */
    getBrand(id: number): Observable<BrandDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/brands/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBrand(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBrand(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BrandDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BrandDtoApiResultObject>;
        }));
    }

    protected processGetBrand(response: HttpResponseBase): Observable<BrandDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BrandDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrandDtoApiResultObject>(null as any);
    }

    /**
     * @return Success
     */
    deleteBrand(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/brands/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteBrand(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteBrand(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteBrand(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateBrand(id: number, body: UpsertBrandCommand | undefined): Observable<BrandDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/brands/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateBrand(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateBrand(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BrandDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BrandDtoApiResultObject>;
        }));
    }

    protected processUpdateBrand(response: HttpResponseBase): Observable<BrandDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BrandDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrandDtoApiResultObject>(null as any);
    }

    /**
     * @param isActive (optional) 
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getBrands(isActive: boolean | undefined, maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<BrandDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/brands?";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBrands(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBrands(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BrandDtoPagingResultApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BrandDtoPagingResultApiResultObject>;
        }));
    }

    protected processGetBrands(response: HttpResponseBase): Observable<BrandDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BrandDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrandDtoPagingResultApiResultObject>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createBrand(body: UpsertBrandCommand | undefined): Observable<BrandDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/brands";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateBrand(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateBrand(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BrandDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BrandDtoApiResultObject>;
        }));
    }

    protected processCreateBrand(response: HttpResponseBase): Observable<BrandDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BrandDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrandDtoApiResultObject>(null as any);
    }

    /**
     * @return Success
     */
    getBudget(id: number): Observable<BudgetDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/budgets/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBudget(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBudget(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BudgetDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BudgetDtoApiResultObject>;
        }));
    }

    protected processGetBudget(response: HttpResponseBase): Observable<BudgetDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BudgetDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BudgetDtoApiResultObject>(null as any);
    }

    /**
     * @return Success
     */
    deleteBudget(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/budgets/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteBudget(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteBudget(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteBudget(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateBudget(id: number, body: BudgetUpsertCommand | undefined): Observable<BudgetDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/budgets/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateBudget(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateBudget(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BudgetDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BudgetDtoApiResultObject>;
        }));
    }

    protected processUpdateBudget(response: HttpResponseBase): Observable<BudgetDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BudgetDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BudgetDtoApiResultObject>(null as any);
    }

    /**
     * @param investmentType (optional) 
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getBudgets(investmentType: BudgetInvestmentType | undefined, maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<BudgetListItemDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/budgets?";
        if (investmentType === null)
            throw new Error("The parameter 'investmentType' cannot be null.");
        else if (investmentType !== undefined)
            url_ += "InvestmentType=" + encodeURIComponent("" + investmentType) + "&";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBudgets(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBudgets(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BudgetListItemDtoPagingResultApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BudgetListItemDtoPagingResultApiResultObject>;
        }));
    }

    protected processGetBudgets(response: HttpResponseBase): Observable<BudgetListItemDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BudgetListItemDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BudgetListItemDtoPagingResultApiResultObject>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createBudget(body: BudgetUpsertCommand | undefined): Observable<BudgetDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/budgets";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateBudget(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateBudget(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BudgetDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BudgetDtoApiResultObject>;
        }));
    }

    protected processCreateBudget(response: HttpResponseBase): Observable<BudgetDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BudgetDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BudgetDtoApiResultObject>(null as any);
    }

    /**
     * @param investmentType (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getBudgetInitDetail(investmentType: BudgetInvestmentType | undefined, queryId: string | undefined): Observable<BudgetInitDetailDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/budgets/initDetail?";
        if (investmentType === null)
            throw new Error("The parameter 'investmentType' cannot be null.");
        else if (investmentType !== undefined)
            url_ += "InvestmentType=" + encodeURIComponent("" + investmentType) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBudgetInitDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBudgetInitDetail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BudgetInitDetailDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BudgetInitDetailDtoApiResultObject>;
        }));
    }

    protected processGetBudgetInitDetail(response: HttpResponseBase): Observable<BudgetInitDetailDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BudgetInitDetailDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BudgetInitDetailDtoApiResultObject>(null as any);
    }

    /**
     * @param type (optional) 
     * @param cycleId (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getBudgetHistoryByUser(type: BudgetInvestmentType | undefined, cycleId: number | undefined, queryId: string | undefined): Observable<BudgetHistoryByUserDtoListApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/budgets/history?";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&";
        if (cycleId === null)
            throw new Error("The parameter 'cycleId' cannot be null.");
        else if (cycleId !== undefined)
            url_ += "CycleId=" + encodeURIComponent("" + cycleId) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBudgetHistoryByUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBudgetHistoryByUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BudgetHistoryByUserDtoListApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BudgetHistoryByUserDtoListApiResultObject>;
        }));
    }

    protected processGetBudgetHistoryByUser(response: HttpResponseBase): Observable<BudgetHistoryByUserDtoListApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BudgetHistoryByUserDtoListApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BudgetHistoryByUserDtoListApiResultObject>(null as any);
    }

    /**
     * @param phone (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    findConsumerByPhone(phone: string | undefined, queryId: string | undefined): Observable<ConsumerInfoDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/consumers/find?";
        if (phone === null)
            throw new Error("The parameter 'phone' cannot be null.");
        else if (phone !== undefined)
            url_ += "Phone=" + encodeURIComponent("" + phone) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindConsumerByPhone(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindConsumerByPhone(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ConsumerInfoDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ConsumerInfoDtoApiResultObject>;
        }));
    }

    protected processFindConsumerByPhone(response: HttpResponseBase): Observable<ConsumerInfoDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConsumerInfoDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ConsumerInfoDtoApiResultObject>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendOtpConsumer(body: ConsumerSendOtpCommand | undefined): Observable<ObjectApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/consumers/send-otp";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendOtpConsumer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendOtpConsumer(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResultObject>;
        }));
    }

    protected processSendOtpConsumer(response: HttpResponseBase): Observable<ObjectApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectApiResultObject>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    validateOtpConsumer(body: ConsumerValidateOtpCommand | undefined): Observable<ObjectApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/consumers/validate-otp";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidateOtpConsumer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidateOtpConsumer(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResultObject>;
        }));
    }

    protected processValidateOtpConsumer(response: HttpResponseBase): Observable<ObjectApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectApiResultObject>(null as any);
    }

    /**
     * @return Success
     */
    getCustomer(id: number): Observable<CustomerDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/customers/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomer(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CustomerDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CustomerDtoApiResultObject>;
        }));
    }

    protected processGetCustomer(response: HttpResponseBase): Observable<CustomerDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomerDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CustomerDtoApiResultObject>(null as any);
    }

    /**
     * @return Success
     */
    getCustomerQrData(code: string): Observable<StringApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/customers/{code}/qrdata";
        if (code === undefined || code === null)
            throw new Error("The parameter 'code' must be defined.");
        url_ = url_.replace("{code}", encodeURIComponent("" + code));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomerQrData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomerQrData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StringApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StringApiResultObject>;
        }));
    }

    protected processGetCustomerQrData(response: HttpResponseBase): Observable<StringApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringApiResultObject>(null as any);
    }

    /**
     * @return Success
     */
    getCustomerByCode(code: string): Observable<CustomerDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/customers/codes/{code}";
        if (code === undefined || code === null)
            throw new Error("The parameter 'code' must be defined.");
        url_ = url_.replace("{code}", encodeURIComponent("" + code));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomerByCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomerByCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CustomerDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CustomerDtoApiResultObject>;
        }));
    }

    protected processGetCustomerByCode(response: HttpResponseBase): Observable<CustomerDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomerDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CustomerDtoApiResultObject>(null as any);
    }

    /**
     * @param isActive (optional) 
     * @param isKeyShop (optional) 
     * @param provinceId (optional) 
     * @param districtId (optional) 
     * @param wardId (optional) 
     * @param staffId (optional) 
     * @param hasTicketInvestment (optional) 
     * @param keyShopStatus (optional) 
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getCustomers(isActive: boolean | undefined, isKeyShop: boolean | undefined, provinceId: number | undefined, districtId: number | undefined, wardId: number | undefined, staffId: number | undefined, hasTicketInvestment: boolean | undefined, keyShopStatus: number[] | undefined, maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<CustomerDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/customers?";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (isKeyShop === null)
            throw new Error("The parameter 'isKeyShop' cannot be null.");
        else if (isKeyShop !== undefined)
            url_ += "IsKeyShop=" + encodeURIComponent("" + isKeyShop) + "&";
        if (provinceId === null)
            throw new Error("The parameter 'provinceId' cannot be null.");
        else if (provinceId !== undefined)
            url_ += "ProvinceId=" + encodeURIComponent("" + provinceId) + "&";
        if (districtId === null)
            throw new Error("The parameter 'districtId' cannot be null.");
        else if (districtId !== undefined)
            url_ += "DistrictId=" + encodeURIComponent("" + districtId) + "&";
        if (wardId === null)
            throw new Error("The parameter 'wardId' cannot be null.");
        else if (wardId !== undefined)
            url_ += "WardId=" + encodeURIComponent("" + wardId) + "&";
        if (staffId === null)
            throw new Error("The parameter 'staffId' cannot be null.");
        else if (staffId !== undefined)
            url_ += "StaffId=" + encodeURIComponent("" + staffId) + "&";
        if (hasTicketInvestment === null)
            throw new Error("The parameter 'hasTicketInvestment' cannot be null.");
        else if (hasTicketInvestment !== undefined)
            url_ += "HasTicketInvestment=" + encodeURIComponent("" + hasTicketInvestment) + "&";
        if (keyShopStatus === null)
            throw new Error("The parameter 'keyShopStatus' cannot be null.");
        else if (keyShopStatus !== undefined)
            keyShopStatus && keyShopStatus.forEach(item => { url_ += "KeyShopStatus=" + encodeURIComponent("" + item) + "&"; });
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CustomerDtoPagingResultApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CustomerDtoPagingResultApiResultObject>;
        }));
    }

    protected processGetCustomers(response: HttpResponseBase): Observable<CustomerDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomerDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CustomerDtoPagingResultApiResultObject>(null as any);
    }

    /**
     * @param isActive (optional) 
     * @param provinceId (optional) 
     * @param districtId (optional) 
     * @param wardId (optional) 
     * @param rsmStaffId (optional) 
     * @param asmStaffId (optional) 
     * @param salesSupervisorStaffId (optional) 
     * @param hasTicketInvestment (optional) 
     * @param keyShopStatus (optional) 
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getCustomersByStaff(isActive: boolean | undefined, provinceId: number | undefined, districtId: number | undefined, wardId: number | undefined, rsmStaffId: number | undefined, asmStaffId: number | undefined, salesSupervisorStaffId: number | undefined, hasTicketInvestment: boolean | undefined, keyShopStatus: number[] | undefined, maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<CustomerByStaffListDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/customers/getCustomersByStaff?";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (provinceId === null)
            throw new Error("The parameter 'provinceId' cannot be null.");
        else if (provinceId !== undefined)
            url_ += "ProvinceId=" + encodeURIComponent("" + provinceId) + "&";
        if (districtId === null)
            throw new Error("The parameter 'districtId' cannot be null.");
        else if (districtId !== undefined)
            url_ += "DistrictId=" + encodeURIComponent("" + districtId) + "&";
        if (wardId === null)
            throw new Error("The parameter 'wardId' cannot be null.");
        else if (wardId !== undefined)
            url_ += "WardId=" + encodeURIComponent("" + wardId) + "&";
        if (rsmStaffId === null)
            throw new Error("The parameter 'rsmStaffId' cannot be null.");
        else if (rsmStaffId !== undefined)
            url_ += "RsmStaffId=" + encodeURIComponent("" + rsmStaffId) + "&";
        if (asmStaffId === null)
            throw new Error("The parameter 'asmStaffId' cannot be null.");
        else if (asmStaffId !== undefined)
            url_ += "AsmStaffId=" + encodeURIComponent("" + asmStaffId) + "&";
        if (salesSupervisorStaffId === null)
            throw new Error("The parameter 'salesSupervisorStaffId' cannot be null.");
        else if (salesSupervisorStaffId !== undefined)
            url_ += "SalesSupervisorStaffId=" + encodeURIComponent("" + salesSupervisorStaffId) + "&";
        if (hasTicketInvestment === null)
            throw new Error("The parameter 'hasTicketInvestment' cannot be null.");
        else if (hasTicketInvestment !== undefined)
            url_ += "HasTicketInvestment=" + encodeURIComponent("" + hasTicketInvestment) + "&";
        if (keyShopStatus === null)
            throw new Error("The parameter 'keyShopStatus' cannot be null.");
        else if (keyShopStatus !== undefined)
            keyShopStatus && keyShopStatus.forEach(item => { url_ += "KeyShopStatus=" + encodeURIComponent("" + item) + "&"; });
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomersByStaff(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomersByStaff(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CustomerByStaffListDtoPagingResultApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CustomerByStaffListDtoPagingResultApiResultObject>;
        }));
    }

    protected processGetCustomersByStaff(response: HttpResponseBase): Observable<CustomerByStaffListDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomerByStaffListDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CustomerByStaffListDtoPagingResultApiResultObject>(null as any);
    }

    /**
     * @param id (optional) 
     * @param date (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getRecentSales(id: number | undefined, date: Date | undefined, queryId: string | undefined): Observable<CustomerRecentSalesDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/customers/recentSales?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (date === null)
            throw new Error("The parameter 'date' cannot be null.");
        else if (date !== undefined)
            url_ += "Date=" + encodeURIComponent(date ? "" + date.toISOString() : "") + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecentSales(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecentSales(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CustomerRecentSalesDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CustomerRecentSalesDtoApiResultObject>;
        }));
    }

    protected processGetRecentSales(response: HttpResponseBase): Observable<CustomerRecentSalesDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomerRecentSalesDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CustomerRecentSalesDtoApiResultObject>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    registerKeyShop(body: CustomerRegisterKeyShopCommand | undefined): Observable<ObjectApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/customers/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterKeyShop(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterKeyShop(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResultObject>;
        }));
    }

    protected processRegisterKeyShop(response: HttpResponseBase): Observable<ObjectApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectApiResultObject>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    register(body: CustomerRegisterCommand | undefined): Observable<ObjectApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/customers/registerNew";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResultObject>;
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<ObjectApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectApiResultObject>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    approveKeyShop(body: CustomerApproveKeyShopCommand | undefined): Observable<ObjectApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/customers/approve";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApproveKeyShop(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApproveKeyShop(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResultObject>;
        }));
    }

    protected processApproveKeyShop(response: HttpResponseBase): Observable<ObjectApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectApiResultObject>(null as any);
    }

    /**
     * @param zoneId (optional) 
     * @param areaId (optional) 
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getCustomerApproveKeyShopList(zoneId: number | undefined, areaId: number | undefined, maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<CustomerApproveKeyShopListDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/customers/approve?";
        if (zoneId === null)
            throw new Error("The parameter 'zoneId' cannot be null.");
        else if (zoneId !== undefined)
            url_ += "ZoneId=" + encodeURIComponent("" + zoneId) + "&";
        if (areaId === null)
            throw new Error("The parameter 'areaId' cannot be null.");
        else if (areaId !== undefined)
            url_ += "AreaId=" + encodeURIComponent("" + areaId) + "&";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomerApproveKeyShopList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomerApproveKeyShopList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CustomerApproveKeyShopListDtoPagingResultApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CustomerApproveKeyShopListDtoPagingResultApiResultObject>;
        }));
    }

    protected processGetCustomerApproveKeyShopList(response: HttpResponseBase): Observable<CustomerApproveKeyShopListDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomerApproveKeyShopListDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CustomerApproveKeyShopListDtoPagingResultApiResultObject>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    refuseKeyShop(body: CustomerRefuseKeyShopCommand | undefined): Observable<ObjectApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/customers/refuse";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRefuseKeyShop(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRefuseKeyShop(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResultObject>;
        }));
    }

    protected processRefuseKeyShop(response: HttpResponseBase): Observable<ObjectApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectApiResultObject>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    validateActivationKeyShop(body: CustomerValidateActivationKeyShopCommand | undefined): Observable<ObjectApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/customers/validate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidateActivationKeyShop(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidateActivationKeyShop(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResultObject>;
        }));
    }

    protected processValidateActivationKeyShop(response: HttpResponseBase): Observable<ObjectApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectApiResultObject>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    activateKeyShop(body: CustomerActivateKeyShopCommand | undefined): Observable<ObjectApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/customers/activate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivateKeyShop(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivateKeyShop(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResultObject>;
        }));
    }

    protected processActivateKeyShop(response: HttpResponseBase): Observable<ObjectApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectApiResultObject>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    validateRecoveryPassword(body: CustomerValidateRecoveryPasswordCommand | undefined): Observable<ObjectApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/customers/recovery-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidateRecoveryPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidateRecoveryPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResultObject>;
        }));
    }

    protected processValidateRecoveryPassword(response: HttpResponseBase): Observable<ObjectApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectApiResultObject>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resetPasswordCustomer(body: CustomerResetPasswordCommand | undefined): Observable<ObjectApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/customers/reset-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPasswordCustomer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPasswordCustomer(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResultObject>;
        }));
    }

    protected processResetPasswordCustomer(response: HttpResponseBase): Observable<ObjectApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectApiResultObject>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    checkCustomerOtp(body: CustomerCheckOtpCommand | undefined): Observable<ObjectApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/customers/check-otp";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckCustomerOtp(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckCustomerOtp(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResultObject>;
        }));
    }

    protected processCheckCustomerOtp(response: HttpResponseBase): Observable<ObjectApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectApiResultObject>(null as any);
    }

    /**
     * @return Success
     */
    getCustomerLocation(id: number): Observable<CustomerLocationDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/customer-locations/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomerLocation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomerLocation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CustomerLocationDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CustomerLocationDtoApiResultObject>;
        }));
    }

    protected processGetCustomerLocation(response: HttpResponseBase): Observable<CustomerLocationDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomerLocationDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CustomerLocationDtoApiResultObject>(null as any);
    }

    /**
     * @return Success
     */
    deleteCustomerLocation(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/customer-locations/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCustomerLocation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCustomerLocation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteCustomerLocation(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateCustomerLocation(id: number, body: CustomerLocationUpsertCommand | undefined): Observable<CustomerLocationDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/customer-locations/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCustomerLocation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCustomerLocation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CustomerLocationDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CustomerLocationDtoApiResultObject>;
        }));
    }

    protected processUpdateCustomerLocation(response: HttpResponseBase): Observable<CustomerLocationDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomerLocationDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CustomerLocationDtoApiResultObject>(null as any);
    }

    /**
     * @param isActive (optional) 
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getCustomerLocations(isActive: boolean | undefined, maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<CustomerLocationDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/customer-locations?";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomerLocations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomerLocations(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CustomerLocationDtoPagingResultApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CustomerLocationDtoPagingResultApiResultObject>;
        }));
    }

    protected processGetCustomerLocations(response: HttpResponseBase): Observable<CustomerLocationDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomerLocationDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CustomerLocationDtoPagingResultApiResultObject>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createCustomerLocation(body: CustomerLocationUpsertCommand | undefined): Observable<CustomerLocationDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/customer-locations";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateCustomerLocation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateCustomerLocation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CustomerLocationDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CustomerLocationDtoApiResultObject>;
        }));
    }

    protected processCreateCustomerLocation(response: HttpResponseBase): Observable<CustomerLocationDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomerLocationDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CustomerLocationDtoApiResultObject>(null as any);
    }

    /**
     * @return Success
     */
    getCycle(id: number): Observable<CycleDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/cycles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCycle(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCycle(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CycleDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CycleDtoApiResultObject>;
        }));
    }

    protected processGetCycle(response: HttpResponseBase): Observable<CycleDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CycleDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CycleDtoApiResultObject>(null as any);
    }

    /**
     * @return Success
     */
    deleteCycle(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/cycles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCycle(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCycle(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteCycle(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateCycle(id: number, body: UpsertCycleCommand | undefined): Observable<CycleDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/cycles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCycle(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCycle(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CycleDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CycleDtoApiResultObject>;
        }));
    }

    protected processUpdateCycle(response: HttpResponseBase): Observable<CycleDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CycleDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CycleDtoApiResultObject>(null as any);
    }

    /**
     * @param isActive (optional) 
     * @param useLimitConfig (optional) 
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getCycles(isActive: boolean | undefined, useLimitConfig: boolean | undefined, maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<CycleDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/cycles?";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (useLimitConfig === null)
            throw new Error("The parameter 'useLimitConfig' cannot be null.");
        else if (useLimitConfig !== undefined)
            url_ += "UseLimitConfig=" + encodeURIComponent("" + useLimitConfig) + "&";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCycles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCycles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CycleDtoPagingResultApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CycleDtoPagingResultApiResultObject>;
        }));
    }

    protected processGetCycles(response: HttpResponseBase): Observable<CycleDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CycleDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CycleDtoPagingResultApiResultObject>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createCycle(body: UpsertCycleCommand | undefined): Observable<CycleDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/cycles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateCycle(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateCycle(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CycleDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CycleDtoApiResultObject>;
        }));
    }

    protected processCreateCycle(response: HttpResponseBase): Observable<CycleDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CycleDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CycleDtoApiResultObject>(null as any);
    }

    /**
     * @return Success
     */
    getProvince(id: number): Observable<ProvinceDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/geography/provinces/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProvince(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProvince(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProvinceDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProvinceDtoApiResultObject>;
        }));
    }

    protected processGetProvince(response: HttpResponseBase): Observable<ProvinceDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProvinceDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProvinceDtoApiResultObject>(null as any);
    }

    /**
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getProvinces(maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<ProvinceDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/geography/provinces?";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProvinces(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProvinces(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProvinceDtoPagingResultApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProvinceDtoPagingResultApiResultObject>;
        }));
    }

    protected processGetProvinces(response: HttpResponseBase): Observable<ProvinceDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProvinceDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProvinceDtoPagingResultApiResultObject>(null as any);
    }

    /**
     * @return Success
     */
    getDistrict(id: number): Observable<DistrictDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/geography/districts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDistrict(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDistrict(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DistrictDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DistrictDtoApiResultObject>;
        }));
    }

    protected processGetDistrict(response: HttpResponseBase): Observable<DistrictDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DistrictDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DistrictDtoApiResultObject>(null as any);
    }

    /**
     * @param provinceId (optional) 
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getDistricts(provinceId: number | undefined, maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<DistrictListDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/geography/districts?";
        if (provinceId === null)
            throw new Error("The parameter 'provinceId' cannot be null.");
        else if (provinceId !== undefined)
            url_ += "ProvinceId=" + encodeURIComponent("" + provinceId) + "&";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDistricts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDistricts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DistrictListDtoPagingResultApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DistrictListDtoPagingResultApiResultObject>;
        }));
    }

    protected processGetDistricts(response: HttpResponseBase): Observable<DistrictListDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DistrictListDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DistrictListDtoPagingResultApiResultObject>(null as any);
    }

    /**
     * @return Success
     */
    getArea(id: number): Observable<AreaDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/geography/areas/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetArea(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetArea(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AreaDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AreaDtoApiResultObject>;
        }));
    }

    protected processGetArea(response: HttpResponseBase): Observable<AreaDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AreaDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AreaDtoApiResultObject>(null as any);
    }

    /**
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getAreas(maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<AreaDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/geography/areas?";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAreas(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAreas(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AreaDtoPagingResultApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AreaDtoPagingResultApiResultObject>;
        }));
    }

    protected processGetAreas(response: HttpResponseBase): Observable<AreaDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AreaDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AreaDtoPagingResultApiResultObject>(null as any);
    }

    /**
     * @param zoneId (optional) 
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getAreaByZones(zoneId: number | undefined, maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<AreaDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/geography/areabyzones?";
        if (zoneId === null)
            throw new Error("The parameter 'zoneId' cannot be null.");
        else if (zoneId !== undefined)
            url_ += "ZoneId=" + encodeURIComponent("" + zoneId) + "&";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAreaByZones(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAreaByZones(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AreaDtoPagingResultApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AreaDtoPagingResultApiResultObject>;
        }));
    }

    protected processGetAreaByZones(response: HttpResponseBase): Observable<AreaDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AreaDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AreaDtoPagingResultApiResultObject>(null as any);
    }

    /**
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getAreaByZoneNames(maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<AreaByZoneNameListDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/geography/areabyzonenames?";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAreaByZoneNames(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAreaByZoneNames(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AreaByZoneNameListDtoPagingResultApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AreaByZoneNameListDtoPagingResultApiResultObject>;
        }));
    }

    protected processGetAreaByZoneNames(response: HttpResponseBase): Observable<AreaByZoneNameListDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AreaByZoneNameListDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AreaByZoneNameListDtoPagingResultApiResultObject>(null as any);
    }

    /**
     * @return Success
     */
    getZone(id: number): Observable<ZoneDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/geography/zones/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetZone(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetZone(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ZoneDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ZoneDtoApiResultObject>;
        }));
    }

    protected processGetZone(response: HttpResponseBase): Observable<ZoneDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ZoneDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ZoneDtoApiResultObject>(null as any);
    }

    /**
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getZones(maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<ZoneDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/geography/zones?";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetZones(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetZones(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ZoneDtoPagingResultApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ZoneDtoPagingResultApiResultObject>;
        }));
    }

    protected processGetZones(response: HttpResponseBase): Observable<ZoneDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ZoneDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ZoneDtoPagingResultApiResultObject>(null as any);
    }

    /**
     * @return Success
     */
    getWard(id: number): Observable<WardDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/geography/wards/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWard(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WardDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WardDtoApiResultObject>;
        }));
    }

    protected processGetWard(response: HttpResponseBase): Observable<WardDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WardDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WardDtoApiResultObject>(null as any);
    }

    /**
     * @param districtId (optional) 
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getWards(districtId: number | undefined, maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<WardDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/geography/wards?";
        if (districtId === null)
            throw new Error("The parameter 'districtId' cannot be null.");
        else if (districtId !== undefined)
            url_ += "DistrictId=" + encodeURIComponent("" + districtId) + "&";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWards(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWards(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WardDtoPagingResultApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WardDtoPagingResultApiResultObject>;
        }));
    }

    protected processGetWards(response: HttpResponseBase): Observable<WardDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WardDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WardDtoPagingResultApiResultObject>(null as any);
    }

    /**
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getWardNames(maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<WardNameListDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/geography/wardnames?";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWardNames(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWardNames(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WardNameListDtoPagingResultApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WardNameListDtoPagingResultApiResultObject>;
        }));
    }

    protected processGetWardNames(response: HttpResponseBase): Observable<WardNameListDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WardNameListDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WardNameListDtoPagingResultApiResultObject>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateSpoonCode(body: OrderUpdateSpoonCodeCommand | undefined): Observable<OrderDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/integration/update-spoon-code";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSpoonCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSpoonCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrderDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrderDtoApiResultObject>;
        }));
    }

    protected processUpdateSpoonCode(response: HttpResponseBase): Observable<OrderDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrderDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrderDtoApiResultObject>(null as any);
    }

    /**
     * @param phone (optional) 
     * @return Success
     */
    tickets(phone: string | undefined): Observable<TicketGetByConsumerDtoListApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/integration/tickets?";
        if (phone === null)
            throw new Error("The parameter 'phone' cannot be null.");
        else if (phone !== undefined)
            url_ += "phone=" + encodeURIComponent("" + phone) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTickets(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTickets(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TicketGetByConsumerDtoListApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TicketGetByConsumerDtoListApiResultObject>;
        }));
    }

    protected processTickets(response: HttpResponseBase): Observable<TicketGetByConsumerDtoListApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TicketGetByConsumerDtoListApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TicketGetByConsumerDtoListApiResultObject>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    integrationCreateVendor(body: VendorUpsertCommand | undefined): Observable<ObjectApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/integration/vendors";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIntegrationCreateVendor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIntegrationCreateVendor(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResultObject>;
        }));
    }

    protected processIntegrationCreateVendor(response: HttpResponseBase): Observable<ObjectApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectApiResultObject>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    integrationUpdateVendor(id: number, body: VendorUpsertCommand | undefined): Observable<VendorDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/integration/vendors/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIntegrationUpdateVendor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIntegrationUpdateVendor(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VendorDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VendorDtoApiResultObject>;
        }));
    }

    protected processIntegrationUpdateVendor(response: HttpResponseBase): Observable<VendorDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VendorDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VendorDtoApiResultObject>(null as any);
    }

    /**
     * @return Success
     */
    getInvestment(): Observable<InvestmentDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/investments";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvestment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvestment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvestmentDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvestmentDtoApiResultObject>;
        }));
    }

    protected processGetInvestment(response: HttpResponseBase): Observable<InvestmentDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvestmentDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvestmentDtoApiResultObject>(null as any);
    }

    /**
     * @return Success
     */
    getInvestmentSetting(): Observable<InvestmentSettingDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/investmentSetting";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvestmentSetting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvestmentSetting(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvestmentSettingDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvestmentSettingDtoApiResultObject>;
        }));
    }

    protected processGetInvestmentSetting(response: HttpResponseBase): Observable<InvestmentSettingDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvestmentSettingDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvestmentSettingDtoApiResultObject>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createInvestmentSetting(body: UpsertInvestmentSettingCommand | undefined): Observable<InvestmentSettingDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/investmentSetting";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateInvestmentSetting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateInvestmentSetting(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvestmentSettingDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvestmentSettingDtoApiResultObject>;
        }));
    }

    protected processCreateInvestmentSetting(response: HttpResponseBase): Observable<InvestmentSettingDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvestmentSettingDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvestmentSettingDtoApiResultObject>(null as any);
    }

    /**
     * @param customerId (optional) 
     * @return Success
     */
    getInvestmentCustomerSetting(customerId: number | undefined): Observable<InvestmentCustomerSettingDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/investmentSetting/customer?";
        if (customerId === null)
            throw new Error("The parameter 'customerId' cannot be null.");
        else if (customerId !== undefined)
            url_ += "CustomerId=" + encodeURIComponent("" + customerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvestmentCustomerSetting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvestmentCustomerSetting(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvestmentCustomerSettingDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvestmentCustomerSettingDtoApiResultObject>;
        }));
    }

    protected processGetInvestmentCustomerSetting(response: HttpResponseBase): Observable<InvestmentCustomerSettingDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvestmentCustomerSettingDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvestmentCustomerSettingDtoApiResultObject>(null as any);
    }

    /**
     * @param customerCode (optional) 
     * @return Success
     */
    getInvestmentCustomerSettingByCode(customerCode: string | undefined): Observable<InvestmentCustomerSettingDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/investmentSetting/customer/bycode?";
        if (customerCode === null)
            throw new Error("The parameter 'customerCode' cannot be null.");
        else if (customerCode !== undefined)
            url_ += "CustomerCode=" + encodeURIComponent("" + customerCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvestmentCustomerSettingByCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvestmentCustomerSettingByCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvestmentCustomerSettingDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvestmentCustomerSettingDtoApiResultObject>;
        }));
    }

    protected processGetInvestmentCustomerSettingByCode(response: HttpResponseBase): Observable<InvestmentCustomerSettingDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvestmentCustomerSettingDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvestmentCustomerSettingDtoApiResultObject>(null as any);
    }

    /**
     * @return Success
     */
    deleteInvestmentSetting(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/investmentSetting/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteInvestmentSetting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteInvestmentSetting(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteInvestmentSetting(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateInvestmentSetting(id: number, body: UpsertInvestmentSettingCommand | undefined): Observable<InvestmentSettingDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/investmentSetting/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateInvestmentSetting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateInvestmentSetting(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvestmentSettingDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvestmentSettingDtoApiResultObject>;
        }));
    }

    protected processUpdateInvestmentSetting(response: HttpResponseBase): Observable<InvestmentSettingDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvestmentSettingDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvestmentSettingDtoApiResultObject>(null as any);
    }

    /**
     * @return Success
     */
    getMaterial(id: number): Observable<MaterialDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/materials/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMaterial(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaterial(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MaterialDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MaterialDtoApiResultObject>;
        }));
    }

    protected processGetMaterial(response: HttpResponseBase): Observable<MaterialDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MaterialDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MaterialDtoApiResultObject>(null as any);
    }

    /**
     * @return Success
     */
    deleteMaterial(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/materials/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteMaterial(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMaterial(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteMaterial(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateMaterial(id: number, body: MaterialUpsertCommand | undefined): Observable<MaterialDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/materials/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateMaterial(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMaterial(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MaterialDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MaterialDtoApiResultObject>;
        }));
    }

    protected processUpdateMaterial(response: HttpResponseBase): Observable<MaterialDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MaterialDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MaterialDtoApiResultObject>(null as any);
    }

    /**
     * @param isActive (optional) 
     * @param materialTypeId (optional) 
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getMaterials(isActive: boolean | undefined, materialTypeId: number | undefined, maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<MaterialListItemDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/materials?";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (materialTypeId === null)
            throw new Error("The parameter 'materialTypeId' cannot be null.");
        else if (materialTypeId !== undefined)
            url_ += "MaterialTypeId=" + encodeURIComponent("" + materialTypeId) + "&";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMaterials(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaterials(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MaterialListItemDtoPagingResultApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MaterialListItemDtoPagingResultApiResultObject>;
        }));
    }

    protected processGetMaterials(response: HttpResponseBase): Observable<MaterialListItemDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MaterialListItemDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MaterialListItemDtoPagingResultApiResultObject>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createMaterial(body: MaterialUpsertCommand | undefined): Observable<MaterialDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/materials";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateMaterial(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateMaterial(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MaterialDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MaterialDtoApiResultObject>;
        }));
    }

    protected processCreateMaterial(response: HttpResponseBase): Observable<MaterialDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MaterialDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MaterialDtoApiResultObject>(null as any);
    }

    /**
     * @return Success
     */
    exportMaterial(): Observable<Stream> {
        let url_ = this.baseUrl + "/api/v1/materials/export";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportMaterial(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportMaterial(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Stream>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Stream>;
        }));
    }

    protected processExportMaterial(response: HttpResponseBase): Observable<Stream> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Stream.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Stream>(null as any);
    }

    /**
     * @param contentType (optional) 
     * @param contentDisposition (optional) 
     * @param headers (optional) 
     * @param length (optional) 
     * @param name (optional) 
     * @param fileName (optional) 
     * @return Success
     */
    importMaterial(contentType: string | undefined, contentDisposition: string | undefined, headers: { [key: string]: string[]; } | undefined, length: number | undefined, name: string | undefined, fileName: string | undefined): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/materials/import";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (contentType === null || contentType === undefined)
            throw new Error("The parameter 'contentType' cannot be null.");
        else
            content_.append("ContentType", contentType.toString());
        if (contentDisposition === null || contentDisposition === undefined)
            throw new Error("The parameter 'contentDisposition' cannot be null.");
        else
            content_.append("ContentDisposition", contentDisposition.toString());
        if (headers === null || headers === undefined)
            throw new Error("The parameter 'headers' cannot be null.");
        else
            content_.append("Headers", JSON.stringify(headers));
        if (length === null || length === undefined)
            throw new Error("The parameter 'length' cannot be null.");
        else
            content_.append("Length", length.toString());
        if (name === null || name === undefined)
            throw new Error("The parameter 'name' cannot be null.");
        else
            content_.append("Name", name.toString());
        if (fileName === null || fileName === undefined)
            throw new Error("The parameter 'fileName' cannot be null.");
        else
            content_.append("FileName", fileName.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportMaterial(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportMaterial(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processImportMaterial(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(null as any);
    }

    /**
     * @return Success
     */
    getMaterialType(id: number): Observable<MaterialTypeDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/material-types/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMaterialType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaterialType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MaterialTypeDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MaterialTypeDtoApiResultObject>;
        }));
    }

    protected processGetMaterialType(response: HttpResponseBase): Observable<MaterialTypeDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MaterialTypeDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MaterialTypeDtoApiResultObject>(null as any);
    }

    /**
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getMaterialTypes(maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<MaterialTypeDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/material-types?";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMaterialTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaterialTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MaterialTypeDtoPagingResultApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MaterialTypeDtoPagingResultApiResultObject>;
        }));
    }

    protected processGetMaterialTypes(response: HttpResponseBase): Observable<MaterialTypeDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MaterialTypeDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MaterialTypeDtoPagingResultApiResultObject>(null as any);
    }

    /**
     * @return Success
     */
    getNotification(id: number): Observable<NotificationDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/notifications/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNotification(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NotificationDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NotificationDtoApiResultObject>;
        }));
    }

    protected processGetNotification(response: HttpResponseBase): Observable<NotificationDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NotificationDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NotificationDtoApiResultObject>(null as any);
    }

    /**
     * @return Success
     */
    deleteNotification(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/notifications/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteNotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteNotification(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteNotification(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateNotification(id: number, body: NotificationUpsertCommand | undefined): Observable<NotificationDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/notifications/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateNotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateNotification(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NotificationDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NotificationDtoApiResultObject>;
        }));
    }

    protected processUpdateNotification(response: HttpResponseBase): Observable<NotificationDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NotificationDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NotificationDtoApiResultObject>(null as any);
    }

    /**
     * @param status (optional) 
     * @param objectType (optional) 
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getNotifications(status: number | undefined, objectType: number | undefined, maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<NotificationListDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/notifications?";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        if (objectType === null)
            throw new Error("The parameter 'objectType' cannot be null.");
        else if (objectType !== undefined)
            url_ += "ObjectType=" + encodeURIComponent("" + objectType) + "&";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNotifications(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNotifications(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NotificationListDtoPagingResultApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NotificationListDtoPagingResultApiResultObject>;
        }));
    }

    protected processGetNotifications(response: HttpResponseBase): Observable<NotificationListDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NotificationListDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NotificationListDtoPagingResultApiResultObject>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createNotification(body: NotificationUpsertCommand | undefined): Observable<NotificationDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/notifications";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateNotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateNotification(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NotificationDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NotificationDtoApiResultObject>;
        }));
    }

    protected processCreateNotification(response: HttpResponseBase): Observable<NotificationDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NotificationDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NotificationDtoApiResultObject>(null as any);
    }

    /**
     * @return Success
     */
    sendNotification(id: number): Observable<NotificationDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/notifications/{id}/send";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendNotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendNotification(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NotificationDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NotificationDtoApiResultObject>;
        }));
    }

    protected processSendNotification(response: HttpResponseBase): Observable<NotificationDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NotificationDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NotificationDtoApiResultObject>(null as any);
    }

    /**
     * @return Success
     */
    viewNotification(id: number): Observable<ObjectApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/notifications/{id}/view";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processViewNotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processViewNotification(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResultObject>;
        }));
    }

    protected processViewNotification(response: HttpResponseBase): Observable<ObjectApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectApiResultObject>(null as any);
    }

    /**
     * @param unread (optional) 
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getNotificationUsers(unread: boolean | undefined, maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<NotificationListDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/notifications/byuser?";
        if (unread === null)
            throw new Error("The parameter 'unread' cannot be null.");
        else if (unread !== undefined)
            url_ += "Unread=" + encodeURIComponent("" + unread) + "&";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNotificationUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNotificationUsers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NotificationListDtoPagingResultApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NotificationListDtoPagingResultApiResultObject>;
        }));
    }

    protected processGetNotificationUsers(response: HttpResponseBase): Observable<NotificationListDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NotificationListDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NotificationListDtoPagingResultApiResultObject>(null as any);
    }

    /**
     * @return Success
     */
    getNotificationUnreadCount(): Observable<Int32ApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/notifications/unread-count";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNotificationUnreadCount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNotificationUnreadCount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Int32ApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Int32ApiResultObject>;
        }));
    }

    protected processGetNotificationUnreadCount(response: HttpResponseBase): Observable<Int32ApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Int32ApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Int32ApiResultObject>(null as any);
    }

    /**
     * @return Success
     */
    getOrder(id: number): Observable<OrderDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/orders/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrder(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrderDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrderDtoApiResultObject>;
        }));
    }

    protected processGetOrder(response: HttpResponseBase): Observable<OrderDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrderDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrderDtoApiResultObject>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrder(body: OrderCreateCommand | undefined): Observable<OrderDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/orders";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrder(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrderDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrderDtoApiResultObject>;
        }));
    }

    protected processCreateOrder(response: HttpResponseBase): Observable<OrderDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrderDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrderDtoApiResultObject>(null as any);
    }

    /**
     * @param customerId (optional) 
     * @param rsmStaffId (optional) 
     * @param asmStaffId (optional) 
     * @param salesSupervisorStaffId (optional) 
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getOrders(customerId: number | undefined, rsmStaffId: number | undefined, asmStaffId: number | undefined, salesSupervisorStaffId: number | undefined, fromDate: Date | undefined, toDate: Date | undefined, maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<OrderListItemDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/orders?";
        if (customerId === null)
            throw new Error("The parameter 'customerId' cannot be null.");
        else if (customerId !== undefined)
            url_ += "CustomerId=" + encodeURIComponent("" + customerId) + "&";
        if (rsmStaffId === null)
            throw new Error("The parameter 'rsmStaffId' cannot be null.");
        else if (rsmStaffId !== undefined)
            url_ += "RsmStaffId=" + encodeURIComponent("" + rsmStaffId) + "&";
        if (asmStaffId === null)
            throw new Error("The parameter 'asmStaffId' cannot be null.");
        else if (asmStaffId !== undefined)
            url_ += "AsmStaffId=" + encodeURIComponent("" + asmStaffId) + "&";
        if (salesSupervisorStaffId === null)
            throw new Error("The parameter 'salesSupervisorStaffId' cannot be null.");
        else if (salesSupervisorStaffId !== undefined)
            url_ += "SalesSupervisorStaffId=" + encodeURIComponent("" + salesSupervisorStaffId) + "&";
        if (fromDate === null)
            throw new Error("The parameter 'fromDate' cannot be null.");
        else if (fromDate !== undefined)
            url_ += "FromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toISOString() : "") + "&";
        if (toDate === null)
            throw new Error("The parameter 'toDate' cannot be null.");
        else if (toDate !== undefined)
            url_ += "ToDate=" + encodeURIComponent(toDate ? "" + toDate.toISOString() : "") + "&";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrders(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrderListItemDtoPagingResultApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrderListItemDtoPagingResultApiResultObject>;
        }));
    }

    protected processGetOrders(response: HttpResponseBase): Observable<OrderListItemDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrderListItemDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrderListItemDtoPagingResultApiResultObject>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addSalesItem(body: CustomerSalesItemCreateCommand | undefined): Observable<ObjectApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/orders/add-sales-item";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddSalesItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddSalesItem(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResultObject>;
        }));
    }

    protected processAddSalesItem(response: HttpResponseBase): Observable<ObjectApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectApiResultObject>(null as any);
    }

    /**
     * @param ticketInvestmentId (optional) 
     * @return Success
     */
    getOrdersForShop(ticketInvestmentId: number | undefined): Observable<OrderListItemDtoListApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/orders/get-for-shop?";
        if (ticketInvestmentId === null)
            throw new Error("The parameter 'ticketInvestmentId' cannot be null.");
        else if (ticketInvestmentId !== undefined)
            url_ += "TicketInvestmentId=" + encodeURIComponent("" + ticketInvestmentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrdersForShop(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrdersForShop(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrderListItemDtoListApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrderListItemDtoListApiResultObject>;
        }));
    }

    protected processGetOrdersForShop(response: HttpResponseBase): Observable<OrderListItemDtoListApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrderListItemDtoListApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrderListItemDtoListApiResultObject>(null as any);
    }

    /**
     * @param orderId (optional) 
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getOrderDetails(orderId: number | undefined, maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<OrderDetailDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/orders/getOrderDetails?";
        if (orderId === null)
            throw new Error("The parameter 'orderId' cannot be null.");
        else if (orderId !== undefined)
            url_ += "OrderId=" + encodeURIComponent("" + orderId) + "&";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrderDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrderDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrderDetailDtoPagingResultApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrderDetailDtoPagingResultApiResultObject>;
        }));
    }

    protected processGetOrderDetails(response: HttpResponseBase): Observable<OrderDetailDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrderDetailDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrderDetailDtoPagingResultApiResultObject>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    validateSpoonCode(body: OrderValidateSpoonCodeCommand | undefined): Observable<ObjectApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/orders/validate-spoon-code";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidateSpoonCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidateSpoonCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResultObject>;
        }));
    }

    protected processValidateSpoonCode(response: HttpResponseBase): Observable<ObjectApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectApiResultObject>(null as any);
    }

    /**
     * @return Success
     */
    getPosmClass(id: number): Observable<PosmClassDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/posm-classes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPosmClass(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPosmClass(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PosmClassDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PosmClassDtoApiResultObject>;
        }));
    }

    protected processGetPosmClass(response: HttpResponseBase): Observable<PosmClassDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PosmClassDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PosmClassDtoApiResultObject>(null as any);
    }

    /**
     * @return Success
     */
    deletePosmClass(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/posm-classes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePosmClass(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePosmClass(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeletePosmClass(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updatePosmClass(id: number, body: PosmClassUpsertCommand | undefined): Observable<PosmClassDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/posm-classes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePosmClass(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePosmClass(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PosmClassDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PosmClassDtoApiResultObject>;
        }));
    }

    protected processUpdatePosmClass(response: HttpResponseBase): Observable<PosmClassDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PosmClassDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PosmClassDtoApiResultObject>(null as any);
    }

    /**
     * @param isActive (optional) 
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getPosmClasses(isActive: boolean | undefined, maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<PosmClassDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/posm-classes?";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPosmClasses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPosmClasses(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PosmClassDtoPagingResultApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PosmClassDtoPagingResultApiResultObject>;
        }));
    }

    protected processGetPosmClasses(response: HttpResponseBase): Observable<PosmClassDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PosmClassDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PosmClassDtoPagingResultApiResultObject>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createPosmClass(body: PosmClassUpsertCommand | undefined): Observable<PosmClassDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/posm-classes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePosmClass(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePosmClass(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PosmClassDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PosmClassDtoApiResultObject>;
        }));
    }

    protected processCreatePosmClass(response: HttpResponseBase): Observable<PosmClassDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PosmClassDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PosmClassDtoApiResultObject>(null as any);
    }

    /**
     * @return Success
     */
    getPosmInvestment(id: number): Observable<PosmInvestmentDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/posm-investments/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPosmInvestment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPosmInvestment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PosmInvestmentDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PosmInvestmentDtoApiResultObject>;
        }));
    }

    protected processGetPosmInvestment(response: HttpResponseBase): Observable<PosmInvestmentDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PosmInvestmentDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PosmInvestmentDtoApiResultObject>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    registerPosmInvestment(body: PosmInvestmentRegisterCommand | undefined): Observable<PosmInvestmentDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/posm-investments/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterPosmInvestment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterPosmInvestment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PosmInvestmentDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PosmInvestmentDtoApiResultObject>;
        }));
    }

    protected processRegisterPosmInvestment(response: HttpResponseBase): Observable<PosmInvestmentDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PosmInvestmentDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PosmInvestmentDtoApiResultObject>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    asmApprovePosmInvestment(id: number, body: PosmInvestmentAsmApproveCommand | undefined): Observable<ObjectApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/posm-investments/{id}/asm-approve";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAsmApprovePosmInvestment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAsmApprovePosmInvestment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResultObject>;
        }));
    }

    protected processAsmApprovePosmInvestment(response: HttpResponseBase): Observable<ObjectApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectApiResultObject>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    asmDenyPosmInvestment(id: number, body: PosmInvestmentAsmDenyCommand | undefined): Observable<ObjectApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/posm-investments/{id}/asm-deny";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAsmDenyPosmInvestment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAsmDenyPosmInvestment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResultObject>;
        }));
    }

    protected processAsmDenyPosmInvestment(response: HttpResponseBase): Observable<ObjectApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectApiResultObject>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    rsmApprovePosmInvestment(id: number, body: PosmInvestmentRsmApproveCommand | undefined): Observable<ObjectApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/posm-investments/{id}/rsm-approve";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRsmApprovePosmInvestment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRsmApprovePosmInvestment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResultObject>;
        }));
    }

    protected processRsmApprovePosmInvestment(response: HttpResponseBase): Observable<ObjectApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectApiResultObject>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    rsmDenyPosmInvestment(id: number, body: PosmInvestmentRsmDenyCommand | undefined): Observable<ObjectApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/posm-investments/{id}/rsm-deny";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRsmDenyPosmInvestment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRsmDenyPosmInvestment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResultObject>;
        }));
    }

    protected processRsmDenyPosmInvestment(response: HttpResponseBase): Observable<ObjectApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectApiResultObject>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    tradeApprovePosmInvestment(id: number, body: PosmInvestmentTradeApproveCommand | undefined): Observable<ObjectApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/posm-investments/{id}/trade-approve";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTradeApprovePosmInvestment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTradeApprovePosmInvestment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResultObject>;
        }));
    }

    protected processTradeApprovePosmInvestment(response: HttpResponseBase): Observable<ObjectApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectApiResultObject>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    tradeMultiApprovePosmInvestment(body: PosmInvestmentTradeMultiApproveCommand | undefined): Observable<ObjectApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/posm-investments/trade-multi-approve";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTradeMultiApprovePosmInvestment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTradeMultiApprovePosmInvestment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResultObject>;
        }));
    }

    protected processTradeMultiApprovePosmInvestment(response: HttpResponseBase): Observable<ObjectApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectApiResultObject>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    tradeDenyPosmInvestment(id: number, body: PosmInvestmentTradeDenyCommand | undefined): Observable<ObjectApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/posm-investments/{id}/trade-deny";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTradeDenyPosmInvestment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTradeDenyPosmInvestment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResultObject>;
        }));
    }

    protected processTradeDenyPosmInvestment(response: HttpResponseBase): Observable<ObjectApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectApiResultObject>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    tradeMultiDenyPosmInvestment(body: PosmInvestmentTradeMultiDenyCommand | undefined): Observable<ObjectApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/posm-investments/trade-multi-deny";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTradeMultiDenyPosmInvestment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTradeMultiDenyPosmInvestment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResultObject>;
        }));
    }

    protected processTradeMultiDenyPosmInvestment(response: HttpResponseBase): Observable<ObjectApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectApiResultObject>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    directorApprovePosmInvestment(id: number, body: PosmInvestmentDirectorApproveCommand | undefined): Observable<ObjectApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/posm-investments/{id}/director-approve";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDirectorApprovePosmInvestment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDirectorApprovePosmInvestment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResultObject>;
        }));
    }

    protected processDirectorApprovePosmInvestment(response: HttpResponseBase): Observable<ObjectApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectApiResultObject>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    directorMultiApprovePosmInvestment(body: PosmInvestmentDirectorMultiApproveCommand | undefined): Observable<ObjectApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/posm-investments/director-multi-approve";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDirectorMultiApprovePosmInvestment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDirectorMultiApprovePosmInvestment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResultObject>;
        }));
    }

    protected processDirectorMultiApprovePosmInvestment(response: HttpResponseBase): Observable<ObjectApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectApiResultObject>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    directorDenyPosmInvestment(id: number, body: PosmInvestmentDirectorDenyCommand | undefined): Observable<ObjectApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/posm-investments/{id}/director-deny";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDirectorDenyPosmInvestment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDirectorDenyPosmInvestment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResultObject>;
        }));
    }

    protected processDirectorDenyPosmInvestment(response: HttpResponseBase): Observable<ObjectApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectApiResultObject>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    directorMultiDenyPosmInvestment(body: PosmInvestmentDirectorMultiDenyCommand | undefined): Observable<ObjectApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/posm-investments/director-multi-deny";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDirectorMultiDenyPosmInvestment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDirectorMultiDenyPosmInvestment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResultObject>;
        }));
    }

    protected processDirectorMultiDenyPosmInvestment(response: HttpResponseBase): Observable<ObjectApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectApiResultObject>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    supplyApprovePosmInvestment(id: number, body: PosmInvestmentSupplyConfirmRequestCommand | undefined): Observable<ObjectApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/posm-investments/{id}/supply-confirm-request";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSupplyApprovePosmInvestment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSupplyApprovePosmInvestment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResultObject>;
        }));
    }

    protected processSupplyApprovePosmInvestment(response: HttpResponseBase): Observable<ObjectApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectApiResultObject>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    supplyDenyPosmInvestment(id: number, body: PosmInvestmentSupplyDenyRequestCommand | undefined): Observable<ObjectApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/posm-investments/{id}/supply-deny-request";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSupplyDenyPosmInvestment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSupplyDenyPosmInvestment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResultObject>;
        }));
    }

    protected processSupplyDenyPosmInvestment(response: HttpResponseBase): Observable<ObjectApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectApiResultObject>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    suggestBudget(id: number, body: PosmInvestmentSupSuggestCommand | undefined): Observable<ObjectApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/posm-investments/{id}/suggest-budget";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSuggestBudget(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSuggestBudget(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResultObject>;
        }));
    }

    protected processSuggestBudget(response: HttpResponseBase): Observable<ObjectApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectApiResultObject>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    asmConfirmSuggest(id: number, body: PosmInvestmentAsmConfirmSuggestCommand | undefined): Observable<ObjectApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/posm-investments/{id}/asm-confirm-suggest";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAsmConfirmSuggest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAsmConfirmSuggest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResultObject>;
        }));
    }

    protected processAsmConfirmSuggest(response: HttpResponseBase): Observable<ObjectApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectApiResultObject>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    rsmConfirmSuggest(id: number, body: PosmInvestmentRsmConfirmSuggestCommand | undefined): Observable<ObjectApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/posm-investments/{id}/rsm-confirm-suggest";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRsmConfirmSuggest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRsmConfirmSuggest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResultObject>;
        }));
    }

    protected processRsmConfirmSuggest(response: HttpResponseBase): Observable<ObjectApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectApiResultObject>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    tradeConfirmSuggest(id: number, body: PosmInvestmentTradeConfirmSuggestCommand | undefined): Observable<ObjectApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/posm-investments/{id}/trade-confirm-suggest";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTradeConfirmSuggest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTradeConfirmSuggest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResultObject>;
        }));
    }

    protected processTradeConfirmSuggest(response: HttpResponseBase): Observable<ObjectApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectApiResultObject>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    marketingConfirmProduce(id: number, body: PosmInvestmentMarketingConfirmProduceCommand | undefined): Observable<ObjectApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/posm-investments/{id}/marketing-confirm-produce";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMarketingConfirmProduce(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMarketingConfirmProduce(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResultObject>;
        }));
    }

    protected processMarketingConfirmProduce(response: HttpResponseBase): Observable<ObjectApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectApiResultObject>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    supConfirmProduce(id: number, body: PosmInvestmentSupConfirmProduceCommand | undefined): Observable<ObjectApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/posm-investments/{id}/sup-confirm-produce";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSupConfirmProduce(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSupConfirmProduce(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResultObject>;
        }));
    }

    protected processSupConfirmProduce(response: HttpResponseBase): Observable<ObjectApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectApiResultObject>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    supplyConfirmProduce(id: number, body: PosmInvestmentSupplyConfirmProduceCommand | undefined): Observable<ObjectApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/posm-investments/{id}/supply-confirm-produce";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSupplyConfirmProduce(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSupplyConfirmProduce(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResultObject>;
        }));
    }

    protected processSupplyConfirmProduce(response: HttpResponseBase): Observable<ObjectApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectApiResultObject>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    accept(id: number, body: PosmInvestmentSupAcceptCommand | undefined): Observable<ObjectApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/posm-investments/{id}/accept";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAccept(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAccept(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResultObject>;
        }));
    }

    protected processAccept(response: HttpResponseBase): Observable<ObjectApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectApiResultObject>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    confirmAccept1(id: number, body: PosmInvestmentAsmConfirmAcceptCommand | undefined): Observable<ObjectApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/posm-investments/{id}/confirm-accept-1";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConfirmAccept1(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfirmAccept1(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResultObject>;
        }));
    }

    protected processConfirmAccept1(response: HttpResponseBase): Observable<ObjectApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectApiResultObject>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    confirmAccept2(id: number, body: PosmInvestmentTradeConfirmAcceptCommand | undefined): Observable<ObjectApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/posm-investments/{id}/confirm-accept-2";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConfirmAccept2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfirmAccept2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResultObject>;
        }));
    }

    protected processConfirmAccept2(response: HttpResponseBase): Observable<ObjectApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectApiResultObject>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    multiConfirmAccept2(body: PosmInvestmentTradeMultiConfirmAcceptCommand | undefined): Observable<ObjectApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/posm-investments/multi-confirm-accept-2";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMultiConfirmAccept2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMultiConfirmAccept2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResultObject>;
        }));
    }

    protected processMultiConfirmAccept2(response: HttpResponseBase): Observable<ObjectApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectApiResultObject>(null as any);
    }

    /**
     * @param status (optional) 
     * @param cycleId (optional) 
     * @param staffId (optional) 
     * @param wardId (optional) 
     * @param districtId (optional) 
     * @param provinceId (optional) 
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getPosmInvestmentsByUser(status: number[] | undefined, cycleId: number | undefined, staffId: number | undefined, wardId: number | undefined, districtId: number | undefined, provinceId: number | undefined, maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<PosmInvestmentListDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/posm-investments/byuser?";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            status && status.forEach(item => { url_ += "Status=" + encodeURIComponent("" + item) + "&"; });
        if (cycleId === null)
            throw new Error("The parameter 'cycleId' cannot be null.");
        else if (cycleId !== undefined)
            url_ += "CycleId=" + encodeURIComponent("" + cycleId) + "&";
        if (staffId === null)
            throw new Error("The parameter 'staffId' cannot be null.");
        else if (staffId !== undefined)
            url_ += "StaffId=" + encodeURIComponent("" + staffId) + "&";
        if (wardId === null)
            throw new Error("The parameter 'wardId' cannot be null.");
        else if (wardId !== undefined)
            url_ += "WardId=" + encodeURIComponent("" + wardId) + "&";
        if (districtId === null)
            throw new Error("The parameter 'districtId' cannot be null.");
        else if (districtId !== undefined)
            url_ += "DistrictId=" + encodeURIComponent("" + districtId) + "&";
        if (provinceId === null)
            throw new Error("The parameter 'provinceId' cannot be null.");
        else if (provinceId !== undefined)
            url_ += "ProvinceId=" + encodeURIComponent("" + provinceId) + "&";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPosmInvestmentsByUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPosmInvestmentsByUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PosmInvestmentListDtoPagingResultApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PosmInvestmentListDtoPagingResultApiResultObject>;
        }));
    }

    protected processGetPosmInvestmentsByUser(response: HttpResponseBase): Observable<PosmInvestmentListDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PosmInvestmentListDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PosmInvestmentListDtoPagingResultApiResultObject>(null as any);
    }

    /**
     * @return Success
     */
    getPosmInvestmentItem(id: number): Observable<PosmInvestmentItemDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/posm-investments/items/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPosmInvestmentItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPosmInvestmentItem(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PosmInvestmentItemDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PosmInvestmentItemDtoApiResultObject>;
        }));
    }

    protected processGetPosmInvestmentItem(response: HttpResponseBase): Observable<PosmInvestmentItemDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PosmInvestmentItemDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PosmInvestmentItemDtoApiResultObject>(null as any);
    }

    /**
     * @return Success
     */
    getPosmInvestmentItemOperation(id: number): Observable<PosmInvestmentItemOperationDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/posm-investments/items/{id}/operation";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPosmInvestmentItemOperation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPosmInvestmentItemOperation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PosmInvestmentItemOperationDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PosmInvestmentItemOperationDtoApiResultObject>;
        }));
    }

    protected processGetPosmInvestmentItemOperation(response: HttpResponseBase): Observable<PosmInvestmentItemOperationDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PosmInvestmentItemOperationDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PosmInvestmentItemOperationDtoApiResultObject>(null as any);
    }

    /**
     * @return Success
     */
    getPosmInvestmentItemHistory(id: number): Observable<PosmInvestmentItemHistoryDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/posm-investments/items/{id}/history";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPosmInvestmentItemHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPosmInvestmentItemHistory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PosmInvestmentItemHistoryDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PosmInvestmentItemHistoryDtoApiResultObject>;
        }));
    }

    protected processGetPosmInvestmentItemHistory(response: HttpResponseBase): Observable<PosmInvestmentItemHistoryDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PosmInvestmentItemHistoryDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PosmInvestmentItemHistoryDtoApiResultObject>(null as any);
    }

    /**
     * @return Success
     */
    getPosmInvestmentItemOperationImage(id: number, index: number): Observable<PosmInvestmentItemHistoryDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/posm-investments/items/{id}/operation-images/{index}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (index === undefined || index === null)
            throw new Error("The parameter 'index' must be defined.");
        url_ = url_.replace("{index}", encodeURIComponent("" + index));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPosmInvestmentItemOperationImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPosmInvestmentItemOperationImage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PosmInvestmentItemHistoryDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PosmInvestmentItemHistoryDtoApiResultObject>;
        }));
    }

    protected processGetPosmInvestmentItemOperationImage(response: HttpResponseBase): Observable<PosmInvestmentItemHistoryDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PosmInvestmentItemHistoryDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PosmInvestmentItemHistoryDtoApiResultObject>(null as any);
    }

    /**
     * @return Success
     */
    getPosmInvestmentItemSurveyImage(id: number, index: number): Observable<PosmInvestmentItemHistoryDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/posm-investments/items/{id}/survey-images/{index}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (index === undefined || index === null)
            throw new Error("The parameter 'index' must be defined.");
        url_ = url_.replace("{index}", encodeURIComponent("" + index));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPosmInvestmentItemSurveyImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPosmInvestmentItemSurveyImage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PosmInvestmentItemHistoryDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PosmInvestmentItemHistoryDtoApiResultObject>;
        }));
    }

    protected processGetPosmInvestmentItemSurveyImage(response: HttpResponseBase): Observable<PosmInvestmentItemHistoryDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PosmInvestmentItemHistoryDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PosmInvestmentItemHistoryDtoApiResultObject>(null as any);
    }

    /**
     * @param status (optional) 
     * @param cycleId (optional) 
     * @param staffId (optional) 
     * @param wardId (optional) 
     * @param districtId (optional) 
     * @param provinceId (optional) 
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getPosmInvestmentItemsByUser(status: number[] | undefined, cycleId: number | undefined, staffId: number | undefined, wardId: number | undefined, districtId: number | undefined, provinceId: number | undefined, maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<PosmInvestmentItemExtDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/posm-investments/items/byuser?";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            status && status.forEach(item => { url_ += "Status=" + encodeURIComponent("" + item) + "&"; });
        if (cycleId === null)
            throw new Error("The parameter 'cycleId' cannot be null.");
        else if (cycleId !== undefined)
            url_ += "CycleId=" + encodeURIComponent("" + cycleId) + "&";
        if (staffId === null)
            throw new Error("The parameter 'staffId' cannot be null.");
        else if (staffId !== undefined)
            url_ += "StaffId=" + encodeURIComponent("" + staffId) + "&";
        if (wardId === null)
            throw new Error("The parameter 'wardId' cannot be null.");
        else if (wardId !== undefined)
            url_ += "WardId=" + encodeURIComponent("" + wardId) + "&";
        if (districtId === null)
            throw new Error("The parameter 'districtId' cannot be null.");
        else if (districtId !== undefined)
            url_ += "DistrictId=" + encodeURIComponent("" + districtId) + "&";
        if (provinceId === null)
            throw new Error("The parameter 'provinceId' cannot be null.");
        else if (provinceId !== undefined)
            url_ += "ProvinceId=" + encodeURIComponent("" + provinceId) + "&";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPosmInvestmentItemsByUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPosmInvestmentItemsByUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PosmInvestmentItemExtDtoPagingResultApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PosmInvestmentItemExtDtoPagingResultApiResultObject>;
        }));
    }

    protected processGetPosmInvestmentItemsByUser(response: HttpResponseBase): Observable<PosmInvestmentItemExtDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PosmInvestmentItemExtDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PosmInvestmentItemExtDtoPagingResultApiResultObject>(null as any);
    }

    /**
     * @param customerId (optional) 
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getPosmInvestmentItemsByCustomer(customerId: number | undefined, maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<PosmInvestmentItemExtDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/posm-investments/items/bycustomer?";
        if (customerId === null)
            throw new Error("The parameter 'customerId' cannot be null.");
        else if (customerId !== undefined)
            url_ += "CustomerId=" + encodeURIComponent("" + customerId) + "&";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPosmInvestmentItemsByCustomer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPosmInvestmentItemsByCustomer(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PosmInvestmentItemExtDtoPagingResultApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PosmInvestmentItemExtDtoPagingResultApiResultObject>;
        }));
    }

    protected processGetPosmInvestmentItemsByCustomer(response: HttpResponseBase): Observable<PosmInvestmentItemExtDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PosmInvestmentItemExtDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PosmInvestmentItemExtDtoPagingResultApiResultObject>(null as any);
    }

    /**
     * @param status (optional) 
     * @param rsmStaffId (optional) 
     * @param asmStaffId (optional) 
     * @param salesSupervisorStaffId (optional) 
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getPosmInvestmentsByTime(status: number[] | undefined, rsmStaffId: number | undefined, asmStaffId: number | undefined, salesSupervisorStaffId: number | undefined, fromDate: Date | undefined, toDate: Date | undefined, maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<PosmInvestmentListDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/posm-investments/bytime?";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            status && status.forEach(item => { url_ += "Status=" + encodeURIComponent("" + item) + "&"; });
        if (rsmStaffId === null)
            throw new Error("The parameter 'rsmStaffId' cannot be null.");
        else if (rsmStaffId !== undefined)
            url_ += "RsmStaffId=" + encodeURIComponent("" + rsmStaffId) + "&";
        if (asmStaffId === null)
            throw new Error("The parameter 'asmStaffId' cannot be null.");
        else if (asmStaffId !== undefined)
            url_ += "AsmStaffId=" + encodeURIComponent("" + asmStaffId) + "&";
        if (salesSupervisorStaffId === null)
            throw new Error("The parameter 'salesSupervisorStaffId' cannot be null.");
        else if (salesSupervisorStaffId !== undefined)
            url_ += "SalesSupervisorStaffId=" + encodeURIComponent("" + salesSupervisorStaffId) + "&";
        if (fromDate === null)
            throw new Error("The parameter 'fromDate' cannot be null.");
        else if (fromDate !== undefined)
            url_ += "FromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toISOString() : "") + "&";
        if (toDate === null)
            throw new Error("The parameter 'toDate' cannot be null.");
        else if (toDate !== undefined)
            url_ += "ToDate=" + encodeURIComponent(toDate ? "" + toDate.toISOString() : "") + "&";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPosmInvestmentsByTime(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPosmInvestmentsByTime(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PosmInvestmentListDtoPagingResultApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PosmInvestmentListDtoPagingResultApiResultObject>;
        }));
    }

    protected processGetPosmInvestmentsByTime(response: HttpResponseBase): Observable<PosmInvestmentListDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PosmInvestmentListDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PosmInvestmentListDtoPagingResultApiResultObject>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    salesRemarkPosmInvestment(id: number, body: PosmInvestmentSalesRemarkCommand | undefined): Observable<ObjectApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/posm-investments/{id}/sales-remark";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSalesRemarkPosmInvestment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSalesRemarkPosmInvestment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResultObject>;
        }));
    }

    protected processSalesRemarkPosmInvestment(response: HttpResponseBase): Observable<ObjectApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectApiResultObject>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    companyRemarkPosmInvestment(id: number, body: PosmInvestmentCompanyRemarkCommand | undefined): Observable<ObjectApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/posm-investments/{id}/company-remark";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCompanyRemarkPosmInvestment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCompanyRemarkPosmInvestment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResultObject>;
        }));
    }

    protected processCompanyRemarkPosmInvestment(response: HttpResponseBase): Observable<ObjectApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectApiResultObject>(null as any);
    }

    /**
     * @param contentType (optional) 
     * @param contentDisposition (optional) 
     * @param headers (optional) 
     * @param length (optional) 
     * @param name (optional) 
     * @param fileName (optional) 
     * @return Success
     */
    importPosmInvestment(contentType: string | undefined, contentDisposition: string | undefined, headers: { [key: string]: string[]; } | undefined, length: number | undefined, name: string | undefined, fileName: string | undefined): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/posm-investments/import";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (contentType === null || contentType === undefined)
            throw new Error("The parameter 'contentType' cannot be null.");
        else
            content_.append("ContentType", contentType.toString());
        if (contentDisposition === null || contentDisposition === undefined)
            throw new Error("The parameter 'contentDisposition' cannot be null.");
        else
            content_.append("ContentDisposition", contentDisposition.toString());
        if (headers === null || headers === undefined)
            throw new Error("The parameter 'headers' cannot be null.");
        else
            content_.append("Headers", JSON.stringify(headers));
        if (length === null || length === undefined)
            throw new Error("The parameter 'length' cannot be null.");
        else
            content_.append("Length", length.toString());
        if (name === null || name === undefined)
            throw new Error("The parameter 'name' cannot be null.");
        else
            content_.append("Name", name.toString());
        if (fileName === null || fileName === undefined)
            throw new Error("The parameter 'fileName' cannot be null.");
        else
            content_.append("FileName", fileName.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportPosmInvestment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportPosmInvestment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processImportPosmInvestment(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(null as any);
    }

    /**
     * @return Success
     */
    getPosmItem(id: number): Observable<PosmItemDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/posm-items/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPosmItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPosmItem(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PosmItemDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PosmItemDtoApiResultObject>;
        }));
    }

    protected processGetPosmItem(response: HttpResponseBase): Observable<PosmItemDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PosmItemDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PosmItemDtoApiResultObject>(null as any);
    }

    /**
     * @return Success
     */
    deletePosmItem(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/posm-items/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePosmItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePosmItem(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeletePosmItem(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updatePosmItem(id: number, body: PosmItemUpsertCommand | undefined): Observable<PosmItemDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/posm-items/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePosmItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePosmItem(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PosmItemDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PosmItemDtoApiResultObject>;
        }));
    }

    protected processUpdatePosmItem(response: HttpResponseBase): Observable<PosmItemDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PosmItemDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PosmItemDtoApiResultObject>(null as any);
    }

    /**
     * @param isActive (optional) 
     * @param posmClassId (optional) 
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getPosmItems(isActive: boolean | undefined, posmClassId: number | undefined, maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<PosmItemListDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/posm-items?";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (posmClassId === null)
            throw new Error("The parameter 'posmClassId' cannot be null.");
        else if (posmClassId !== undefined)
            url_ += "PosmClassId=" + encodeURIComponent("" + posmClassId) + "&";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPosmItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPosmItems(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PosmItemListDtoPagingResultApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PosmItemListDtoPagingResultApiResultObject>;
        }));
    }

    protected processGetPosmItems(response: HttpResponseBase): Observable<PosmItemListDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PosmItemListDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PosmItemListDtoPagingResultApiResultObject>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createPosmItem(body: PosmItemUpsertCommand | undefined): Observable<PosmItemDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/posm-items";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePosmItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePosmItem(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PosmItemDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PosmItemDtoApiResultObject>;
        }));
    }

    protected processCreatePosmItem(response: HttpResponseBase): Observable<PosmItemDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PosmItemDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PosmItemDtoApiResultObject>(null as any);
    }

    /**
     * @return Success
     */
    getPosmItemPrice(id: number): Observable<number> {
        let url_ = this.baseUrl + "/api/v1/posm-items/{id}/price";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPosmItemPrice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPosmItemPrice(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetPosmItemPrice(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * @return Success
     */
    getPosmCatalogs(id: number): Observable<PosmCatalogListDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/posm-items/{id}/catalogs";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPosmCatalogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPosmCatalogs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PosmCatalogListDtoPagingResultApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PosmCatalogListDtoPagingResultApiResultObject>;
        }));
    }

    protected processGetPosmCatalogs(response: HttpResponseBase): Observable<PosmCatalogListDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PosmCatalogListDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PosmCatalogListDtoPagingResultApiResultObject>(null as any);
    }

    /**
     * @return Success
     */
    getPosmCatalog(id: number): Observable<PosmCatalogDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/posm-items/catalogs/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPosmCatalog(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPosmCatalog(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PosmCatalogDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PosmCatalogDtoApiResultObject>;
        }));
    }

    protected processGetPosmCatalog(response: HttpResponseBase): Observable<PosmCatalogDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PosmCatalogDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PosmCatalogDtoApiResultObject>(null as any);
    }

    /**
     * @return Success
     */
    exportPosmItem(): Observable<Stream> {
        let url_ = this.baseUrl + "/api/v1/posm-items/export";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportPosmItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportPosmItem(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Stream>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Stream>;
        }));
    }

    protected processExportPosmItem(response: HttpResponseBase): Observable<Stream> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Stream.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Stream>(null as any);
    }

    /**
     * @param contentType (optional) 
     * @param contentDisposition (optional) 
     * @param headers (optional) 
     * @param length (optional) 
     * @param name (optional) 
     * @param fileName (optional) 
     * @return Success
     */
    importPosmItem(contentType: string | undefined, contentDisposition: string | undefined, headers: { [key: string]: string[]; } | undefined, length: number | undefined, name: string | undefined, fileName: string | undefined): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/posm-items/import";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (contentType === null || contentType === undefined)
            throw new Error("The parameter 'contentType' cannot be null.");
        else
            content_.append("ContentType", contentType.toString());
        if (contentDisposition === null || contentDisposition === undefined)
            throw new Error("The parameter 'contentDisposition' cannot be null.");
        else
            content_.append("ContentDisposition", contentDisposition.toString());
        if (headers === null || headers === undefined)
            throw new Error("The parameter 'headers' cannot be null.");
        else
            content_.append("Headers", JSON.stringify(headers));
        if (length === null || length === undefined)
            throw new Error("The parameter 'length' cannot be null.");
        else
            content_.append("Length", length.toString());
        if (name === null || name === undefined)
            throw new Error("The parameter 'name' cannot be null.");
        else
            content_.append("Name", name.toString());
        if (fileName === null || fileName === undefined)
            throw new Error("The parameter 'fileName' cannot be null.");
        else
            content_.append("FileName", fileName.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportPosmItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportPosmItem(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processImportPosmItem(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(null as any);
    }

    /**
     * @return Success
     */
    getPosmPrice(id: number): Observable<PosmPriceHeaderDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/posm-prices/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPosmPrice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPosmPrice(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PosmPriceHeaderDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PosmPriceHeaderDtoApiResultObject>;
        }));
    }

    protected processGetPosmPrice(response: HttpResponseBase): Observable<PosmPriceHeaderDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PosmPriceHeaderDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PosmPriceHeaderDtoApiResultObject>(null as any);
    }

    /**
     * @return Success
     */
    deletePosmPrice(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/posm-prices/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePosmPrice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePosmPrice(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeletePosmPrice(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updatePosmPrice(id: number, body: PosmPriceUpsertCommand | undefined): Observable<PosmPriceHeaderDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/posm-prices/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePosmPrice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePosmPrice(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PosmPriceHeaderDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PosmPriceHeaderDtoApiResultObject>;
        }));
    }

    protected processUpdatePosmPrice(response: HttpResponseBase): Observable<PosmPriceHeaderDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PosmPriceHeaderDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PosmPriceHeaderDtoApiResultObject>(null as any);
    }

    /**
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param isActive (optional) 
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getPosmPrices(fromDate: Date | undefined, toDate: Date | undefined, isActive: boolean | undefined, maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<PosmPriceHeaderListDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/posm-prices?";
        if (fromDate === null)
            throw new Error("The parameter 'fromDate' cannot be null.");
        else if (fromDate !== undefined)
            url_ += "FromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toISOString() : "") + "&";
        if (toDate === null)
            throw new Error("The parameter 'toDate' cannot be null.");
        else if (toDate !== undefined)
            url_ += "ToDate=" + encodeURIComponent(toDate ? "" + toDate.toISOString() : "") + "&";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPosmPrices(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPosmPrices(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PosmPriceHeaderListDtoPagingResultApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PosmPriceHeaderListDtoPagingResultApiResultObject>;
        }));
    }

    protected processGetPosmPrices(response: HttpResponseBase): Observable<PosmPriceHeaderListDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PosmPriceHeaderListDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PosmPriceHeaderListDtoPagingResultApiResultObject>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createPosmPrice(body: PosmPriceUpsertCommand | undefined): Observable<PosmPriceHeaderDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/posm-prices";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePosmPrice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePosmPrice(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PosmPriceHeaderDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PosmPriceHeaderDtoApiResultObject>;
        }));
    }

    protected processCreatePosmPrice(response: HttpResponseBase): Observable<PosmPriceHeaderDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PosmPriceHeaderDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PosmPriceHeaderDtoApiResultObject>(null as any);
    }

    /**
     * @return Success
     */
    exportPosmPrice(): Observable<Stream> {
        let url_ = this.baseUrl + "/api/v1/posm-prices/export";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportPosmPrice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportPosmPrice(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Stream>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Stream>;
        }));
    }

    protected processExportPosmPrice(response: HttpResponseBase): Observable<Stream> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Stream.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Stream>(null as any);
    }

    /**
     * @param contentType (optional) 
     * @param contentDisposition (optional) 
     * @param headers (optional) 
     * @param length (optional) 
     * @param name (optional) 
     * @param fileName (optional) 
     * @return Success
     */
    importPosmPrice(contentType: string | undefined, contentDisposition: string | undefined, headers: { [key: string]: string[]; } | undefined, length: number | undefined, name: string | undefined, fileName: string | undefined): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/posm-prices/import";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (contentType === null || contentType === undefined)
            throw new Error("The parameter 'contentType' cannot be null.");
        else
            content_.append("ContentType", contentType.toString());
        if (contentDisposition === null || contentDisposition === undefined)
            throw new Error("The parameter 'contentDisposition' cannot be null.");
        else
            content_.append("ContentDisposition", contentDisposition.toString());
        if (headers === null || headers === undefined)
            throw new Error("The parameter 'headers' cannot be null.");
        else
            content_.append("Headers", JSON.stringify(headers));
        if (length === null || length === undefined)
            throw new Error("The parameter 'length' cannot be null.");
        else
            content_.append("Length", length.toString());
        if (name === null || name === undefined)
            throw new Error("The parameter 'name' cannot be null.");
        else
            content_.append("Name", name.toString());
        if (fileName === null || fileName === undefined)
            throw new Error("The parameter 'fileName' cannot be null.");
        else
            content_.append("FileName", fileName.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportPosmPrice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportPosmPrice(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processImportPosmPrice(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(null as any);
    }

    /**
     * @return Success
     */
    getPosmType(id: number): Observable<PosmTypeDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/posm-types/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPosmType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPosmType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PosmTypeDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PosmTypeDtoApiResultObject>;
        }));
    }

    protected processGetPosmType(response: HttpResponseBase): Observable<PosmTypeDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PosmTypeDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PosmTypeDtoApiResultObject>(null as any);
    }

    /**
     * @return Success
     */
    deletePosmType(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/posm-types/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePosmType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePosmType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeletePosmType(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updatePosmType(id: number, body: PosmTypeUpsertCommand | undefined): Observable<PosmTypeDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/posm-types/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePosmType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePosmType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PosmTypeDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PosmTypeDtoApiResultObject>;
        }));
    }

    protected processUpdatePosmType(response: HttpResponseBase): Observable<PosmTypeDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PosmTypeDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PosmTypeDtoApiResultObject>(null as any);
    }

    /**
     * @param isActive (optional) 
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getPosmTypes(isActive: boolean | undefined, maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<PosmTypeDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/posm-types?";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPosmTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPosmTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PosmTypeDtoPagingResultApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PosmTypeDtoPagingResultApiResultObject>;
        }));
    }

    protected processGetPosmTypes(response: HttpResponseBase): Observable<PosmTypeDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PosmTypeDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PosmTypeDtoPagingResultApiResultObject>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createPosmType(body: PosmTypeUpsertCommand | undefined): Observable<PosmTypeDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/posm-types";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePosmType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePosmType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PosmTypeDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PosmTypeDtoApiResultObject>;
        }));
    }

    protected processCreatePosmType(response: HttpResponseBase): Observable<PosmTypeDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PosmTypeDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PosmTypeDtoApiResultObject>(null as any);
    }

    /**
     * @return Success
     */
    getProduct(id: number): Observable<ProductBaseDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/products/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProduct(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductBaseDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductBaseDtoApiResultObject>;
        }));
    }

    protected processGetProduct(response: HttpResponseBase): Observable<ProductBaseDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductBaseDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductBaseDtoApiResultObject>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateProduct(id: number, body: UpsertProductCommand | undefined): Observable<ProductBaseDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/products/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateProduct(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductBaseDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductBaseDtoApiResultObject>;
        }));
    }

    protected processUpdateProduct(response: HttpResponseBase): Observable<ProductBaseDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductBaseDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductBaseDtoApiResultObject>(null as any);
    }

    /**
     * @return Success
     */
    getProductItem(id: number): Observable<ProductItemDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/products/item/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductItem(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductItemDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductItemDtoApiResultObject>;
        }));
    }

    protected processGetProductItem(response: HttpResponseBase): Observable<ProductItemDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductItemDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductItemDtoApiResultObject>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateProductItem(id: number, body: UpsertProductItemCommand | undefined): Observable<ProductItemDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/products/item/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateProductItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateProductItem(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductItemDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductItemDtoApiResultObject>;
        }));
    }

    protected processUpdateProductItem(response: HttpResponseBase): Observable<ProductItemDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductItemDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductItemDtoApiResultObject>(null as any);
    }

    /**
     * @param isActive (optional) 
     * @param productClassCode (optional) 
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getProducts(isActive: boolean | undefined, productClassCode: string | undefined, maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<ProductListItemDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/products?";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (productClassCode === null)
            throw new Error("The parameter 'productClassCode' cannot be null.");
        else if (productClassCode !== undefined)
            url_ += "ProductClassCode=" + encodeURIComponent("" + productClassCode) + "&";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProducts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProducts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductListItemDtoPagingResultApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductListItemDtoPagingResultApiResultObject>;
        }));
    }

    protected processGetProducts(response: HttpResponseBase): Observable<ProductListItemDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductListItemDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductListItemDtoPagingResultApiResultObject>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createProduct(body: UpsertProductCommand | undefined): Observable<ProductBaseDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/products";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateProduct(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductBaseDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductBaseDtoApiResultObject>;
        }));
    }

    protected processCreateProduct(response: HttpResponseBase): Observable<ProductBaseDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductBaseDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductBaseDtoApiResultObject>(null as any);
    }

    /**
     * @param isActive (optional) 
     * @param classId (optional) 
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getProductItemClasses(isActive: boolean | undefined, classId: number | undefined, maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<ProductListItemDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/products/itembyclass?";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (classId === null)
            throw new Error("The parameter 'classId' cannot be null.");
        else if (classId !== undefined)
            url_ += "ClassId=" + encodeURIComponent("" + classId) + "&";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductItemClasses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductItemClasses(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductListItemDtoPagingResultApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductListItemDtoPagingResultApiResultObject>;
        }));
    }

    protected processGetProductItemClasses(response: HttpResponseBase): Observable<ProductListItemDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductListItemDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductListItemDtoPagingResultApiResultObject>(null as any);
    }

    /**
     * @param qrCode (optional) 
     * @param smallUnitRequire (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    findProductByQrCode(qrCode: string | undefined, smallUnitRequire: boolean | undefined, queryId: string | undefined): Observable<ProductInfoDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/products/find?";
        if (qrCode === null)
            throw new Error("The parameter 'qrCode' cannot be null.");
        else if (qrCode !== undefined)
            url_ += "QrCode=" + encodeURIComponent("" + qrCode) + "&";
        if (smallUnitRequire === null)
            throw new Error("The parameter 'smallUnitRequire' cannot be null.");
        else if (smallUnitRequire !== undefined)
            url_ += "SmallUnitRequire=" + encodeURIComponent("" + smallUnitRequire) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindProductByQrCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindProductByQrCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductInfoDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductInfoDtoApiResultObject>;
        }));
    }

    protected processFindProductByQrCode(response: HttpResponseBase): Observable<ProductInfoDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductInfoDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductInfoDtoApiResultObject>(null as any);
    }

    /**
     * @return Success
     */
    getProductClass(id: number): Observable<ProductClassDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/product-classes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductClass(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductClass(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductClassDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductClassDtoApiResultObject>;
        }));
    }

    protected processGetProductClass(response: HttpResponseBase): Observable<ProductClassDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductClassDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductClassDtoApiResultObject>(null as any);
    }

    /**
     * @return Success
     */
    deleteProductClass(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/product-classes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteProductClass(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteProductClass(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteProductClass(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateProductClass(id: number, body: UpsertProductClassCommand | undefined): Observable<ProductClassDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/product-classes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateProductClass(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateProductClass(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductClassDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductClassDtoApiResultObject>;
        }));
    }

    protected processUpdateProductClass(response: HttpResponseBase): Observable<ProductClassDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductClassDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductClassDtoApiResultObject>(null as any);
    }

    /**
     * @param isActive (optional) 
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getProductClasses(isActive: boolean | undefined, maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<ProductClassDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/product-classes?";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductClasses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductClasses(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductClassDtoPagingResultApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductClassDtoPagingResultApiResultObject>;
        }));
    }

    protected processGetProductClasses(response: HttpResponseBase): Observable<ProductClassDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductClassDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductClassDtoPagingResultApiResultObject>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createProductClass(body: UpsertProductClassCommand | undefined): Observable<ProductClassDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/product-classes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateProductClass(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateProductClass(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductClassDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductClassDtoApiResultObject>;
        }));
    }

    protected processCreateProductClass(response: HttpResponseBase): Observable<ProductClassDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductClassDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductClassDtoApiResultObject>(null as any);
    }

    /**
     * @return Success
     */
    getProductPoint(id: number): Observable<ProductPointDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/product-points/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductPoint(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductPoint(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductPointDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductPointDtoApiResultObject>;
        }));
    }

    protected processGetProductPoint(response: HttpResponseBase): Observable<ProductPointDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductPointDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductPointDtoApiResultObject>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateProductPoint(id: number, body: ProductPointUpsertCommand | undefined): Observable<ProductPointDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/product-points/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateProductPoint(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateProductPoint(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductPointDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductPointDtoApiResultObject>;
        }));
    }

    protected processUpdateProductPoint(response: HttpResponseBase): Observable<ProductPointDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductPointDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductPointDtoApiResultObject>(null as any);
    }

    /**
     * @return Success
     */
    deleteProductPoint(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/product-points/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteProductPoint(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteProductPoint(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteProductPoint(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param productClassId (optional) 
     * @param isActive (optional) 
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getProductPoints(productClassId: number | undefined, isActive: boolean | undefined, maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<ProductPointListItemDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/product-points?";
        if (productClassId === null)
            throw new Error("The parameter 'productClassId' cannot be null.");
        else if (productClassId !== undefined)
            url_ += "ProductClassId=" + encodeURIComponent("" + productClassId) + "&";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductPoints(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductPoints(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductPointListItemDtoPagingResultApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductPointListItemDtoPagingResultApiResultObject>;
        }));
    }

    protected processGetProductPoints(response: HttpResponseBase): Observable<ProductPointListItemDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductPointListItemDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductPointListItemDtoPagingResultApiResultObject>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createProductPoint(body: ProductPointUpsertCommand | undefined): Observable<ProductPointDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/product-points";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateProductPoint(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateProductPoint(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductPointDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductPointDtoApiResultObject>;
        }));
    }

    protected processCreateProductPoint(response: HttpResponseBase): Observable<ProductPointDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductPointDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductPointDtoApiResultObject>(null as any);
    }

    /**
     * @return Success
     */
    exportProductPoint(): Observable<Stream> {
        let url_ = this.baseUrl + "/api/v1/product-points/export";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportProductPoint(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportProductPoint(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Stream>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Stream>;
        }));
    }

    protected processExportProductPoint(response: HttpResponseBase): Observable<Stream> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Stream.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Stream>(null as any);
    }

    /**
     * @param contentType (optional) 
     * @param contentDisposition (optional) 
     * @param headers (optional) 
     * @param length (optional) 
     * @param name (optional) 
     * @param fileName (optional) 
     * @return Success
     */
    importProductPoint(contentType: string | undefined, contentDisposition: string | undefined, headers: { [key: string]: string[]; } | undefined, length: number | undefined, name: string | undefined, fileName: string | undefined): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/product-points/import";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (contentType === null || contentType === undefined)
            throw new Error("The parameter 'contentType' cannot be null.");
        else
            content_.append("ContentType", contentType.toString());
        if (contentDisposition === null || contentDisposition === undefined)
            throw new Error("The parameter 'contentDisposition' cannot be null.");
        else
            content_.append("ContentDisposition", contentDisposition.toString());
        if (headers === null || headers === undefined)
            throw new Error("The parameter 'headers' cannot be null.");
        else
            content_.append("Headers", JSON.stringify(headers));
        if (length === null || length === undefined)
            throw new Error("The parameter 'length' cannot be null.");
        else
            content_.append("Length", length.toString());
        if (name === null || name === undefined)
            throw new Error("The parameter 'name' cannot be null.");
        else
            content_.append("Name", name.toString());
        if (fileName === null || fileName === undefined)
            throw new Error("The parameter 'fileName' cannot be null.");
        else
            content_.append("FileName", fileName.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportProductPoint(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportProductPoint(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processImportProductPoint(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(null as any);
    }

    /**
     * @return Success
     */
    getProductUnit(id: number): Observable<ProductUnitDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/productUnits/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductUnit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductUnitDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductUnitDtoApiResultObject>;
        }));
    }

    protected processGetProductUnit(response: HttpResponseBase): Observable<ProductUnitDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductUnitDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductUnitDtoApiResultObject>(null as any);
    }

    /**
     * @return Success
     */
    deleteProductUnit(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/productUnits/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteProductUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteProductUnit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteProductUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateProductUnit(id: number, body: UpsertProductUnitCommand | undefined): Observable<ProductUnitDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/productUnits/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateProductUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateProductUnit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductUnitDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductUnitDtoApiResultObject>;
        }));
    }

    protected processUpdateProductUnit(response: HttpResponseBase): Observable<ProductUnitDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductUnitDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductUnitDtoApiResultObject>(null as any);
    }

    /**
     * @param productId (optional) 
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getProductUnits(productId: number | undefined, maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<ProductUnitDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/productUnits?";
        if (productId === null)
            throw new Error("The parameter 'productId' cannot be null.");
        else if (productId !== undefined)
            url_ += "ProductId=" + encodeURIComponent("" + productId) + "&";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductUnits(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductUnits(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductUnitDtoPagingResultApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductUnitDtoPagingResultApiResultObject>;
        }));
    }

    protected processGetProductUnits(response: HttpResponseBase): Observable<ProductUnitDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductUnitDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductUnitDtoPagingResultApiResultObject>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createProductUnit(body: UpsertProductUnitCommand | undefined): Observable<ProductUnitDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/productUnits";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateProductUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateProductUnit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductUnitDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductUnitDtoApiResultObject>;
        }));
    }

    protected processCreateProductUnit(response: HttpResponseBase): Observable<ProductUnitDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductUnitDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductUnitDtoApiResultObject>(null as any);
    }

    /**
     * @param params (optional) 
     * @return Success
     */
    report(params: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/Report?";
        if (params === null)
            throw new Error("The parameter 'params' cannot be null.");
        else if (params !== undefined)
            url_ += "params=" + encodeURIComponent("" + params) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processReport(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getRewardPackage(id: number): Observable<RewardPackageDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/rewardPackages/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRewardPackage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRewardPackage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RewardPackageDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RewardPackageDtoApiResultObject>;
        }));
    }

    protected processGetRewardPackage(response: HttpResponseBase): Observable<RewardPackageDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RewardPackageDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RewardPackageDtoApiResultObject>(null as any);
    }

    /**
     * @return Success
     */
    deleteRewardPackage(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/rewardPackages/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRewardPackage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRewardPackage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteRewardPackage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateRewardPackage(id: number, body: RewardPackageUpsertCommand | undefined): Observable<RewardPackageDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/rewardPackages/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateRewardPackage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateRewardPackage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RewardPackageDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RewardPackageDtoApiResultObject>;
        }));
    }

    protected processUpdateRewardPackage(response: HttpResponseBase): Observable<RewardPackageDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RewardPackageDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RewardPackageDtoApiResultObject>(null as any);
    }

    /**
     * @param isActive (optional) 
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getRewardPackages(isActive: boolean | undefined, maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<RewardPackageListDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/rewardPackages?";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRewardPackages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRewardPackages(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RewardPackageListDtoPagingResultApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RewardPackageListDtoPagingResultApiResultObject>;
        }));
    }

    protected processGetRewardPackages(response: HttpResponseBase): Observable<RewardPackageListDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RewardPackageListDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RewardPackageListDtoPagingResultApiResultObject>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createRewardPackage(body: RewardPackageUpsertCommand | undefined): Observable<RewardPackageDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/rewardPackages";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateRewardPackage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateRewardPackage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RewardPackageDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RewardPackageDtoApiResultObject>;
        }));
    }

    protected processCreateRewardPackage(response: HttpResponseBase): Observable<RewardPackageDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RewardPackageDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RewardPackageDtoApiResultObject>(null as any);
    }

    /**
     * @param type (optional) 
     * @param customerId (optional) 
     * @param isActive (optional) 
     * @param validDate (optional) 
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getRewardPackageListByTypeCustomerId(type: number | undefined, customerId: number | undefined, isActive: boolean | undefined, validDate: Date | undefined, maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<RewardPackageListDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/rewardPackages/getRewardPackageListByTypeCustomer?";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&";
        if (customerId === null)
            throw new Error("The parameter 'customerId' cannot be null.");
        else if (customerId !== undefined)
            url_ += "CustomerId=" + encodeURIComponent("" + customerId) + "&";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (validDate === null)
            throw new Error("The parameter 'validDate' cannot be null.");
        else if (validDate !== undefined)
            url_ += "ValidDate=" + encodeURIComponent(validDate ? "" + validDate.toISOString() : "") + "&";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRewardPackageListByTypeCustomerId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRewardPackageListByTypeCustomerId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RewardPackageListDtoPagingResultApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RewardPackageListDtoPagingResultApiResultObject>;
        }));
    }

    protected processGetRewardPackageListByTypeCustomerId(response: HttpResponseBase): Observable<RewardPackageListDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RewardPackageListDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RewardPackageListDtoPagingResultApiResultObject>(null as any);
    }

    /**
     * @return Success
     */
    getStaffInfo(): Observable<StaffDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/staffs/info";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStaffInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStaffInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StaffDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StaffDtoApiResultObject>;
        }));
    }

    protected processGetStaffInfo(response: HttpResponseBase): Observable<StaffDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StaffDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StaffDtoApiResultObject>(null as any);
    }

    /**
     * @return Success
     */
    getStaff(id: number): Observable<StaffDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/staffs/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStaff(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStaff(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StaffDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StaffDtoApiResultObject>;
        }));
    }

    protected processGetStaff(response: HttpResponseBase): Observable<StaffDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StaffDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StaffDtoApiResultObject>(null as any);
    }

    /**
     * @param supervisorId (optional) 
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getSalesSuppervisorStaffs(supervisorId: number | undefined, maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<StaffListDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/staffs/sales-supervisor?";
        if (supervisorId === null)
            throw new Error("The parameter 'supervisorId' cannot be null.");
        else if (supervisorId !== undefined)
            url_ += "SupervisorId=" + encodeURIComponent("" + supervisorId) + "&";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSalesSuppervisorStaffs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSalesSuppervisorStaffs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StaffListDtoPagingResultApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StaffListDtoPagingResultApiResultObject>;
        }));
    }

    protected processGetSalesSuppervisorStaffs(response: HttpResponseBase): Observable<StaffListDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StaffListDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StaffListDtoPagingResultApiResultObject>(null as any);
    }

    /**
     * @param id (optional) 
     * @param supervisorId (optional) 
     * @param staffTypeCode (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getStaffByRoleId(id: number | undefined, supervisorId: number | undefined, staffTypeCode: string | undefined, queryId: string | undefined): Observable<StaffListDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/staffs/get-staff-by-roleId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (supervisorId === null)
            throw new Error("The parameter 'supervisorId' cannot be null.");
        else if (supervisorId !== undefined)
            url_ += "SupervisorId=" + encodeURIComponent("" + supervisorId) + "&";
        if (staffTypeCode === null)
            throw new Error("The parameter 'staffTypeCode' cannot be null.");
        else if (staffTypeCode !== undefined)
            url_ += "StaffTypeCode=" + encodeURIComponent("" + staffTypeCode) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStaffByRoleId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStaffByRoleId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StaffListDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StaffListDtoApiResultObject>;
        }));
    }

    protected processGetStaffByRoleId(response: HttpResponseBase): Observable<StaffListDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StaffListDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StaffListDtoApiResultObject>(null as any);
    }

    /**
     * @param supervisorId (optional) 
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getAsmStaffs(supervisorId: number | undefined, maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<StaffListDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/staffs/asm?";
        if (supervisorId === null)
            throw new Error("The parameter 'supervisorId' cannot be null.");
        else if (supervisorId !== undefined)
            url_ += "SupervisorId=" + encodeURIComponent("" + supervisorId) + "&";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAsmStaffs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAsmStaffs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StaffListDtoPagingResultApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StaffListDtoPagingResultApiResultObject>;
        }));
    }

    protected processGetAsmStaffs(response: HttpResponseBase): Observable<StaffListDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StaffListDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StaffListDtoPagingResultApiResultObject>(null as any);
    }

    /**
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getRsmStaffs(maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<StaffListDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/staffs/rsm?";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRsmStaffs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRsmStaffs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StaffListDtoPagingResultApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StaffListDtoPagingResultApiResultObject>;
        }));
    }

    protected processGetRsmStaffs(response: HttpResponseBase): Observable<StaffListDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StaffListDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StaffListDtoPagingResultApiResultObject>(null as any);
    }

    /**
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getStaffs(maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<StaffListDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/staffs?";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStaffs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStaffs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StaffListDtoPagingResultApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StaffListDtoPagingResultApiResultObject>;
        }));
    }

    protected processGetStaffs(response: HttpResponseBase): Observable<StaffListDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StaffListDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StaffListDtoPagingResultApiResultObject>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateCreditPoint(id: number, body: StaffUpdateCreditPointCommand | undefined): Observable<ObjectApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/staffs/{id}/update-credit-point";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCreditPoint(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCreditPoint(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResultObject>;
        }));
    }

    protected processUpdateCreditPoint(response: HttpResponseBase): Observable<ObjectApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectApiResultObject>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    registerStaff(body: StaffRegisterCommand | undefined): Observable<ObjectApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/staffs/registerNew";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterStaff(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterStaff(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResultObject>;
        }));
    }

    protected processRegisterStaff(response: HttpResponseBase): Observable<ObjectApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectApiResultObject>(null as any);
    }

    /**
     * @return Success
     */
    getSubProductClass(id: number): Observable<SubProductClassDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/sub-product-classes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubProductClass(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubProductClass(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubProductClassDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubProductClassDtoApiResultObject>;
        }));
    }

    protected processGetSubProductClass(response: HttpResponseBase): Observable<SubProductClassDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubProductClassDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubProductClassDtoApiResultObject>(null as any);
    }

    /**
     * @return Success
     */
    deleteSubProductClass(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/sub-product-classes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteSubProductClass(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteSubProductClass(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteSubProductClass(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateSubProductClass(id: number, body: SubProductClassUpsertCommand | undefined): Observable<SubProductClassDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/sub-product-classes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSubProductClass(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSubProductClass(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubProductClassDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubProductClassDtoApiResultObject>;
        }));
    }

    protected processUpdateSubProductClass(response: HttpResponseBase): Observable<SubProductClassDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubProductClassDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubProductClassDtoApiResultObject>(null as any);
    }

    /**
     * @param isActive (optional) 
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getSubProductClasses(isActive: boolean | undefined, maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<SubProductClassDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/sub-product-classes?";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubProductClasses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubProductClasses(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubProductClassDtoPagingResultApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubProductClassDtoPagingResultApiResultObject>;
        }));
    }

    protected processGetSubProductClasses(response: HttpResponseBase): Observable<SubProductClassDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubProductClassDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubProductClassDtoPagingResultApiResultObject>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createSubProductClass(body: SubProductClassUpsertCommand | undefined): Observable<SubProductClassDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/sub-product-classes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateSubProductClass(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateSubProductClass(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubProductClassDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubProductClassDtoApiResultObject>;
        }));
    }

    protected processCreateSubProductClass(response: HttpResponseBase): Observable<SubProductClassDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubProductClassDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubProductClassDtoApiResultObject>(null as any);
    }

    /**
     * @return Success
     */
    getTicketInvestment(id: number): Observable<TicketInvestmentDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/ticket-investments/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTicketInvestment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTicketInvestment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TicketInvestmentDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TicketInvestmentDtoApiResultObject>;
        }));
    }

    protected processGetTicketInvestment(response: HttpResponseBase): Observable<TicketInvestmentDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TicketInvestmentDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TicketInvestmentDtoApiResultObject>(null as any);
    }

    /**
     * @return Success
     */
    getTicketInvestmentHistory(id: number): Observable<TicketInvestmentHistoryDtoListApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/ticket-investments/{id}/history";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTicketInvestmentHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTicketInvestmentHistory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TicketInvestmentHistoryDtoListApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TicketInvestmentHistoryDtoListApiResultObject>;
        }));
    }

    protected processGetTicketInvestmentHistory(response: HttpResponseBase): Observable<TicketInvestmentHistoryDtoListApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TicketInvestmentHistoryDtoListApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TicketInvestmentHistoryDtoListApiResultObject>(null as any);
    }

    /**
     * @return Success
     */
    getTickets(id: number): Observable<TicketDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/ticket-investments/{id}/tickets";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTickets(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTickets(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TicketDtoPagingResultApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TicketDtoPagingResultApiResultObject>;
        }));
    }

    protected processGetTickets(response: HttpResponseBase): Observable<TicketDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TicketDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TicketDtoPagingResultApiResultObject>(null as any);
    }

    /**
     * @return Success
     */
    getTicketInvestmentSummary(id: number): Observable<TicketInvestmentSummaryDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/ticket-investments/{id}/summary";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTicketInvestmentSummary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTicketInvestmentSummary(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TicketInvestmentSummaryDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TicketInvestmentSummaryDtoApiResultObject>;
        }));
    }

    protected processGetTicketInvestmentSummary(response: HttpResponseBase): Observable<TicketInvestmentSummaryDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TicketInvestmentSummaryDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TicketInvestmentSummaryDtoApiResultObject>(null as any);
    }

    /**
     * @return Success
     */
    getTicketInvestmentTracking(id: number): Observable<TicketInvestmentTrackingDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/ticket-investments/{id}/tracking";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTicketInvestmentTracking(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTicketInvestmentTracking(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TicketInvestmentTrackingDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TicketInvestmentTrackingDtoApiResultObject>;
        }));
    }

    protected processGetTicketInvestmentTracking(response: HttpResponseBase): Observable<TicketInvestmentTrackingDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TicketInvestmentTrackingDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TicketInvestmentTrackingDtoApiResultObject>(null as any);
    }

    /**
     * @return Success
     */
    getActiveTicketInvestment(): Observable<TicketInvestmentTrackingDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/ticket-investments/active-program";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActiveTicketInvestment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActiveTicketInvestment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TicketInvestmentTrackingDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TicketInvestmentTrackingDtoApiResultObject>;
        }));
    }

    protected processGetActiveTicketInvestment(response: HttpResponseBase): Observable<TicketInvestmentTrackingDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TicketInvestmentTrackingDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TicketInvestmentTrackingDtoApiResultObject>(null as any);
    }

    /**
     * @return Success
     */
    getTicket(id: number): Observable<TicketDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/ticket-investments/tickets/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTicket(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTicket(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TicketDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TicketDtoApiResultObject>;
        }));
    }

    protected processGetTicket(response: HttpResponseBase): Observable<TicketDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TicketDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TicketDtoApiResultObject>(null as any);
    }

    /**
     * @return Success
     */
    getTicketConsumerReward(id: number): Observable<TicketConsumerRewardDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/ticket-investments/consumer-rewards/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTicketConsumerReward(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTicketConsumerReward(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TicketConsumerRewardDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TicketConsumerRewardDtoApiResultObject>;
        }));
    }

    protected processGetTicketConsumerReward(response: HttpResponseBase): Observable<TicketConsumerRewardDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TicketConsumerRewardDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TicketConsumerRewardDtoApiResultObject>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    registerTicketInvestment(body: TicketInvestmentRegisterCommand | undefined): Observable<TicketInvestmentDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/ticket-investments/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterTicketInvestment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterTicketInvestment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TicketInvestmentDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TicketInvestmentDtoApiResultObject>;
        }));
    }

    protected processRegisterTicketInvestment(response: HttpResponseBase): Observable<TicketInvestmentDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TicketInvestmentDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TicketInvestmentDtoApiResultObject>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateTicketInvestment(body: TicketInvestmentUpdateCommand | undefined): Observable<ObjectApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/ticket-investments/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTicketInvestment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTicketInvestment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResultObject>;
        }));
    }

    protected processUpdateTicketInvestment(response: HttpResponseBase): Observable<ObjectApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectApiResultObject>(null as any);
    }

    /**
     * @return Success
     */
    approveTicketInvestment(id: number): Observable<ObjectApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/ticket-investments/{id}/approve";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApproveTicketInvestment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApproveTicketInvestment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResultObject>;
        }));
    }

    protected processApproveTicketInvestment(response: HttpResponseBase): Observable<ObjectApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectApiResultObject>(null as any);
    }

    /**
     * @return Success
     */
    denyTicketInvestment(id: number): Observable<ObjectApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/ticket-investments/{id}/deny";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDenyTicketInvestment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDenyTicketInvestment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResultObject>;
        }));
    }

    protected processDenyTicketInvestment(response: HttpResponseBase): Observable<ObjectApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectApiResultObject>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createTicketInvestmentProgress(id: number, body: TicketInvestmentUpsertProgressCommand | undefined): Observable<TicketInvestmentDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/ticket-investments/{id}/progresses";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateTicketInvestmentProgress(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTicketInvestmentProgress(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TicketInvestmentDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TicketInvestmentDtoApiResultObject>;
        }));
    }

    protected processCreateTicketInvestmentProgress(response: HttpResponseBase): Observable<TicketInvestmentDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TicketInvestmentDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TicketInvestmentDtoApiResultObject>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateTicketInvestmentProgress(id: number, progressId: number, body: TicketInvestmentUpsertProgressCommand | undefined): Observable<TicketInvestmentDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/ticket-investments/{id}/progresses/{progressId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (progressId === undefined || progressId === null)
            throw new Error("The parameter 'progressId' must be defined.");
        url_ = url_.replace("{progressId}", encodeURIComponent("" + progressId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTicketInvestmentProgress(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTicketInvestmentProgress(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TicketInvestmentDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TicketInvestmentDtoApiResultObject>;
        }));
    }

    protected processUpdateTicketInvestmentProgress(response: HttpResponseBase): Observable<TicketInvestmentDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TicketInvestmentDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TicketInvestmentDtoApiResultObject>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    operateTicketInvestment(id: number, body: TicketInvestmentOperateCommand | undefined): Observable<TicketInvestmentDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/ticket-investments/{id}/operate";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOperateTicketInvestment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOperateTicketInvestment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TicketInvestmentDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TicketInvestmentDtoApiResultObject>;
        }));
    }

    protected processOperateTicketInvestment(response: HttpResponseBase): Observable<TicketInvestmentDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TicketInvestmentDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TicketInvestmentDtoApiResultObject>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    acceptTicketInvestment(id: number, body: TicketInvestmentUpsertAcceptanceCommand | undefined): Observable<TicketInvestmentDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/ticket-investments/{id}/accept";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAcceptTicketInvestment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAcceptTicketInvestment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TicketInvestmentDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TicketInvestmentDtoApiResultObject>;
        }));
    }

    protected processAcceptTicketInvestment(response: HttpResponseBase): Observable<TicketInvestmentDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TicketInvestmentDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TicketInvestmentDtoApiResultObject>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    finalSettlementTicketInvestment(id: number, body: TicketInvestmentUpsertFinalSettlementCommand | undefined): Observable<TicketInvestmentDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/ticket-investments/{id}/final-settlement";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFinalSettlementTicketInvestment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFinalSettlementTicketInvestment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TicketInvestmentDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TicketInvestmentDtoApiResultObject>;
        }));
    }

    protected processFinalSettlementTicketInvestment(response: HttpResponseBase): Observable<TicketInvestmentDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TicketInvestmentDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TicketInvestmentDtoApiResultObject>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateTicketInvestmentConsumerReward(id: number, rewardItemId: number, body: TicketInvestmentUpsertConsumerRewardCommand | undefined): Observable<TicketConsumerRewardDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/ticket-investments/{id}/consumer-rewards/{rewardItemId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (rewardItemId === undefined || rewardItemId === null)
            throw new Error("The parameter 'rewardItemId' must be defined.");
        url_ = url_.replace("{rewardItemId}", encodeURIComponent("" + rewardItemId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTicketInvestmentConsumerReward(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTicketInvestmentConsumerReward(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TicketConsumerRewardDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TicketConsumerRewardDtoApiResultObject>;
        }));
    }

    protected processUpdateTicketInvestmentConsumerReward(response: HttpResponseBase): Observable<TicketConsumerRewardDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TicketConsumerRewardDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TicketConsumerRewardDtoApiResultObject>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    salesRemarkTicketInvestment(id: number, body: TicketInvestmentSalesRemarkCommand | undefined): Observable<ObjectApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/ticket-investments/{id}/sales-remark";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSalesRemarkTicketInvestment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSalesRemarkTicketInvestment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResultObject>;
        }));
    }

    protected processSalesRemarkTicketInvestment(response: HttpResponseBase): Observable<ObjectApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectApiResultObject>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    companyRemarkTicketInvestment(id: number, body: TicketInvestmentCompanyRemarkCommand | undefined): Observable<ObjectApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/ticket-investments/{id}/company-remark";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCompanyRemarkTicketInvestment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCompanyRemarkTicketInvestment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResultObject>;
        }));
    }

    protected processCompanyRemarkTicketInvestment(response: HttpResponseBase): Observable<ObjectApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectApiResultObject>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    customerDevelopmentRemarkTicketInvestment(id: number, body: TicketInvestmentCustomerDevelopmentRemarkCommand | undefined): Observable<ObjectApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/ticket-investments/{id}/customer-development-remark";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCustomerDevelopmentRemarkTicketInvestment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCustomerDevelopmentRemarkTicketInvestment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResultObject>;
        }));
    }

    protected processCustomerDevelopmentRemarkTicketInvestment(response: HttpResponseBase): Observable<ObjectApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectApiResultObject>(null as any);
    }

    /**
     * @param status (optional) 
     * @param cycleId (optional) 
     * @param staffId (optional) 
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getTicketInvestmentsByUser(status: number[] | undefined, cycleId: number | undefined, staffId: number | undefined, maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<TicketInvestmentListItemDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/ticket-investments/byuser?";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            status && status.forEach(item => { url_ += "Status=" + encodeURIComponent("" + item) + "&"; });
        if (cycleId === null)
            throw new Error("The parameter 'cycleId' cannot be null.");
        else if (cycleId !== undefined)
            url_ += "CycleId=" + encodeURIComponent("" + cycleId) + "&";
        if (staffId === null)
            throw new Error("The parameter 'staffId' cannot be null.");
        else if (staffId !== undefined)
            url_ += "StaffId=" + encodeURIComponent("" + staffId) + "&";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTicketInvestmentsByUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTicketInvestmentsByUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TicketInvestmentListItemDtoPagingResultApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TicketInvestmentListItemDtoPagingResultApiResultObject>;
        }));
    }

    protected processGetTicketInvestmentsByUser(response: HttpResponseBase): Observable<TicketInvestmentListItemDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TicketInvestmentListItemDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TicketInvestmentListItemDtoPagingResultApiResultObject>(null as any);
    }

    /**
     * @param staffId (optional) 
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getHoldingTicketInvestmentsByUser(staffId: number | undefined, maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<TicketInvestmentListItemDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/ticket-investments/holding?";
        if (staffId === null)
            throw new Error("The parameter 'staffId' cannot be null.");
        else if (staffId !== undefined)
            url_ += "StaffId=" + encodeURIComponent("" + staffId) + "&";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHoldingTicketInvestmentsByUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHoldingTicketInvestmentsByUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TicketInvestmentListItemDtoPagingResultApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TicketInvestmentListItemDtoPagingResultApiResultObject>;
        }));
    }

    protected processGetHoldingTicketInvestmentsByUser(response: HttpResponseBase): Observable<TicketInvestmentListItemDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TicketInvestmentListItemDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TicketInvestmentListItemDtoPagingResultApiResultObject>(null as any);
    }

    /**
     * @param staffId (optional) 
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getRequestTicketInvestmentsByUser(staffId: number | undefined, maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<TicketInvestmentListItemDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/ticket-investments/request?";
        if (staffId === null)
            throw new Error("The parameter 'staffId' cannot be null.");
        else if (staffId !== undefined)
            url_ += "StaffId=" + encodeURIComponent("" + staffId) + "&";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRequestTicketInvestmentsByUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRequestTicketInvestmentsByUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TicketInvestmentListItemDtoPagingResultApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TicketInvestmentListItemDtoPagingResultApiResultObject>;
        }));
    }

    protected processGetRequestTicketInvestmentsByUser(response: HttpResponseBase): Observable<TicketInvestmentListItemDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TicketInvestmentListItemDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TicketInvestmentListItemDtoPagingResultApiResultObject>(null as any);
    }

    /**
     * @param staffId (optional) 
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getApprovedTicketInvestmentsByUser(staffId: number | undefined, maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<TicketInvestmentListItemDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/ticket-investments/approved?";
        if (staffId === null)
            throw new Error("The parameter 'staffId' cannot be null.");
        else if (staffId !== undefined)
            url_ += "StaffId=" + encodeURIComponent("" + staffId) + "&";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApprovedTicketInvestmentsByUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApprovedTicketInvestmentsByUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TicketInvestmentListItemDtoPagingResultApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TicketInvestmentListItemDtoPagingResultApiResultObject>;
        }));
    }

    protected processGetApprovedTicketInvestmentsByUser(response: HttpResponseBase): Observable<TicketInvestmentListItemDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TicketInvestmentListItemDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TicketInvestmentListItemDtoPagingResultApiResultObject>(null as any);
    }

    /**
     * @param customerId (optional) 
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getTicketInvestmentsByCustomer(customerId: number | undefined, maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<TicketInvestmentListItemDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/ticket-investments/bycustomer?";
        if (customerId === null)
            throw new Error("The parameter 'customerId' cannot be null.");
        else if (customerId !== undefined)
            url_ += "CustomerId=" + encodeURIComponent("" + customerId) + "&";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTicketInvestmentsByCustomer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTicketInvestmentsByCustomer(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TicketInvestmentListItemDtoPagingResultApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TicketInvestmentListItemDtoPagingResultApiResultObject>;
        }));
    }

    protected processGetTicketInvestmentsByCustomer(response: HttpResponseBase): Observable<TicketInvestmentListItemDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TicketInvestmentListItemDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TicketInvestmentListItemDtoPagingResultApiResultObject>(null as any);
    }

    /**
     * @param status (optional) 
     * @param rsmStaffId (optional) 
     * @param asmStaffId (optional) 
     * @param salesSupervisorStaffId (optional) 
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param byOperationDate (optional) 
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getTicketInvestmentsByTime(status: number[] | undefined, rsmStaffId: number | undefined, asmStaffId: number | undefined, salesSupervisorStaffId: number | undefined, fromDate: Date | undefined, toDate: Date | undefined, byOperationDate: boolean | undefined, maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<TicketInvestmentListItemDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/ticket-investments/bytime?";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            status && status.forEach(item => { url_ += "Status=" + encodeURIComponent("" + item) + "&"; });
        if (rsmStaffId === null)
            throw new Error("The parameter 'rsmStaffId' cannot be null.");
        else if (rsmStaffId !== undefined)
            url_ += "RsmStaffId=" + encodeURIComponent("" + rsmStaffId) + "&";
        if (asmStaffId === null)
            throw new Error("The parameter 'asmStaffId' cannot be null.");
        else if (asmStaffId !== undefined)
            url_ += "AsmStaffId=" + encodeURIComponent("" + asmStaffId) + "&";
        if (salesSupervisorStaffId === null)
            throw new Error("The parameter 'salesSupervisorStaffId' cannot be null.");
        else if (salesSupervisorStaffId !== undefined)
            url_ += "SalesSupervisorStaffId=" + encodeURIComponent("" + salesSupervisorStaffId) + "&";
        if (fromDate === null)
            throw new Error("The parameter 'fromDate' cannot be null.");
        else if (fromDate !== undefined)
            url_ += "FromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toISOString() : "") + "&";
        if (toDate === null)
            throw new Error("The parameter 'toDate' cannot be null.");
        else if (toDate !== undefined)
            url_ += "ToDate=" + encodeURIComponent(toDate ? "" + toDate.toISOString() : "") + "&";
        if (byOperationDate === null)
            throw new Error("The parameter 'byOperationDate' cannot be null.");
        else if (byOperationDate !== undefined)
            url_ += "ByOperationDate=" + encodeURIComponent("" + byOperationDate) + "&";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTicketInvestmentsByTime(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTicketInvestmentsByTime(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TicketInvestmentListItemDtoPagingResultApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TicketInvestmentListItemDtoPagingResultApiResultObject>;
        }));
    }

    protected processGetTicketInvestmentsByTime(response: HttpResponseBase): Observable<TicketInvestmentListItemDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TicketInvestmentListItemDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TicketInvestmentListItemDtoPagingResultApiResultObject>(null as any);
    }

    /**
     * @param status (optional) 
     * @param rsmStaffId (optional) 
     * @param asmStaffId (optional) 
     * @param salesSupervisorStaffId (optional) 
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param byOperationDate (optional) 
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getOperationPlanInvestmentList(status: number[] | undefined, rsmStaffId: number | undefined, asmStaffId: number | undefined, salesSupervisorStaffId: number | undefined, fromDate: Date | undefined, toDate: Date | undefined, byOperationDate: boolean | undefined, maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<TicketInvestmentListItemDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/ticket-investments/getOperationPlanInvestmentList?";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            status && status.forEach(item => { url_ += "Status=" + encodeURIComponent("" + item) + "&"; });
        if (rsmStaffId === null)
            throw new Error("The parameter 'rsmStaffId' cannot be null.");
        else if (rsmStaffId !== undefined)
            url_ += "RsmStaffId=" + encodeURIComponent("" + rsmStaffId) + "&";
        if (asmStaffId === null)
            throw new Error("The parameter 'asmStaffId' cannot be null.");
        else if (asmStaffId !== undefined)
            url_ += "AsmStaffId=" + encodeURIComponent("" + asmStaffId) + "&";
        if (salesSupervisorStaffId === null)
            throw new Error("The parameter 'salesSupervisorStaffId' cannot be null.");
        else if (salesSupervisorStaffId !== undefined)
            url_ += "SalesSupervisorStaffId=" + encodeURIComponent("" + salesSupervisorStaffId) + "&";
        if (fromDate === null)
            throw new Error("The parameter 'fromDate' cannot be null.");
        else if (fromDate !== undefined)
            url_ += "FromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toISOString() : "") + "&";
        if (toDate === null)
            throw new Error("The parameter 'toDate' cannot be null.");
        else if (toDate !== undefined)
            url_ += "ToDate=" + encodeURIComponent(toDate ? "" + toDate.toISOString() : "") + "&";
        if (byOperationDate === null)
            throw new Error("The parameter 'byOperationDate' cannot be null.");
        else if (byOperationDate !== undefined)
            url_ += "ByOperationDate=" + encodeURIComponent("" + byOperationDate) + "&";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOperationPlanInvestmentList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOperationPlanInvestmentList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TicketInvestmentListItemDtoPagingResultApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TicketInvestmentListItemDtoPagingResultApiResultObject>;
        }));
    }

    protected processGetOperationPlanInvestmentList(response: HttpResponseBase): Observable<TicketInvestmentListItemDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TicketInvestmentListItemDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TicketInvestmentListItemDtoPagingResultApiResultObject>(null as any);
    }

    /**
     * @param ticketInvestmentId (optional) 
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getTicketByTicketInvestmentId(ticketInvestmentId: number | undefined, maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<TicketListDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/ticket-investments/getTicketByTicketInvestmentId?";
        if (ticketInvestmentId === null)
            throw new Error("The parameter 'ticketInvestmentId' cannot be null.");
        else if (ticketInvestmentId !== undefined)
            url_ += "TicketInvestmentId=" + encodeURIComponent("" + ticketInvestmentId) + "&";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTicketByTicketInvestmentId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTicketByTicketInvestmentId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TicketListDtoPagingResultApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TicketListDtoPagingResultApiResultObject>;
        }));
    }

    protected processGetTicketByTicketInvestmentId(response: HttpResponseBase): Observable<TicketListDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TicketListDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TicketListDtoPagingResultApiResultObject>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    printTicket(body: TicketInvestmentUpdatePrintTicketQuantityCommand | undefined): Observable<ObjectApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/ticket-investments/print";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPrintTicket(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPrintTicket(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ObjectApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ObjectApiResultObject>;
        }));
    }

    protected processPrintTicket(response: HttpResponseBase): Observable<ObjectApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectApiResultObject>(null as any);
    }

    /**
     * @return Success
     */
    getUser(id: number): Observable<UserDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/user-management/users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDtoApiResultObject>;
        }));
    }

    protected processGetUser(response: HttpResponseBase): Observable<UserDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDtoApiResultObject>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateUser(id: number, body: UpsertUserExtCommand | undefined): Observable<UserDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/user-management/users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDtoApiResultObject>;
        }));
    }

    protected processUpdateUser(response: HttpResponseBase): Observable<UserDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDtoApiResultObject>(null as any);
    }

    /**
     * @return Success
     */
    deleteUser(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/user-management/users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param isActive (optional) 
     * @param roleId (optional) 
     * @param roleName (optional) 
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getUsers(isActive: boolean | undefined, roleId: number | undefined, roleName: string | undefined, maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<UserListItemDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/user-management/users?";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (roleId === null)
            throw new Error("The parameter 'roleId' cannot be null.");
        else if (roleId !== undefined)
            url_ += "RoleId=" + encodeURIComponent("" + roleId) + "&";
        if (roleName === null)
            throw new Error("The parameter 'roleName' cannot be null.");
        else if (roleName !== undefined)
            url_ += "RoleName=" + encodeURIComponent("" + roleName) + "&";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserListItemDtoPagingResultApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserListItemDtoPagingResultApiResultObject>;
        }));
    }

    protected processGetUsers(response: HttpResponseBase): Observable<UserListItemDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserListItemDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserListItemDtoPagingResultApiResultObject>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createUser(body: UpsertUserExtCommand | undefined): Observable<UserDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/user-management/users";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDtoApiResultObject>;
        }));
    }

    protected processCreateUser(response: HttpResponseBase): Observable<UserDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDtoApiResultObject>(null as any);
    }

    /**
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getCustomerDevelopmentUsers(maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<UserListItemDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/user-management/customer-development-users?";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomerDevelopmentUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomerDevelopmentUsers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserListItemDtoPagingResultApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserListItemDtoPagingResultApiResultObject>;
        }));
    }

    protected processGetCustomerDevelopmentUsers(response: HttpResponseBase): Observable<UserListItemDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserListItemDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserListItemDtoPagingResultApiResultObject>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeUserPassword(body: ChangeUserPasswordCommand | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/user-management/users/change-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeUserPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeUserPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processChangeUserPassword(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateProfile(body: UpdateProfileCommand | undefined): Observable<UserDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/user-management/update-profile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateProfile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDtoApiResultObject>;
        }));
    }

    protected processUpdateProfile(response: HttpResponseBase): Observable<UserDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDtoApiResultObject>(null as any);
    }

    /**
     * @return Success
     */
    getRole(id: number): Observable<RoleDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/user-management/roles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRole(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDtoApiResultObject>;
        }));
    }

    protected processGetRole(response: HttpResponseBase): Observable<RoleDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDtoApiResultObject>(null as any);
    }

    /**
     * @return Success
     */
    deleteRole(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/user-management/roles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRole(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteRole(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateRole(id: number, body: UpsertRoleCommand | undefined): Observable<RoleDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/user-management/roles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateRole(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDtoApiResultObject>;
        }));
    }

    protected processUpdateRole(response: HttpResponseBase): Observable<RoleDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDtoApiResultObject>(null as any);
    }

    /**
     * @param isActive (optional) 
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getRoles(isActive: boolean | undefined, maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<RoleListItemDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/user-management/roles?";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleListItemDtoPagingResultApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleListItemDtoPagingResultApiResultObject>;
        }));
    }

    protected processGetRoles(response: HttpResponseBase): Observable<RoleListItemDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleListItemDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleListItemDtoPagingResultApiResultObject>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createRole(body: UpsertRoleCommand | undefined): Observable<RoleDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/user-management/roles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateRole(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDtoApiResultObject>;
        }));
    }

    protected processCreateRole(response: HttpResponseBase): Observable<RoleDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDtoApiResultObject>(null as any);
    }

    /**
     * @return Success
     */
    getPermission(id: number): Observable<PermissionDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/user-management/permissions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPermission(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPermission(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PermissionDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PermissionDtoApiResultObject>;
        }));
    }

    protected processGetPermission(response: HttpResponseBase): Observable<PermissionDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PermissionDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PermissionDtoApiResultObject>(null as any);
    }

    /**
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getPermissions(maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<PermissionDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/user-management/permissions?";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPermissions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PermissionDtoPagingResultApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PermissionDtoPagingResultApiResultObject>;
        }));
    }

    protected processGetPermissions(response: HttpResponseBase): Observable<PermissionDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PermissionDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PermissionDtoPagingResultApiResultObject>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendEmailResetPassword(body: SendEmailResetPasswordCommand | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/user-management/send-email-reset-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendEmailResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendEmailResetPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSendEmailResetPassword(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resetPassword(body: ResetPasswordCommand | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/user-management/reset-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getVendor(id: number): Observable<VendorDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/Vendors/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVendor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVendor(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VendorDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VendorDtoApiResultObject>;
        }));
    }

    protected processGetVendor(response: HttpResponseBase): Observable<VendorDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VendorDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VendorDtoApiResultObject>(null as any);
    }

    /**
     * @return Success
     */
    deleteVendor(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/Vendors/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteVendor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteVendor(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteVendor(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateVendor(id: number, body: VendorUpsertCommand | undefined): Observable<VendorDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/Vendors/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateVendor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateVendor(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VendorDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VendorDtoApiResultObject>;
        }));
    }

    protected processUpdateVendor(response: HttpResponseBase): Observable<VendorDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VendorDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VendorDtoApiResultObject>(null as any);
    }

    /**
     * @param isActive (optional) 
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getVendors(isActive: boolean | undefined, maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<VendorListDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/Vendors?";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVendors(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVendors(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VendorListDtoPagingResultApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VendorListDtoPagingResultApiResultObject>;
        }));
    }

    protected processGetVendors(response: HttpResponseBase): Observable<VendorListDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VendorListDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VendorListDtoPagingResultApiResultObject>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createVendor(body: VendorUpsertCommand | undefined): Observable<VendorDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/Vendors";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateVendor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateVendor(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VendorDtoApiResultObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VendorDtoApiResultObject>;
        }));
    }

    protected processCreateVendor(response: HttpResponseBase): Observable<VendorDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VendorDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VendorDtoApiResultObject>(null as any);
    }
}

export class AppSettingDto implements IAppSettingDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    value?: string | undefined;
    description?: string | undefined;

    constructor(data?: IAppSettingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.value = _data["value"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): AppSettingDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppSettingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["value"] = this.value;
        data["description"] = this.description;
        return data;
    }

    clone(): AppSettingDto {
        const json = this.toJSON();
        let result = new AppSettingDto();
        result.init(json);
        return result;
    }
}

export interface IAppSettingDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    value?: string | undefined;
    description?: string | undefined;
}

export class AppSettingDtoApiResultObject implements IAppSettingDtoApiResultObject {
    result?: AppSettingDto;
    success?: boolean;

    constructor(data?: IAppSettingDtoApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? AppSettingDto.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): AppSettingDtoApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new AppSettingDtoApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data;
    }

    clone(): AppSettingDtoApiResultObject {
        const json = this.toJSON();
        let result = new AppSettingDtoApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IAppSettingDtoApiResultObject {
    result?: AppSettingDto;
    success?: boolean;
}

export class AppSettingDtoPagingResult implements IAppSettingDtoPagingResult {
    items?: AppSettingDto[] | undefined;
    totalCount?: number;

    constructor(data?: IAppSettingDtoPagingResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AppSettingDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): AppSettingDtoPagingResult {
        data = typeof data === 'object' ? data : {};
        let result = new AppSettingDtoPagingResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): AppSettingDtoPagingResult {
        const json = this.toJSON();
        let result = new AppSettingDtoPagingResult();
        result.init(json);
        return result;
    }
}

export interface IAppSettingDtoPagingResult {
    items?: AppSettingDto[] | undefined;
    totalCount?: number;
}

export class AppSettingDtoPagingResultApiResultObject implements IAppSettingDtoPagingResultApiResultObject {
    result?: AppSettingDtoPagingResult;
    success?: boolean;

    constructor(data?: IAppSettingDtoPagingResultApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? AppSettingDtoPagingResult.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): AppSettingDtoPagingResultApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new AppSettingDtoPagingResultApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data;
    }

    clone(): AppSettingDtoPagingResultApiResultObject {
        const json = this.toJSON();
        let result = new AppSettingDtoPagingResultApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IAppSettingDtoPagingResultApiResultObject {
    result?: AppSettingDtoPagingResult;
    success?: boolean;
}

export class AreaByZoneNameListDto implements IAreaByZoneNameListDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    zoneId?: number;
    salesOrgId?: number;
    zoneName?: string | undefined;

    constructor(data?: IAreaByZoneNameListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.zoneId = _data["zoneId"];
            this.salesOrgId = _data["salesOrgId"];
            this.zoneName = _data["zoneName"];
        }
    }

    static fromJS(data: any): AreaByZoneNameListDto {
        data = typeof data === 'object' ? data : {};
        let result = new AreaByZoneNameListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["zoneId"] = this.zoneId;
        data["salesOrgId"] = this.salesOrgId;
        data["zoneName"] = this.zoneName;
        return data;
    }

    clone(): AreaByZoneNameListDto {
        const json = this.toJSON();
        let result = new AreaByZoneNameListDto();
        result.init(json);
        return result;
    }
}

export interface IAreaByZoneNameListDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    zoneId?: number;
    salesOrgId?: number;
    zoneName?: string | undefined;
}

export class AreaByZoneNameListDtoPagingResult implements IAreaByZoneNameListDtoPagingResult {
    items?: AreaByZoneNameListDto[] | undefined;
    totalCount?: number;

    constructor(data?: IAreaByZoneNameListDtoPagingResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AreaByZoneNameListDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): AreaByZoneNameListDtoPagingResult {
        data = typeof data === 'object' ? data : {};
        let result = new AreaByZoneNameListDtoPagingResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): AreaByZoneNameListDtoPagingResult {
        const json = this.toJSON();
        let result = new AreaByZoneNameListDtoPagingResult();
        result.init(json);
        return result;
    }
}

export interface IAreaByZoneNameListDtoPagingResult {
    items?: AreaByZoneNameListDto[] | undefined;
    totalCount?: number;
}

export class AreaByZoneNameListDtoPagingResultApiResultObject implements IAreaByZoneNameListDtoPagingResultApiResultObject {
    result?: AreaByZoneNameListDtoPagingResult;
    success?: boolean;

    constructor(data?: IAreaByZoneNameListDtoPagingResultApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? AreaByZoneNameListDtoPagingResult.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): AreaByZoneNameListDtoPagingResultApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new AreaByZoneNameListDtoPagingResultApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data;
    }

    clone(): AreaByZoneNameListDtoPagingResultApiResultObject {
        const json = this.toJSON();
        let result = new AreaByZoneNameListDtoPagingResultApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IAreaByZoneNameListDtoPagingResultApiResultObject {
    result?: AreaByZoneNameListDtoPagingResult;
    success?: boolean;
}

export class AreaDto implements IAreaDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    zoneId?: number;
    salesOrgId?: number;

    constructor(data?: IAreaDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.zoneId = _data["zoneId"];
            this.salesOrgId = _data["salesOrgId"];
        }
    }

    static fromJS(data: any): AreaDto {
        data = typeof data === 'object' ? data : {};
        let result = new AreaDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["zoneId"] = this.zoneId;
        data["salesOrgId"] = this.salesOrgId;
        return data;
    }

    clone(): AreaDto {
        const json = this.toJSON();
        let result = new AreaDto();
        result.init(json);
        return result;
    }
}

export interface IAreaDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    zoneId?: number;
    salesOrgId?: number;
}

export class AreaDtoApiResultObject implements IAreaDtoApiResultObject {
    result?: AreaDto;
    success?: boolean;

    constructor(data?: IAreaDtoApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? AreaDto.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): AreaDtoApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new AreaDtoApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data;
    }

    clone(): AreaDtoApiResultObject {
        const json = this.toJSON();
        let result = new AreaDtoApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IAreaDtoApiResultObject {
    result?: AreaDto;
    success?: boolean;
}

export class AreaDtoPagingResult implements IAreaDtoPagingResult {
    items?: AreaDto[] | undefined;
    totalCount?: number;

    constructor(data?: IAreaDtoPagingResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AreaDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): AreaDtoPagingResult {
        data = typeof data === 'object' ? data : {};
        let result = new AreaDtoPagingResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): AreaDtoPagingResult {
        const json = this.toJSON();
        let result = new AreaDtoPagingResult();
        result.init(json);
        return result;
    }
}

export interface IAreaDtoPagingResult {
    items?: AreaDto[] | undefined;
    totalCount?: number;
}

export class AreaDtoPagingResultApiResultObject implements IAreaDtoPagingResultApiResultObject {
    result?: AreaDtoPagingResult;
    success?: boolean;

    constructor(data?: IAreaDtoPagingResultApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? AreaDtoPagingResult.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): AreaDtoPagingResultApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new AreaDtoPagingResultApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data;
    }

    clone(): AreaDtoPagingResultApiResultObject {
        const json = this.toJSON();
        let result = new AreaDtoPagingResultApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IAreaDtoPagingResultApiResultObject {
    result?: AreaDtoPagingResult;
    success?: boolean;
}

export class BranchDto implements IBranchDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    areaId?: number;
    salesOrgId?: number;
    zoneId?: number;
    isActive?: boolean;
    channelId?: number | undefined;

    constructor(data?: IBranchDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.areaId = _data["areaId"];
            this.salesOrgId = _data["salesOrgId"];
            this.zoneId = _data["zoneId"];
            this.isActive = _data["isActive"];
            this.channelId = _data["channelId"];
        }
    }

    static fromJS(data: any): BranchDto {
        data = typeof data === 'object' ? data : {};
        let result = new BranchDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["areaId"] = this.areaId;
        data["salesOrgId"] = this.salesOrgId;
        data["zoneId"] = this.zoneId;
        data["isActive"] = this.isActive;
        data["channelId"] = this.channelId;
        return data;
    }

    clone(): BranchDto {
        const json = this.toJSON();
        let result = new BranchDto();
        result.init(json);
        return result;
    }
}

export interface IBranchDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    areaId?: number;
    salesOrgId?: number;
    zoneId?: number;
    isActive?: boolean;
    channelId?: number | undefined;
}

export class BranchDtoApiResultObject implements IBranchDtoApiResultObject {
    result?: BranchDto;
    success?: boolean;

    constructor(data?: IBranchDtoApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? BranchDto.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): BranchDtoApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new BranchDtoApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data;
    }

    clone(): BranchDtoApiResultObject {
        const json = this.toJSON();
        let result = new BranchDtoApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IBranchDtoApiResultObject {
    result?: BranchDto;
    success?: boolean;
}

export class BranchListItemDto implements IBranchListItemDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    areaId?: number;
    salesOrgId?: number;
    zoneId?: number;
    isActive?: boolean;
    channelId?: number | undefined;
    zoneName?: string | undefined;
    areaName?: string | undefined;
    channelName?: string | undefined;
    provinccId?: number | undefined;
    provinceName?: string | undefined;

    constructor(data?: IBranchListItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.areaId = _data["areaId"];
            this.salesOrgId = _data["salesOrgId"];
            this.zoneId = _data["zoneId"];
            this.isActive = _data["isActive"];
            this.channelId = _data["channelId"];
            this.zoneName = _data["zoneName"];
            this.areaName = _data["areaName"];
            this.channelName = _data["channelName"];
            this.provinccId = _data["provinccId"];
            this.provinceName = _data["provinceName"];
        }
    }

    static fromJS(data: any): BranchListItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new BranchListItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["areaId"] = this.areaId;
        data["salesOrgId"] = this.salesOrgId;
        data["zoneId"] = this.zoneId;
        data["isActive"] = this.isActive;
        data["channelId"] = this.channelId;
        data["zoneName"] = this.zoneName;
        data["areaName"] = this.areaName;
        data["channelName"] = this.channelName;
        data["provinccId"] = this.provinccId;
        data["provinceName"] = this.provinceName;
        return data;
    }

    clone(): BranchListItemDto {
        const json = this.toJSON();
        let result = new BranchListItemDto();
        result.init(json);
        return result;
    }
}

export interface IBranchListItemDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    areaId?: number;
    salesOrgId?: number;
    zoneId?: number;
    isActive?: boolean;
    channelId?: number | undefined;
    zoneName?: string | undefined;
    areaName?: string | undefined;
    channelName?: string | undefined;
    provinccId?: number | undefined;
    provinceName?: string | undefined;
}

export class BranchListItemDtoPagingResult implements IBranchListItemDtoPagingResult {
    items?: BranchListItemDto[] | undefined;
    totalCount?: number;

    constructor(data?: IBranchListItemDtoPagingResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(BranchListItemDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): BranchListItemDtoPagingResult {
        data = typeof data === 'object' ? data : {};
        let result = new BranchListItemDtoPagingResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): BranchListItemDtoPagingResult {
        const json = this.toJSON();
        let result = new BranchListItemDtoPagingResult();
        result.init(json);
        return result;
    }
}

export interface IBranchListItemDtoPagingResult {
    items?: BranchListItemDto[] | undefined;
    totalCount?: number;
}

export class BranchListItemDtoPagingResultApiResultObject implements IBranchListItemDtoPagingResultApiResultObject {
    result?: BranchListItemDtoPagingResult;
    success?: boolean;

    constructor(data?: IBranchListItemDtoPagingResultApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? BranchListItemDtoPagingResult.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): BranchListItemDtoPagingResultApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new BranchListItemDtoPagingResultApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data;
    }

    clone(): BranchListItemDtoPagingResultApiResultObject {
        const json = this.toJSON();
        let result = new BranchListItemDtoPagingResultApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IBranchListItemDtoPagingResultApiResultObject {
    result?: BranchListItemDtoPagingResult;
    success?: boolean;
}

export class BrandDto implements IBrandDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    isActive?: boolean;

    constructor(data?: IBrandDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): BrandDto {
        data = typeof data === 'object' ? data : {};
        let result = new BrandDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): BrandDto {
        const json = this.toJSON();
        let result = new BrandDto();
        result.init(json);
        return result;
    }
}

export interface IBrandDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    isActive?: boolean;
}

export class BrandDtoApiResultObject implements IBrandDtoApiResultObject {
    result?: BrandDto;
    success?: boolean;

    constructor(data?: IBrandDtoApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? BrandDto.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): BrandDtoApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new BrandDtoApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data;
    }

    clone(): BrandDtoApiResultObject {
        const json = this.toJSON();
        let result = new BrandDtoApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IBrandDtoApiResultObject {
    result?: BrandDto;
    success?: boolean;
}

export class BrandDtoPagingResult implements IBrandDtoPagingResult {
    items?: BrandDto[] | undefined;
    totalCount?: number;

    constructor(data?: IBrandDtoPagingResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(BrandDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): BrandDtoPagingResult {
        data = typeof data === 'object' ? data : {};
        let result = new BrandDtoPagingResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): BrandDtoPagingResult {
        const json = this.toJSON();
        let result = new BrandDtoPagingResult();
        result.init(json);
        return result;
    }
}

export interface IBrandDtoPagingResult {
    items?: BrandDto[] | undefined;
    totalCount?: number;
}

export class BrandDtoPagingResultApiResultObject implements IBrandDtoPagingResultApiResultObject {
    result?: BrandDtoPagingResult;
    success?: boolean;

    constructor(data?: IBrandDtoPagingResultApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? BrandDtoPagingResult.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): BrandDtoPagingResultApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new BrandDtoPagingResultApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data;
    }

    clone(): BrandDtoPagingResultApiResultObject {
        const json = this.toJSON();
        let result = new BrandDtoPagingResultApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IBrandDtoPagingResultApiResultObject {
    result?: BrandDtoPagingResult;
    success?: boolean;
}

export class BudgetAreaDto implements IBudgetAreaDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    areaId?: number;
    areaCode?: string | undefined;
    areaName?: string | undefined;
    zoneId?: number;
    zoneName?: string | undefined;
    salesOrgId?: number;
    parentSalesOrgId?: number;
    allocateAmount?: number;
    remainAmount?: number;
    usedAmount?: number;
    tempRemainAmount?: number;
    tempUsedAmount?: number;

    constructor(data?: IBudgetAreaDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.areaId = _data["areaId"];
            this.areaCode = _data["areaCode"];
            this.areaName = _data["areaName"];
            this.zoneId = _data["zoneId"];
            this.zoneName = _data["zoneName"];
            this.salesOrgId = _data["salesOrgId"];
            this.parentSalesOrgId = _data["parentSalesOrgId"];
            this.allocateAmount = _data["allocateAmount"];
            this.remainAmount = _data["remainAmount"];
            this.usedAmount = _data["usedAmount"];
            this.tempRemainAmount = _data["tempRemainAmount"];
            this.tempUsedAmount = _data["tempUsedAmount"];
        }
    }

    static fromJS(data: any): BudgetAreaDto {
        data = typeof data === 'object' ? data : {};
        let result = new BudgetAreaDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["areaId"] = this.areaId;
        data["areaCode"] = this.areaCode;
        data["areaName"] = this.areaName;
        data["zoneId"] = this.zoneId;
        data["zoneName"] = this.zoneName;
        data["salesOrgId"] = this.salesOrgId;
        data["parentSalesOrgId"] = this.parentSalesOrgId;
        data["allocateAmount"] = this.allocateAmount;
        data["remainAmount"] = this.remainAmount;
        data["usedAmount"] = this.usedAmount;
        data["tempRemainAmount"] = this.tempRemainAmount;
        data["tempUsedAmount"] = this.tempUsedAmount;
        return data;
    }

    clone(): BudgetAreaDto {
        const json = this.toJSON();
        let result = new BudgetAreaDto();
        result.init(json);
        return result;
    }
}

export interface IBudgetAreaDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    areaId?: number;
    areaCode?: string | undefined;
    areaName?: string | undefined;
    zoneId?: number;
    zoneName?: string | undefined;
    salesOrgId?: number;
    parentSalesOrgId?: number;
    allocateAmount?: number;
    remainAmount?: number;
    usedAmount?: number;
    tempRemainAmount?: number;
    tempUsedAmount?: number;
}

export class BudgetAreaUpsertDto implements IBudgetAreaUpsertDto {
    id?: number;
    areaId?: number;
    areaCode?: string | undefined;
    areaName?: string | undefined;
    salesOrgId?: number;
    parentSalesOrgId?: number;
    allocateAmount?: number;
    remainAmount?: number;
    usedAmount?: number;

    constructor(data?: IBudgetAreaUpsertDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.areaId = _data["areaId"];
            this.areaCode = _data["areaCode"];
            this.areaName = _data["areaName"];
            this.salesOrgId = _data["salesOrgId"];
            this.parentSalesOrgId = _data["parentSalesOrgId"];
            this.allocateAmount = _data["allocateAmount"];
            this.remainAmount = _data["remainAmount"];
            this.usedAmount = _data["usedAmount"];
        }
    }

    static fromJS(data: any): BudgetAreaUpsertDto {
        data = typeof data === 'object' ? data : {};
        let result = new BudgetAreaUpsertDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["areaId"] = this.areaId;
        data["areaCode"] = this.areaCode;
        data["areaName"] = this.areaName;
        data["salesOrgId"] = this.salesOrgId;
        data["parentSalesOrgId"] = this.parentSalesOrgId;
        data["allocateAmount"] = this.allocateAmount;
        data["remainAmount"] = this.remainAmount;
        data["usedAmount"] = this.usedAmount;
        return data;
    }

    clone(): BudgetAreaUpsertDto {
        const json = this.toJSON();
        let result = new BudgetAreaUpsertDto();
        result.init(json);
        return result;
    }
}

export interface IBudgetAreaUpsertDto {
    id?: number;
    areaId?: number;
    areaCode?: string | undefined;
    areaName?: string | undefined;
    salesOrgId?: number;
    parentSalesOrgId?: number;
    allocateAmount?: number;
    remainAmount?: number;
    usedAmount?: number;
}

export class BudgetAreaUpsertDtoCrudListDto implements IBudgetAreaUpsertDtoCrudListDto {
    upsertedItems?: BudgetAreaUpsertDto[] | undefined;
    deletedItems?: BudgetAreaUpsertDto[] | undefined;

    constructor(data?: IBudgetAreaUpsertDtoCrudListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["upsertedItems"])) {
                this.upsertedItems = [] as any;
                for (let item of _data["upsertedItems"])
                    this.upsertedItems!.push(BudgetAreaUpsertDto.fromJS(item));
            }
            if (Array.isArray(_data["deletedItems"])) {
                this.deletedItems = [] as any;
                for (let item of _data["deletedItems"])
                    this.deletedItems!.push(BudgetAreaUpsertDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BudgetAreaUpsertDtoCrudListDto {
        data = typeof data === 'object' ? data : {};
        let result = new BudgetAreaUpsertDtoCrudListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.upsertedItems)) {
            data["upsertedItems"] = [];
            for (let item of this.upsertedItems)
                data["upsertedItems"].push(item.toJSON());
        }
        if (Array.isArray(this.deletedItems)) {
            data["deletedItems"] = [];
            for (let item of this.deletedItems)
                data["deletedItems"].push(item.toJSON());
        }
        return data;
    }

    clone(): BudgetAreaUpsertDtoCrudListDto {
        const json = this.toJSON();
        let result = new BudgetAreaUpsertDtoCrudListDto();
        result.init(json);
        return result;
    }
}

export interface IBudgetAreaUpsertDtoCrudListDto {
    upsertedItems?: BudgetAreaUpsertDto[] | undefined;
    deletedItems?: BudgetAreaUpsertDto[] | undefined;
}

export class BudgetBranchDto implements IBudgetBranchDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    branchId?: number;
    branchCode?: string | undefined;
    branchName?: string | undefined;
    zoneId?: number;
    zoneName?: string | undefined;
    areaId?: number;
    areaName?: string | undefined;
    salesOrgId?: number;
    parentSalesOrgId?: number;
    allocateAmount?: number;
    remainAmount?: number;
    usedAmount?: number;
    tempRemainAmount?: number;
    tempUsedAmount?: number;

    constructor(data?: IBudgetBranchDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.branchId = _data["branchId"];
            this.branchCode = _data["branchCode"];
            this.branchName = _data["branchName"];
            this.zoneId = _data["zoneId"];
            this.zoneName = _data["zoneName"];
            this.areaId = _data["areaId"];
            this.areaName = _data["areaName"];
            this.salesOrgId = _data["salesOrgId"];
            this.parentSalesOrgId = _data["parentSalesOrgId"];
            this.allocateAmount = _data["allocateAmount"];
            this.remainAmount = _data["remainAmount"];
            this.usedAmount = _data["usedAmount"];
            this.tempRemainAmount = _data["tempRemainAmount"];
            this.tempUsedAmount = _data["tempUsedAmount"];
        }
    }

    static fromJS(data: any): BudgetBranchDto {
        data = typeof data === 'object' ? data : {};
        let result = new BudgetBranchDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["branchId"] = this.branchId;
        data["branchCode"] = this.branchCode;
        data["branchName"] = this.branchName;
        data["zoneId"] = this.zoneId;
        data["zoneName"] = this.zoneName;
        data["areaId"] = this.areaId;
        data["areaName"] = this.areaName;
        data["salesOrgId"] = this.salesOrgId;
        data["parentSalesOrgId"] = this.parentSalesOrgId;
        data["allocateAmount"] = this.allocateAmount;
        data["remainAmount"] = this.remainAmount;
        data["usedAmount"] = this.usedAmount;
        data["tempRemainAmount"] = this.tempRemainAmount;
        data["tempUsedAmount"] = this.tempUsedAmount;
        return data;
    }

    clone(): BudgetBranchDto {
        const json = this.toJSON();
        let result = new BudgetBranchDto();
        result.init(json);
        return result;
    }
}

export interface IBudgetBranchDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    branchId?: number;
    branchCode?: string | undefined;
    branchName?: string | undefined;
    zoneId?: number;
    zoneName?: string | undefined;
    areaId?: number;
    areaName?: string | undefined;
    salesOrgId?: number;
    parentSalesOrgId?: number;
    allocateAmount?: number;
    remainAmount?: number;
    usedAmount?: number;
    tempRemainAmount?: number;
    tempUsedAmount?: number;
}

export class BudgetBranchUpsertDto implements IBudgetBranchUpsertDto {
    id?: number;
    branchId?: number;
    branchCode?: string | undefined;
    branchName?: string | undefined;
    salesOrgId?: number;
    parentSalesOrgId?: number;
    allocateAmount?: number;
    remainAmount?: number;
    usedAmount?: number;

    constructor(data?: IBudgetBranchUpsertDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.branchId = _data["branchId"];
            this.branchCode = _data["branchCode"];
            this.branchName = _data["branchName"];
            this.salesOrgId = _data["salesOrgId"];
            this.parentSalesOrgId = _data["parentSalesOrgId"];
            this.allocateAmount = _data["allocateAmount"];
            this.remainAmount = _data["remainAmount"];
            this.usedAmount = _data["usedAmount"];
        }
    }

    static fromJS(data: any): BudgetBranchUpsertDto {
        data = typeof data === 'object' ? data : {};
        let result = new BudgetBranchUpsertDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["branchId"] = this.branchId;
        data["branchCode"] = this.branchCode;
        data["branchName"] = this.branchName;
        data["salesOrgId"] = this.salesOrgId;
        data["parentSalesOrgId"] = this.parentSalesOrgId;
        data["allocateAmount"] = this.allocateAmount;
        data["remainAmount"] = this.remainAmount;
        data["usedAmount"] = this.usedAmount;
        return data;
    }

    clone(): BudgetBranchUpsertDto {
        const json = this.toJSON();
        let result = new BudgetBranchUpsertDto();
        result.init(json);
        return result;
    }
}

export interface IBudgetBranchUpsertDto {
    id?: number;
    branchId?: number;
    branchCode?: string | undefined;
    branchName?: string | undefined;
    salesOrgId?: number;
    parentSalesOrgId?: number;
    allocateAmount?: number;
    remainAmount?: number;
    usedAmount?: number;
}

export class BudgetBranchUpsertDtoCrudListDto implements IBudgetBranchUpsertDtoCrudListDto {
    upsertedItems?: BudgetBranchUpsertDto[] | undefined;
    deletedItems?: BudgetBranchUpsertDto[] | undefined;

    constructor(data?: IBudgetBranchUpsertDtoCrudListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["upsertedItems"])) {
                this.upsertedItems = [] as any;
                for (let item of _data["upsertedItems"])
                    this.upsertedItems!.push(BudgetBranchUpsertDto.fromJS(item));
            }
            if (Array.isArray(_data["deletedItems"])) {
                this.deletedItems = [] as any;
                for (let item of _data["deletedItems"])
                    this.deletedItems!.push(BudgetBranchUpsertDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BudgetBranchUpsertDtoCrudListDto {
        data = typeof data === 'object' ? data : {};
        let result = new BudgetBranchUpsertDtoCrudListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.upsertedItems)) {
            data["upsertedItems"] = [];
            for (let item of this.upsertedItems)
                data["upsertedItems"].push(item.toJSON());
        }
        if (Array.isArray(this.deletedItems)) {
            data["deletedItems"] = [];
            for (let item of this.deletedItems)
                data["deletedItems"].push(item.toJSON());
        }
        return data;
    }

    clone(): BudgetBranchUpsertDtoCrudListDto {
        const json = this.toJSON();
        let result = new BudgetBranchUpsertDtoCrudListDto();
        result.init(json);
        return result;
    }
}

export interface IBudgetBranchUpsertDtoCrudListDto {
    upsertedItems?: BudgetBranchUpsertDto[] | undefined;
    deletedItems?: BudgetBranchUpsertDto[] | undefined;
}

export class BudgetDto implements IBudgetDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    cycleId?: number;
    fromDate?: Date;
    toDate?: Date;
    investmentType?: number;
    zones?: BudgetZoneDto[] | undefined;
    areas?: BudgetAreaDto[] | undefined;
    branches?: BudgetBranchDto[] | undefined;

    constructor(data?: IBudgetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.cycleId = _data["cycleId"];
            this.fromDate = _data["fromDate"] ? new Date(_data["fromDate"].toString()) : <any>undefined;
            this.toDate = _data["toDate"] ? new Date(_data["toDate"].toString()) : <any>undefined;
            this.investmentType = _data["investmentType"];
            if (Array.isArray(_data["zones"])) {
                this.zones = [] as any;
                for (let item of _data["zones"])
                    this.zones!.push(BudgetZoneDto.fromJS(item));
            }
            if (Array.isArray(_data["areas"])) {
                this.areas = [] as any;
                for (let item of _data["areas"])
                    this.areas!.push(BudgetAreaDto.fromJS(item));
            }
            if (Array.isArray(_data["branches"])) {
                this.branches = [] as any;
                for (let item of _data["branches"])
                    this.branches!.push(BudgetBranchDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BudgetDto {
        data = typeof data === 'object' ? data : {};
        let result = new BudgetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["cycleId"] = this.cycleId;
        data["fromDate"] = this.fromDate ? this.fromDate.toISOString() : <any>undefined;
        data["toDate"] = this.toDate ? this.toDate.toISOString() : <any>undefined;
        data["investmentType"] = this.investmentType;
        if (Array.isArray(this.zones)) {
            data["zones"] = [];
            for (let item of this.zones)
                data["zones"].push(item.toJSON());
        }
        if (Array.isArray(this.areas)) {
            data["areas"] = [];
            for (let item of this.areas)
                data["areas"].push(item.toJSON());
        }
        if (Array.isArray(this.branches)) {
            data["branches"] = [];
            for (let item of this.branches)
                data["branches"].push(item.toJSON());
        }
        return data;
    }

    clone(): BudgetDto {
        const json = this.toJSON();
        let result = new BudgetDto();
        result.init(json);
        return result;
    }
}

export interface IBudgetDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    cycleId?: number;
    fromDate?: Date;
    toDate?: Date;
    investmentType?: number;
    zones?: BudgetZoneDto[] | undefined;
    areas?: BudgetAreaDto[] | undefined;
    branches?: BudgetBranchDto[] | undefined;
}

export class BudgetDtoApiResultObject implements IBudgetDtoApiResultObject {
    result?: BudgetDto;
    success?: boolean;

    constructor(data?: IBudgetDtoApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? BudgetDto.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): BudgetDtoApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new BudgetDtoApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data;
    }

    clone(): BudgetDtoApiResultObject {
        const json = this.toJSON();
        let result = new BudgetDtoApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IBudgetDtoApiResultObject {
    result?: BudgetDto;
    success?: boolean;
}

export class BudgetHistoryByUserDto implements IBudgetHistoryByUserDto {
    investmentType?: number;
    allocateAmount?: number;
    tempUsedAmount?: number;
    tempRemainAmount?: number;
    usedAmount?: number;
    remainAmount?: number;
    calls?: number;

    constructor(data?: IBudgetHistoryByUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.investmentType = _data["investmentType"];
            this.allocateAmount = _data["allocateAmount"];
            this.tempUsedAmount = _data["tempUsedAmount"];
            this.tempRemainAmount = _data["tempRemainAmount"];
            this.usedAmount = _data["usedAmount"];
            this.remainAmount = _data["remainAmount"];
            this.calls = _data["calls"];
        }
    }

    static fromJS(data: any): BudgetHistoryByUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new BudgetHistoryByUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["investmentType"] = this.investmentType;
        data["allocateAmount"] = this.allocateAmount;
        data["tempUsedAmount"] = this.tempUsedAmount;
        data["tempRemainAmount"] = this.tempRemainAmount;
        data["usedAmount"] = this.usedAmount;
        data["remainAmount"] = this.remainAmount;
        data["calls"] = this.calls;
        return data;
    }

    clone(): BudgetHistoryByUserDto {
        const json = this.toJSON();
        let result = new BudgetHistoryByUserDto();
        result.init(json);
        return result;
    }
}

export interface IBudgetHistoryByUserDto {
    investmentType?: number;
    allocateAmount?: number;
    tempUsedAmount?: number;
    tempRemainAmount?: number;
    usedAmount?: number;
    remainAmount?: number;
    calls?: number;
}

export class BudgetHistoryByUserDtoListApiResultObject implements IBudgetHistoryByUserDtoListApiResultObject {
    result?: BudgetHistoryByUserDto[] | undefined;
    success?: boolean;

    constructor(data?: IBudgetHistoryByUserDtoListApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(BudgetHistoryByUserDto.fromJS(item));
            }
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): BudgetHistoryByUserDtoListApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new BudgetHistoryByUserDtoListApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["success"] = this.success;
        return data;
    }

    clone(): BudgetHistoryByUserDtoListApiResultObject {
        const json = this.toJSON();
        let result = new BudgetHistoryByUserDtoListApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IBudgetHistoryByUserDtoListApiResultObject {
    result?: BudgetHistoryByUserDto[] | undefined;
    success?: boolean;
}

export class BudgetInitDetailDto implements IBudgetInitDetailDto {
    zones?: BudgetZoneDto[] | undefined;
    areas?: BudgetAreaDto[] | undefined;
    branches?: BudgetBranchDto[] | undefined;

    constructor(data?: IBudgetInitDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["zones"])) {
                this.zones = [] as any;
                for (let item of _data["zones"])
                    this.zones!.push(BudgetZoneDto.fromJS(item));
            }
            if (Array.isArray(_data["areas"])) {
                this.areas = [] as any;
                for (let item of _data["areas"])
                    this.areas!.push(BudgetAreaDto.fromJS(item));
            }
            if (Array.isArray(_data["branches"])) {
                this.branches = [] as any;
                for (let item of _data["branches"])
                    this.branches!.push(BudgetBranchDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BudgetInitDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new BudgetInitDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.zones)) {
            data["zones"] = [];
            for (let item of this.zones)
                data["zones"].push(item.toJSON());
        }
        if (Array.isArray(this.areas)) {
            data["areas"] = [];
            for (let item of this.areas)
                data["areas"].push(item.toJSON());
        }
        if (Array.isArray(this.branches)) {
            data["branches"] = [];
            for (let item of this.branches)
                data["branches"].push(item.toJSON());
        }
        return data;
    }

    clone(): BudgetInitDetailDto {
        const json = this.toJSON();
        let result = new BudgetInitDetailDto();
        result.init(json);
        return result;
    }
}

export interface IBudgetInitDetailDto {
    zones?: BudgetZoneDto[] | undefined;
    areas?: BudgetAreaDto[] | undefined;
    branches?: BudgetBranchDto[] | undefined;
}

export class BudgetInitDetailDtoApiResultObject implements IBudgetInitDetailDtoApiResultObject {
    result?: BudgetInitDetailDto;
    success?: boolean;

    constructor(data?: IBudgetInitDetailDtoApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? BudgetInitDetailDto.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): BudgetInitDetailDtoApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new BudgetInitDetailDtoApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data;
    }

    clone(): BudgetInitDetailDtoApiResultObject {
        const json = this.toJSON();
        let result = new BudgetInitDetailDtoApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IBudgetInitDetailDtoApiResultObject {
    result?: BudgetInitDetailDto;
    success?: boolean;
}

export enum BudgetInvestmentType {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export class BudgetListItemDto implements IBudgetListItemDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    cycleId?: number;
    cycleNumber?: string | undefined;
    investmentType?: number;
    usedAmount?: number;
    remainAmount?: number;
    allocateAmount?: number;
    tempRemainAmount?: number;
    tempUsedAmount?: number;

    constructor(data?: IBudgetListItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.cycleId = _data["cycleId"];
            this.cycleNumber = _data["cycleNumber"];
            this.investmentType = _data["investmentType"];
            this.usedAmount = _data["usedAmount"];
            this.remainAmount = _data["remainAmount"];
            this.allocateAmount = _data["allocateAmount"];
            this.tempRemainAmount = _data["tempRemainAmount"];
            this.tempUsedAmount = _data["tempUsedAmount"];
        }
    }

    static fromJS(data: any): BudgetListItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new BudgetListItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["cycleId"] = this.cycleId;
        data["cycleNumber"] = this.cycleNumber;
        data["investmentType"] = this.investmentType;
        data["usedAmount"] = this.usedAmount;
        data["remainAmount"] = this.remainAmount;
        data["allocateAmount"] = this.allocateAmount;
        data["tempRemainAmount"] = this.tempRemainAmount;
        data["tempUsedAmount"] = this.tempUsedAmount;
        return data;
    }

    clone(): BudgetListItemDto {
        const json = this.toJSON();
        let result = new BudgetListItemDto();
        result.init(json);
        return result;
    }
}

export interface IBudgetListItemDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    cycleId?: number;
    cycleNumber?: string | undefined;
    investmentType?: number;
    usedAmount?: number;
    remainAmount?: number;
    allocateAmount?: number;
    tempRemainAmount?: number;
    tempUsedAmount?: number;
}

export class BudgetListItemDtoPagingResult implements IBudgetListItemDtoPagingResult {
    items?: BudgetListItemDto[] | undefined;
    totalCount?: number;

    constructor(data?: IBudgetListItemDtoPagingResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(BudgetListItemDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): BudgetListItemDtoPagingResult {
        data = typeof data === 'object' ? data : {};
        let result = new BudgetListItemDtoPagingResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): BudgetListItemDtoPagingResult {
        const json = this.toJSON();
        let result = new BudgetListItemDtoPagingResult();
        result.init(json);
        return result;
    }
}

export interface IBudgetListItemDtoPagingResult {
    items?: BudgetListItemDto[] | undefined;
    totalCount?: number;
}

export class BudgetListItemDtoPagingResultApiResultObject implements IBudgetListItemDtoPagingResultApiResultObject {
    result?: BudgetListItemDtoPagingResult;
    success?: boolean;

    constructor(data?: IBudgetListItemDtoPagingResultApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? BudgetListItemDtoPagingResult.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): BudgetListItemDtoPagingResultApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new BudgetListItemDtoPagingResultApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data;
    }

    clone(): BudgetListItemDtoPagingResultApiResultObject {
        const json = this.toJSON();
        let result = new BudgetListItemDtoPagingResultApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IBudgetListItemDtoPagingResultApiResultObject {
    result?: BudgetListItemDtoPagingResult;
    success?: boolean;
}

export class BudgetUpsertCommand implements IBudgetUpsertCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: BudgetUpsertDto;
    readonly handleType?: string | undefined;

    constructor(data?: IBudgetUpsertCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? BudgetUpsertDto.fromJS(_data["data"]) : <any>undefined;
            (<any>this).handleType = _data["handleType"];
        }
    }

    static fromJS(data: any): BudgetUpsertCommand {
        data = typeof data === 'object' ? data : {};
        let result = new BudgetUpsertCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["handleType"] = this.handleType;
        return data;
    }

    clone(): BudgetUpsertCommand {
        const json = this.toJSON();
        let result = new BudgetUpsertCommand();
        result.init(json);
        return result;
    }
}

export interface IBudgetUpsertCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: BudgetUpsertDto;
    handleType?: string | undefined;
}

export class BudgetUpsertDto implements IBudgetUpsertDto {
    id?: number;
    cycleId?: number;
    investmentType?: BudgetInvestmentType;
    zonesChanges?: BudgetZoneUpsertDtoCrudListDto;
    areasChanges?: BudgetAreaUpsertDtoCrudListDto;
    branchesChanges?: BudgetBranchUpsertDtoCrudListDto;

    constructor(data?: IBudgetUpsertDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.cycleId = _data["cycleId"];
            this.investmentType = _data["investmentType"];
            this.zonesChanges = _data["zonesChanges"] ? BudgetZoneUpsertDtoCrudListDto.fromJS(_data["zonesChanges"]) : <any>undefined;
            this.areasChanges = _data["areasChanges"] ? BudgetAreaUpsertDtoCrudListDto.fromJS(_data["areasChanges"]) : <any>undefined;
            this.branchesChanges = _data["branchesChanges"] ? BudgetBranchUpsertDtoCrudListDto.fromJS(_data["branchesChanges"]) : <any>undefined;
        }
    }

    static fromJS(data: any): BudgetUpsertDto {
        data = typeof data === 'object' ? data : {};
        let result = new BudgetUpsertDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["cycleId"] = this.cycleId;
        data["investmentType"] = this.investmentType;
        data["zonesChanges"] = this.zonesChanges ? this.zonesChanges.toJSON() : <any>undefined;
        data["areasChanges"] = this.areasChanges ? this.areasChanges.toJSON() : <any>undefined;
        data["branchesChanges"] = this.branchesChanges ? this.branchesChanges.toJSON() : <any>undefined;
        return data;
    }

    clone(): BudgetUpsertDto {
        const json = this.toJSON();
        let result = new BudgetUpsertDto();
        result.init(json);
        return result;
    }
}

export interface IBudgetUpsertDto {
    id?: number;
    cycleId?: number;
    investmentType?: BudgetInvestmentType;
    zonesChanges?: BudgetZoneUpsertDtoCrudListDto;
    areasChanges?: BudgetAreaUpsertDtoCrudListDto;
    branchesChanges?: BudgetBranchUpsertDtoCrudListDto;
}

export class BudgetZoneDto implements IBudgetZoneDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    zoneId?: number;
    zoneCode?: string | undefined;
    zoneName?: string | undefined;
    salesOrgId?: number;
    parentSalesOrgId?: number;
    allocateAmount?: number;
    remainAmount?: number;
    usedAmount?: number;
    tempRemainAmount?: number;
    tempUsedAmount?: number;

    constructor(data?: IBudgetZoneDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.zoneId = _data["zoneId"];
            this.zoneCode = _data["zoneCode"];
            this.zoneName = _data["zoneName"];
            this.salesOrgId = _data["salesOrgId"];
            this.parentSalesOrgId = _data["parentSalesOrgId"];
            this.allocateAmount = _data["allocateAmount"];
            this.remainAmount = _data["remainAmount"];
            this.usedAmount = _data["usedAmount"];
            this.tempRemainAmount = _data["tempRemainAmount"];
            this.tempUsedAmount = _data["tempUsedAmount"];
        }
    }

    static fromJS(data: any): BudgetZoneDto {
        data = typeof data === 'object' ? data : {};
        let result = new BudgetZoneDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["zoneId"] = this.zoneId;
        data["zoneCode"] = this.zoneCode;
        data["zoneName"] = this.zoneName;
        data["salesOrgId"] = this.salesOrgId;
        data["parentSalesOrgId"] = this.parentSalesOrgId;
        data["allocateAmount"] = this.allocateAmount;
        data["remainAmount"] = this.remainAmount;
        data["usedAmount"] = this.usedAmount;
        data["tempRemainAmount"] = this.tempRemainAmount;
        data["tempUsedAmount"] = this.tempUsedAmount;
        return data;
    }

    clone(): BudgetZoneDto {
        const json = this.toJSON();
        let result = new BudgetZoneDto();
        result.init(json);
        return result;
    }
}

export interface IBudgetZoneDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    zoneId?: number;
    zoneCode?: string | undefined;
    zoneName?: string | undefined;
    salesOrgId?: number;
    parentSalesOrgId?: number;
    allocateAmount?: number;
    remainAmount?: number;
    usedAmount?: number;
    tempRemainAmount?: number;
    tempUsedAmount?: number;
}

export class BudgetZoneUpsertDto implements IBudgetZoneUpsertDto {
    id?: number;
    zoneId?: number;
    zoneCode?: string | undefined;
    zoneName?: string | undefined;
    salesOrgId?: number;
    parentSalesOrgId?: number;
    allocateAmount?: number;
    remainAmount?: number;
    usedAmount?: number;

    constructor(data?: IBudgetZoneUpsertDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.zoneId = _data["zoneId"];
            this.zoneCode = _data["zoneCode"];
            this.zoneName = _data["zoneName"];
            this.salesOrgId = _data["salesOrgId"];
            this.parentSalesOrgId = _data["parentSalesOrgId"];
            this.allocateAmount = _data["allocateAmount"];
            this.remainAmount = _data["remainAmount"];
            this.usedAmount = _data["usedAmount"];
        }
    }

    static fromJS(data: any): BudgetZoneUpsertDto {
        data = typeof data === 'object' ? data : {};
        let result = new BudgetZoneUpsertDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["zoneId"] = this.zoneId;
        data["zoneCode"] = this.zoneCode;
        data["zoneName"] = this.zoneName;
        data["salesOrgId"] = this.salesOrgId;
        data["parentSalesOrgId"] = this.parentSalesOrgId;
        data["allocateAmount"] = this.allocateAmount;
        data["remainAmount"] = this.remainAmount;
        data["usedAmount"] = this.usedAmount;
        return data;
    }

    clone(): BudgetZoneUpsertDto {
        const json = this.toJSON();
        let result = new BudgetZoneUpsertDto();
        result.init(json);
        return result;
    }
}

export interface IBudgetZoneUpsertDto {
    id?: number;
    zoneId?: number;
    zoneCode?: string | undefined;
    zoneName?: string | undefined;
    salesOrgId?: number;
    parentSalesOrgId?: number;
    allocateAmount?: number;
    remainAmount?: number;
    usedAmount?: number;
}

export class BudgetZoneUpsertDtoCrudListDto implements IBudgetZoneUpsertDtoCrudListDto {
    upsertedItems?: BudgetZoneUpsertDto[] | undefined;
    deletedItems?: BudgetZoneUpsertDto[] | undefined;

    constructor(data?: IBudgetZoneUpsertDtoCrudListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["upsertedItems"])) {
                this.upsertedItems = [] as any;
                for (let item of _data["upsertedItems"])
                    this.upsertedItems!.push(BudgetZoneUpsertDto.fromJS(item));
            }
            if (Array.isArray(_data["deletedItems"])) {
                this.deletedItems = [] as any;
                for (let item of _data["deletedItems"])
                    this.deletedItems!.push(BudgetZoneUpsertDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BudgetZoneUpsertDtoCrudListDto {
        data = typeof data === 'object' ? data : {};
        let result = new BudgetZoneUpsertDtoCrudListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.upsertedItems)) {
            data["upsertedItems"] = [];
            for (let item of this.upsertedItems)
                data["upsertedItems"].push(item.toJSON());
        }
        if (Array.isArray(this.deletedItems)) {
            data["deletedItems"] = [];
            for (let item of this.deletedItems)
                data["deletedItems"].push(item.toJSON());
        }
        return data;
    }

    clone(): BudgetZoneUpsertDtoCrudListDto {
        const json = this.toJSON();
        let result = new BudgetZoneUpsertDtoCrudListDto();
        result.init(json);
        return result;
    }
}

export interface IBudgetZoneUpsertDtoCrudListDto {
    upsertedItems?: BudgetZoneUpsertDto[] | undefined;
    deletedItems?: BudgetZoneUpsertDto[] | undefined;
}

export class ChangeUserPasswordCommand implements IChangeUserPasswordCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    newPassword?: string | undefined;

    constructor(data?: IChangeUserPasswordCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ChangeUserPasswordCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUserPasswordCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["newPassword"] = this.newPassword;
        return data;
    }

    clone(): ChangeUserPasswordCommand {
        const json = this.toJSON();
        let result = new ChangeUserPasswordCommand();
        result.init(json);
        return result;
    }
}

export interface IChangeUserPasswordCommand {
    commandId?: string;
    occuredDate?: Date;
    newPassword?: string | undefined;
}

export class ConsumerInfoDto implements IConsumerInfoDto {
    name?: string | undefined;
    phone?: string | undefined;

    constructor(data?: IConsumerInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.phone = _data["phone"];
        }
    }

    static fromJS(data: any): ConsumerInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConsumerInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["phone"] = this.phone;
        return data;
    }

    clone(): ConsumerInfoDto {
        const json = this.toJSON();
        let result = new ConsumerInfoDto();
        result.init(json);
        return result;
    }
}

export interface IConsumerInfoDto {
    name?: string | undefined;
    phone?: string | undefined;
}

export class ConsumerInfoDtoApiResultObject implements IConsumerInfoDtoApiResultObject {
    result?: ConsumerInfoDto;
    success?: boolean;

    constructor(data?: IConsumerInfoDtoApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? ConsumerInfoDto.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): ConsumerInfoDtoApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new ConsumerInfoDtoApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data;
    }

    clone(): ConsumerInfoDtoApiResultObject {
        const json = this.toJSON();
        let result = new ConsumerInfoDtoApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IConsumerInfoDtoApiResultObject {
    result?: ConsumerInfoDto;
    success?: boolean;
}

export class ConsumerRewardDetail implements IConsumerRewardDetail {
    id?: number;
    ticketId?: number;
    note?: string | undefined;

    constructor(data?: IConsumerRewardDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.ticketId = _data["ticketId"];
            this.note = _data["note"];
        }
    }

    static fromJS(data: any): ConsumerRewardDetail {
        data = typeof data === 'object' ? data : {};
        let result = new ConsumerRewardDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["ticketId"] = this.ticketId;
        data["note"] = this.note;
        return data;
    }

    clone(): ConsumerRewardDetail {
        const json = this.toJSON();
        let result = new ConsumerRewardDetail();
        result.init(json);
        return result;
    }
}

export interface IConsumerRewardDetail {
    id?: number;
    ticketId?: number;
    note?: string | undefined;
}

export class ConsumerRewardDetailCrudListDto implements IConsumerRewardDetailCrudListDto {
    upsertedItems?: ConsumerRewardDetail[] | undefined;
    deletedItems?: ConsumerRewardDetail[] | undefined;

    constructor(data?: IConsumerRewardDetailCrudListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["upsertedItems"])) {
                this.upsertedItems = [] as any;
                for (let item of _data["upsertedItems"])
                    this.upsertedItems!.push(ConsumerRewardDetail.fromJS(item));
            }
            if (Array.isArray(_data["deletedItems"])) {
                this.deletedItems = [] as any;
                for (let item of _data["deletedItems"])
                    this.deletedItems!.push(ConsumerRewardDetail.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ConsumerRewardDetailCrudListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConsumerRewardDetailCrudListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.upsertedItems)) {
            data["upsertedItems"] = [];
            for (let item of this.upsertedItems)
                data["upsertedItems"].push(item.toJSON());
        }
        if (Array.isArray(this.deletedItems)) {
            data["deletedItems"] = [];
            for (let item of this.deletedItems)
                data["deletedItems"].push(item.toJSON());
        }
        return data;
    }

    clone(): ConsumerRewardDetailCrudListDto {
        const json = this.toJSON();
        let result = new ConsumerRewardDetailCrudListDto();
        result.init(json);
        return result;
    }
}

export interface IConsumerRewardDetailCrudListDto {
    upsertedItems?: ConsumerRewardDetail[] | undefined;
    deletedItems?: ConsumerRewardDetail[] | undefined;
}

export class ConsumerSendOtpCommand implements IConsumerSendOtpCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: ConsumerSendOtpDto;

    constructor(data?: IConsumerSendOtpCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? ConsumerSendOtpDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ConsumerSendOtpCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ConsumerSendOtpCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }

    clone(): ConsumerSendOtpCommand {
        const json = this.toJSON();
        let result = new ConsumerSendOtpCommand();
        result.init(json);
        return result;
    }
}

export interface IConsumerSendOtpCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: ConsumerSendOtpDto;
}

export class ConsumerSendOtpDto implements IConsumerSendOtpDto {
    phone?: string | undefined;

    constructor(data?: IConsumerSendOtpDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.phone = _data["phone"];
        }
    }

    static fromJS(data: any): ConsumerSendOtpDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConsumerSendOtpDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["phone"] = this.phone;
        return data;
    }

    clone(): ConsumerSendOtpDto {
        const json = this.toJSON();
        let result = new ConsumerSendOtpDto();
        result.init(json);
        return result;
    }
}

export interface IConsumerSendOtpDto {
    phone?: string | undefined;
}

export class ConsumerValidateOtpCommand implements IConsumerValidateOtpCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: ConsumerValidateOtpDto;

    constructor(data?: IConsumerValidateOtpCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? ConsumerValidateOtpDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ConsumerValidateOtpCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ConsumerValidateOtpCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }

    clone(): ConsumerValidateOtpCommand {
        const json = this.toJSON();
        let result = new ConsumerValidateOtpCommand();
        result.init(json);
        return result;
    }
}

export interface IConsumerValidateOtpCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: ConsumerValidateOtpDto;
}

export class ConsumerValidateOtpDto implements IConsumerValidateOtpDto {
    phone?: string | undefined;
    otpCode?: string | undefined;

    constructor(data?: IConsumerValidateOtpDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.phone = _data["phone"];
            this.otpCode = _data["otpCode"];
        }
    }

    static fromJS(data: any): ConsumerValidateOtpDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConsumerValidateOtpDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["phone"] = this.phone;
        data["otpCode"] = this.otpCode;
        return data;
    }

    clone(): ConsumerValidateOtpDto {
        const json = this.toJSON();
        let result = new ConsumerValidateOtpDto();
        result.init(json);
        return result;
    }
}

export interface IConsumerValidateOtpDto {
    phone?: string | undefined;
    otpCode?: string | undefined;
}

export class CustomerActivateKeyShopCommand implements ICustomerActivateKeyShopCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: CustomerActivateKeyShopDto;

    constructor(data?: ICustomerActivateKeyShopCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? CustomerActivateKeyShopDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CustomerActivateKeyShopCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerActivateKeyShopCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }

    clone(): CustomerActivateKeyShopCommand {
        const json = this.toJSON();
        let result = new CustomerActivateKeyShopCommand();
        result.init(json);
        return result;
    }
}

export interface ICustomerActivateKeyShopCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: CustomerActivateKeyShopDto;
}

export class CustomerActivateKeyShopDto implements ICustomerActivateKeyShopDto {
    code?: string | undefined;
    otpCode?: string | undefined;
    password?: string | undefined;

    constructor(data?: ICustomerActivateKeyShopDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.otpCode = _data["otpCode"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): CustomerActivateKeyShopDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerActivateKeyShopDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["otpCode"] = this.otpCode;
        data["password"] = this.password;
        return data;
    }

    clone(): CustomerActivateKeyShopDto {
        const json = this.toJSON();
        let result = new CustomerActivateKeyShopDto();
        result.init(json);
        return result;
    }
}

export interface ICustomerActivateKeyShopDto {
    code?: string | undefined;
    otpCode?: string | undefined;
    password?: string | undefined;
}

export class CustomerApproveKeyShopCommand implements ICustomerApproveKeyShopCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: number[] | undefined;

    constructor(data?: ICustomerApproveKeyShopCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(item);
            }
        }
    }

    static fromJS(data: any): CustomerApproveKeyShopCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerApproveKeyShopCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item);
        }
        return data;
    }

    clone(): CustomerApproveKeyShopCommand {
        const json = this.toJSON();
        let result = new CustomerApproveKeyShopCommand();
        result.init(json);
        return result;
    }
}

export interface ICustomerApproveKeyShopCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: number[] | undefined;
}

export class CustomerApproveKeyShopListDto implements ICustomerApproveKeyShopListDto {
    id?: string | undefined;
    isSelected?: boolean;
    code?: string | undefined;
    name?: string | undefined;
    mobilePhone?: string | undefined;
    birthday?: Date | undefined;
    address?: string | undefined;
    keyShopStatus?: number;
    keyShopRegisterStaffId?: number;
    staffName?: string | undefined;
    channelCode?: string | undefined;
    channelName?: string | undefined;
    email?: string | undefined;
    keyShopAuthCode?: string | undefined;
    zoneId?: number;
    areaId?: number;

    constructor(data?: ICustomerApproveKeyShopListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.isSelected = _data["isSelected"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.mobilePhone = _data["mobilePhone"];
            this.birthday = _data["birthday"] ? new Date(_data["birthday"].toString()) : <any>undefined;
            this.address = _data["address"];
            this.keyShopStatus = _data["keyShopStatus"];
            this.keyShopRegisterStaffId = _data["keyShopRegisterStaffId"];
            this.staffName = _data["staffName"];
            this.channelCode = _data["channelCode"];
            this.channelName = _data["channelName"];
            this.email = _data["email"];
            this.keyShopAuthCode = _data["keyShopAuthCode"];
            this.zoneId = _data["zoneId"];
            this.areaId = _data["areaId"];
        }
    }

    static fromJS(data: any): CustomerApproveKeyShopListDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerApproveKeyShopListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["isSelected"] = this.isSelected;
        data["code"] = this.code;
        data["name"] = this.name;
        data["mobilePhone"] = this.mobilePhone;
        data["birthday"] = this.birthday ? this.birthday.toISOString() : <any>undefined;
        data["address"] = this.address;
        data["keyShopStatus"] = this.keyShopStatus;
        data["keyShopRegisterStaffId"] = this.keyShopRegisterStaffId;
        data["staffName"] = this.staffName;
        data["channelCode"] = this.channelCode;
        data["channelName"] = this.channelName;
        data["email"] = this.email;
        data["keyShopAuthCode"] = this.keyShopAuthCode;
        data["zoneId"] = this.zoneId;
        data["areaId"] = this.areaId;
        return data;
    }

    clone(): CustomerApproveKeyShopListDto {
        const json = this.toJSON();
        let result = new CustomerApproveKeyShopListDto();
        result.init(json);
        return result;
    }
}

export interface ICustomerApproveKeyShopListDto {
    id?: string | undefined;
    isSelected?: boolean;
    code?: string | undefined;
    name?: string | undefined;
    mobilePhone?: string | undefined;
    birthday?: Date | undefined;
    address?: string | undefined;
    keyShopStatus?: number;
    keyShopRegisterStaffId?: number;
    staffName?: string | undefined;
    channelCode?: string | undefined;
    channelName?: string | undefined;
    email?: string | undefined;
    keyShopAuthCode?: string | undefined;
    zoneId?: number;
    areaId?: number;
}

export class CustomerApproveKeyShopListDtoPagingResult implements ICustomerApproveKeyShopListDtoPagingResult {
    items?: CustomerApproveKeyShopListDto[] | undefined;
    totalCount?: number;

    constructor(data?: ICustomerApproveKeyShopListDtoPagingResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CustomerApproveKeyShopListDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): CustomerApproveKeyShopListDtoPagingResult {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerApproveKeyShopListDtoPagingResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): CustomerApproveKeyShopListDtoPagingResult {
        const json = this.toJSON();
        let result = new CustomerApproveKeyShopListDtoPagingResult();
        result.init(json);
        return result;
    }
}

export interface ICustomerApproveKeyShopListDtoPagingResult {
    items?: CustomerApproveKeyShopListDto[] | undefined;
    totalCount?: number;
}

export class CustomerApproveKeyShopListDtoPagingResultApiResultObject implements ICustomerApproveKeyShopListDtoPagingResultApiResultObject {
    result?: CustomerApproveKeyShopListDtoPagingResult;
    success?: boolean;

    constructor(data?: ICustomerApproveKeyShopListDtoPagingResultApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? CustomerApproveKeyShopListDtoPagingResult.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): CustomerApproveKeyShopListDtoPagingResultApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerApproveKeyShopListDtoPagingResultApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data;
    }

    clone(): CustomerApproveKeyShopListDtoPagingResultApiResultObject {
        const json = this.toJSON();
        let result = new CustomerApproveKeyShopListDtoPagingResultApiResultObject();
        result.init(json);
        return result;
    }
}

export interface ICustomerApproveKeyShopListDtoPagingResultApiResultObject {
    result?: CustomerApproveKeyShopListDtoPagingResult;
    success?: boolean;
}

export class CustomerByStaffListDto implements ICustomerByStaffListDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    branchId?: number | undefined;
    contactName?: string | undefined;
    mobilePhone?: string | undefined;
    phone?: string | undefined;
    email?: string | undefined;
    channelCode?: string | undefined;
    channelName?: string | undefined;
    houseNumber?: string | undefined;
    street?: string | undefined;
    address?: string | undefined;
    wardId?: number | undefined;
    districtId?: number | undefined;
    provinceId?: number | undefined;
    isActive?: boolean;
    lat?: number;
    lng?: number;
    birthday?: Date | undefined;
    userId?: number | undefined;
    isKeyShop?: boolean;
    isAllowKeyShopRegister?: boolean;
    keyShopStatus?: number;
    keyShopAuthCode?: string | undefined;
    salesSupervisorStaffId?: number | undefined;
    areaId?: number | undefined;
    zoneId?: number | undefined;
    efficient?: number | undefined;
    rsmStaffId?: number | undefined;
    asmStaffId?: number | undefined;
    zoneName?: string | undefined;
    areaName?: string | undefined;
    wardName?: string | undefined;
    districtName?: string | undefined;
    provinceName?: string | undefined;
    salesSupervisorStaffCode?: string | undefined;
    salesSupervisorStaffName?: string | undefined;

    constructor(data?: ICustomerByStaffListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.branchId = _data["branchId"];
            this.contactName = _data["contactName"];
            this.mobilePhone = _data["mobilePhone"];
            this.phone = _data["phone"];
            this.email = _data["email"];
            this.channelCode = _data["channelCode"];
            this.channelName = _data["channelName"];
            this.houseNumber = _data["houseNumber"];
            this.street = _data["street"];
            this.address = _data["address"];
            this.wardId = _data["wardId"];
            this.districtId = _data["districtId"];
            this.provinceId = _data["provinceId"];
            this.isActive = _data["isActive"];
            this.lat = _data["lat"];
            this.lng = _data["lng"];
            this.birthday = _data["birthday"] ? new Date(_data["birthday"].toString()) : <any>undefined;
            this.userId = _data["userId"];
            this.isKeyShop = _data["isKeyShop"];
            this.isAllowKeyShopRegister = _data["isAllowKeyShopRegister"];
            this.keyShopStatus = _data["keyShopStatus"];
            this.keyShopAuthCode = _data["keyShopAuthCode"];
            this.salesSupervisorStaffId = _data["salesSupervisorStaffId"];
            this.areaId = _data["areaId"];
            this.zoneId = _data["zoneId"];
            this.efficient = _data["efficient"];
            this.rsmStaffId = _data["rsmStaffId"];
            this.asmStaffId = _data["asmStaffId"];
            this.zoneName = _data["zoneName"];
            this.areaName = _data["areaName"];
            this.wardName = _data["wardName"];
            this.districtName = _data["districtName"];
            this.provinceName = _data["provinceName"];
            this.salesSupervisorStaffCode = _data["salesSupervisorStaffCode"];
            this.salesSupervisorStaffName = _data["salesSupervisorStaffName"];
        }
    }

    static fromJS(data: any): CustomerByStaffListDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerByStaffListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["branchId"] = this.branchId;
        data["contactName"] = this.contactName;
        data["mobilePhone"] = this.mobilePhone;
        data["phone"] = this.phone;
        data["email"] = this.email;
        data["channelCode"] = this.channelCode;
        data["channelName"] = this.channelName;
        data["houseNumber"] = this.houseNumber;
        data["street"] = this.street;
        data["address"] = this.address;
        data["wardId"] = this.wardId;
        data["districtId"] = this.districtId;
        data["provinceId"] = this.provinceId;
        data["isActive"] = this.isActive;
        data["lat"] = this.lat;
        data["lng"] = this.lng;
        data["birthday"] = this.birthday ? this.birthday.toISOString() : <any>undefined;
        data["userId"] = this.userId;
        data["isKeyShop"] = this.isKeyShop;
        data["isAllowKeyShopRegister"] = this.isAllowKeyShopRegister;
        data["keyShopStatus"] = this.keyShopStatus;
        data["keyShopAuthCode"] = this.keyShopAuthCode;
        data["salesSupervisorStaffId"] = this.salesSupervisorStaffId;
        data["areaId"] = this.areaId;
        data["zoneId"] = this.zoneId;
        data["efficient"] = this.efficient;
        data["rsmStaffId"] = this.rsmStaffId;
        data["asmStaffId"] = this.asmStaffId;
        data["zoneName"] = this.zoneName;
        data["areaName"] = this.areaName;
        data["wardName"] = this.wardName;
        data["districtName"] = this.districtName;
        data["provinceName"] = this.provinceName;
        data["salesSupervisorStaffCode"] = this.salesSupervisorStaffCode;
        data["salesSupervisorStaffName"] = this.salesSupervisorStaffName;
        return data;
    }

    clone(): CustomerByStaffListDto {
        const json = this.toJSON();
        let result = new CustomerByStaffListDto();
        result.init(json);
        return result;
    }
}

export interface ICustomerByStaffListDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    branchId?: number | undefined;
    contactName?: string | undefined;
    mobilePhone?: string | undefined;
    phone?: string | undefined;
    email?: string | undefined;
    channelCode?: string | undefined;
    channelName?: string | undefined;
    houseNumber?: string | undefined;
    street?: string | undefined;
    address?: string | undefined;
    wardId?: number | undefined;
    districtId?: number | undefined;
    provinceId?: number | undefined;
    isActive?: boolean;
    lat?: number;
    lng?: number;
    birthday?: Date | undefined;
    userId?: number | undefined;
    isKeyShop?: boolean;
    isAllowKeyShopRegister?: boolean;
    keyShopStatus?: number;
    keyShopAuthCode?: string | undefined;
    salesSupervisorStaffId?: number | undefined;
    areaId?: number | undefined;
    zoneId?: number | undefined;
    efficient?: number | undefined;
    rsmStaffId?: number | undefined;
    asmStaffId?: number | undefined;
    zoneName?: string | undefined;
    areaName?: string | undefined;
    wardName?: string | undefined;
    districtName?: string | undefined;
    provinceName?: string | undefined;
    salesSupervisorStaffCode?: string | undefined;
    salesSupervisorStaffName?: string | undefined;
}

export class CustomerByStaffListDtoPagingResult implements ICustomerByStaffListDtoPagingResult {
    items?: CustomerByStaffListDto[] | undefined;
    totalCount?: number;

    constructor(data?: ICustomerByStaffListDtoPagingResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CustomerByStaffListDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): CustomerByStaffListDtoPagingResult {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerByStaffListDtoPagingResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): CustomerByStaffListDtoPagingResult {
        const json = this.toJSON();
        let result = new CustomerByStaffListDtoPagingResult();
        result.init(json);
        return result;
    }
}

export interface ICustomerByStaffListDtoPagingResult {
    items?: CustomerByStaffListDto[] | undefined;
    totalCount?: number;
}

export class CustomerByStaffListDtoPagingResultApiResultObject implements ICustomerByStaffListDtoPagingResultApiResultObject {
    result?: CustomerByStaffListDtoPagingResult;
    success?: boolean;

    constructor(data?: ICustomerByStaffListDtoPagingResultApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? CustomerByStaffListDtoPagingResult.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): CustomerByStaffListDtoPagingResultApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerByStaffListDtoPagingResultApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data;
    }

    clone(): CustomerByStaffListDtoPagingResultApiResultObject {
        const json = this.toJSON();
        let result = new CustomerByStaffListDtoPagingResultApiResultObject();
        result.init(json);
        return result;
    }
}

export interface ICustomerByStaffListDtoPagingResultApiResultObject {
    result?: CustomerByStaffListDtoPagingResult;
    success?: boolean;
}

export class CustomerCheckOtpCommand implements ICustomerCheckOtpCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: CustomerCheckOtpDto;

    constructor(data?: ICustomerCheckOtpCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? CustomerCheckOtpDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CustomerCheckOtpCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerCheckOtpCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }

    clone(): CustomerCheckOtpCommand {
        const json = this.toJSON();
        let result = new CustomerCheckOtpCommand();
        result.init(json);
        return result;
    }
}

export interface ICustomerCheckOtpCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: CustomerCheckOtpDto;
}

export class CustomerCheckOtpDto implements ICustomerCheckOtpDto {
    mobilePhone?: string | undefined;
    otpCode?: string | undefined;

    constructor(data?: ICustomerCheckOtpDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.mobilePhone = _data["mobilePhone"];
            this.otpCode = _data["otpCode"];
        }
    }

    static fromJS(data: any): CustomerCheckOtpDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerCheckOtpDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mobilePhone"] = this.mobilePhone;
        data["otpCode"] = this.otpCode;
        return data;
    }

    clone(): CustomerCheckOtpDto {
        const json = this.toJSON();
        let result = new CustomerCheckOtpDto();
        result.init(json);
        return result;
    }
}

export interface ICustomerCheckOtpDto {
    mobilePhone?: string | undefined;
    otpCode?: string | undefined;
}

export class CustomerDto implements ICustomerDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    branchId?: number | undefined;
    contactName?: string | undefined;
    mobilePhone?: string | undefined;
    phone?: string | undefined;
    email?: string | undefined;
    channelCode?: string | undefined;
    channelName?: string | undefined;
    houseNumber?: string | undefined;
    street?: string | undefined;
    address?: string | undefined;
    wardId?: number | undefined;
    districtId?: number | undefined;
    provinceId?: number | undefined;
    isActive?: boolean;
    lat?: number;
    lng?: number;
    birthday?: Date | undefined;
    userId?: number | undefined;
    isKeyShop?: boolean;
    isAllowKeyShopRegister?: boolean;
    keyShopStatus?: number;
    keyShopAuthCode?: string | undefined;
    salesSupervisorStaffId?: number | undefined;
    areaId?: number | undefined;
    zoneId?: number | undefined;
    efficient?: number | undefined;
    rsmStaffId?: number | undefined;
    asmStaffId?: number | undefined;

    constructor(data?: ICustomerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.branchId = _data["branchId"];
            this.contactName = _data["contactName"];
            this.mobilePhone = _data["mobilePhone"];
            this.phone = _data["phone"];
            this.email = _data["email"];
            this.channelCode = _data["channelCode"];
            this.channelName = _data["channelName"];
            this.houseNumber = _data["houseNumber"];
            this.street = _data["street"];
            this.address = _data["address"];
            this.wardId = _data["wardId"];
            this.districtId = _data["districtId"];
            this.provinceId = _data["provinceId"];
            this.isActive = _data["isActive"];
            this.lat = _data["lat"];
            this.lng = _data["lng"];
            this.birthday = _data["birthday"] ? new Date(_data["birthday"].toString()) : <any>undefined;
            this.userId = _data["userId"];
            this.isKeyShop = _data["isKeyShop"];
            this.isAllowKeyShopRegister = _data["isAllowKeyShopRegister"];
            this.keyShopStatus = _data["keyShopStatus"];
            this.keyShopAuthCode = _data["keyShopAuthCode"];
            this.salesSupervisorStaffId = _data["salesSupervisorStaffId"];
            this.areaId = _data["areaId"];
            this.zoneId = _data["zoneId"];
            this.efficient = _data["efficient"];
            this.rsmStaffId = _data["rsmStaffId"];
            this.asmStaffId = _data["asmStaffId"];
        }
    }

    static fromJS(data: any): CustomerDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["branchId"] = this.branchId;
        data["contactName"] = this.contactName;
        data["mobilePhone"] = this.mobilePhone;
        data["phone"] = this.phone;
        data["email"] = this.email;
        data["channelCode"] = this.channelCode;
        data["channelName"] = this.channelName;
        data["houseNumber"] = this.houseNumber;
        data["street"] = this.street;
        data["address"] = this.address;
        data["wardId"] = this.wardId;
        data["districtId"] = this.districtId;
        data["provinceId"] = this.provinceId;
        data["isActive"] = this.isActive;
        data["lat"] = this.lat;
        data["lng"] = this.lng;
        data["birthday"] = this.birthday ? this.birthday.toISOString() : <any>undefined;
        data["userId"] = this.userId;
        data["isKeyShop"] = this.isKeyShop;
        data["isAllowKeyShopRegister"] = this.isAllowKeyShopRegister;
        data["keyShopStatus"] = this.keyShopStatus;
        data["keyShopAuthCode"] = this.keyShopAuthCode;
        data["salesSupervisorStaffId"] = this.salesSupervisorStaffId;
        data["areaId"] = this.areaId;
        data["zoneId"] = this.zoneId;
        data["efficient"] = this.efficient;
        data["rsmStaffId"] = this.rsmStaffId;
        data["asmStaffId"] = this.asmStaffId;
        return data;
    }

    clone(): CustomerDto {
        const json = this.toJSON();
        let result = new CustomerDto();
        result.init(json);
        return result;
    }
}

export interface ICustomerDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    branchId?: number | undefined;
    contactName?: string | undefined;
    mobilePhone?: string | undefined;
    phone?: string | undefined;
    email?: string | undefined;
    channelCode?: string | undefined;
    channelName?: string | undefined;
    houseNumber?: string | undefined;
    street?: string | undefined;
    address?: string | undefined;
    wardId?: number | undefined;
    districtId?: number | undefined;
    provinceId?: number | undefined;
    isActive?: boolean;
    lat?: number;
    lng?: number;
    birthday?: Date | undefined;
    userId?: number | undefined;
    isKeyShop?: boolean;
    isAllowKeyShopRegister?: boolean;
    keyShopStatus?: number;
    keyShopAuthCode?: string | undefined;
    salesSupervisorStaffId?: number | undefined;
    areaId?: number | undefined;
    zoneId?: number | undefined;
    efficient?: number | undefined;
    rsmStaffId?: number | undefined;
    asmStaffId?: number | undefined;
}

export class CustomerDtoApiResultObject implements ICustomerDtoApiResultObject {
    result?: CustomerDto;
    success?: boolean;

    constructor(data?: ICustomerDtoApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? CustomerDto.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): CustomerDtoApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerDtoApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data;
    }

    clone(): CustomerDtoApiResultObject {
        const json = this.toJSON();
        let result = new CustomerDtoApiResultObject();
        result.init(json);
        return result;
    }
}

export interface ICustomerDtoApiResultObject {
    result?: CustomerDto;
    success?: boolean;
}

export class CustomerDtoPagingResult implements ICustomerDtoPagingResult {
    items?: CustomerDto[] | undefined;
    totalCount?: number;

    constructor(data?: ICustomerDtoPagingResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CustomerDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): CustomerDtoPagingResult {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerDtoPagingResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): CustomerDtoPagingResult {
        const json = this.toJSON();
        let result = new CustomerDtoPagingResult();
        result.init(json);
        return result;
    }
}

export interface ICustomerDtoPagingResult {
    items?: CustomerDto[] | undefined;
    totalCount?: number;
}

export class CustomerDtoPagingResultApiResultObject implements ICustomerDtoPagingResultApiResultObject {
    result?: CustomerDtoPagingResult;
    success?: boolean;

    constructor(data?: ICustomerDtoPagingResultApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? CustomerDtoPagingResult.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): CustomerDtoPagingResultApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerDtoPagingResultApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data;
    }

    clone(): CustomerDtoPagingResultApiResultObject {
        const json = this.toJSON();
        let result = new CustomerDtoPagingResultApiResultObject();
        result.init(json);
        return result;
    }
}

export interface ICustomerDtoPagingResultApiResultObject {
    result?: CustomerDtoPagingResult;
    success?: boolean;
}

export class CustomerLocationDto implements ICustomerLocationDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    isActive?: boolean;

    constructor(data?: ICustomerLocationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CustomerLocationDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerLocationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): CustomerLocationDto {
        const json = this.toJSON();
        let result = new CustomerLocationDto();
        result.init(json);
        return result;
    }
}

export interface ICustomerLocationDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    isActive?: boolean;
}

export class CustomerLocationDtoApiResultObject implements ICustomerLocationDtoApiResultObject {
    result?: CustomerLocationDto;
    success?: boolean;

    constructor(data?: ICustomerLocationDtoApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? CustomerLocationDto.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): CustomerLocationDtoApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerLocationDtoApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data;
    }

    clone(): CustomerLocationDtoApiResultObject {
        const json = this.toJSON();
        let result = new CustomerLocationDtoApiResultObject();
        result.init(json);
        return result;
    }
}

export interface ICustomerLocationDtoApiResultObject {
    result?: CustomerLocationDto;
    success?: boolean;
}

export class CustomerLocationDtoPagingResult implements ICustomerLocationDtoPagingResult {
    items?: CustomerLocationDto[] | undefined;
    totalCount?: number;

    constructor(data?: ICustomerLocationDtoPagingResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CustomerLocationDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): CustomerLocationDtoPagingResult {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerLocationDtoPagingResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): CustomerLocationDtoPagingResult {
        const json = this.toJSON();
        let result = new CustomerLocationDtoPagingResult();
        result.init(json);
        return result;
    }
}

export interface ICustomerLocationDtoPagingResult {
    items?: CustomerLocationDto[] | undefined;
    totalCount?: number;
}

export class CustomerLocationDtoPagingResultApiResultObject implements ICustomerLocationDtoPagingResultApiResultObject {
    result?: CustomerLocationDtoPagingResult;
    success?: boolean;

    constructor(data?: ICustomerLocationDtoPagingResultApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? CustomerLocationDtoPagingResult.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): CustomerLocationDtoPagingResultApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerLocationDtoPagingResultApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data;
    }

    clone(): CustomerLocationDtoPagingResultApiResultObject {
        const json = this.toJSON();
        let result = new CustomerLocationDtoPagingResultApiResultObject();
        result.init(json);
        return result;
    }
}

export interface ICustomerLocationDtoPagingResultApiResultObject {
    result?: CustomerLocationDtoPagingResult;
    success?: boolean;
}

export class CustomerLocationUpsertCommand implements ICustomerLocationUpsertCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: CustomerLocationUpsertDto;
    readonly handleType?: string | undefined;

    constructor(data?: ICustomerLocationUpsertCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? CustomerLocationUpsertDto.fromJS(_data["data"]) : <any>undefined;
            (<any>this).handleType = _data["handleType"];
        }
    }

    static fromJS(data: any): CustomerLocationUpsertCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerLocationUpsertCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["handleType"] = this.handleType;
        return data;
    }

    clone(): CustomerLocationUpsertCommand {
        const json = this.toJSON();
        let result = new CustomerLocationUpsertCommand();
        result.init(json);
        return result;
    }
}

export interface ICustomerLocationUpsertCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: CustomerLocationUpsertDto;
    handleType?: string | undefined;
}

export class CustomerLocationUpsertDto implements ICustomerLocationUpsertDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    isActive?: boolean;

    constructor(data?: ICustomerLocationUpsertDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CustomerLocationUpsertDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerLocationUpsertDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): CustomerLocationUpsertDto {
        const json = this.toJSON();
        let result = new CustomerLocationUpsertDto();
        result.init(json);
        return result;
    }
}

export interface ICustomerLocationUpsertDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    isActive?: boolean;
}

export class CustomerRecentSalesDto implements ICustomerRecentSalesDto {
    monthData?: MonthData[] | undefined;
    yearData?: YearData[] | undefined;

    constructor(data?: ICustomerRecentSalesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["monthData"])) {
                this.monthData = [] as any;
                for (let item of _data["monthData"])
                    this.monthData!.push(MonthData.fromJS(item));
            }
            if (Array.isArray(_data["yearData"])) {
                this.yearData = [] as any;
                for (let item of _data["yearData"])
                    this.yearData!.push(YearData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CustomerRecentSalesDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerRecentSalesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.monthData)) {
            data["monthData"] = [];
            for (let item of this.monthData)
                data["monthData"].push(item.toJSON());
        }
        if (Array.isArray(this.yearData)) {
            data["yearData"] = [];
            for (let item of this.yearData)
                data["yearData"].push(item.toJSON());
        }
        return data;
    }

    clone(): CustomerRecentSalesDto {
        const json = this.toJSON();
        let result = new CustomerRecentSalesDto();
        result.init(json);
        return result;
    }
}

export interface ICustomerRecentSalesDto {
    monthData?: MonthData[] | undefined;
    yearData?: YearData[] | undefined;
}

export class CustomerRecentSalesDtoApiResultObject implements ICustomerRecentSalesDtoApiResultObject {
    result?: CustomerRecentSalesDto;
    success?: boolean;

    constructor(data?: ICustomerRecentSalesDtoApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? CustomerRecentSalesDto.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): CustomerRecentSalesDtoApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerRecentSalesDtoApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data;
    }

    clone(): CustomerRecentSalesDtoApiResultObject {
        const json = this.toJSON();
        let result = new CustomerRecentSalesDtoApiResultObject();
        result.init(json);
        return result;
    }
}

export interface ICustomerRecentSalesDtoApiResultObject {
    result?: CustomerRecentSalesDto;
    success?: boolean;
}

export class CustomerRefuseKeyShopCommand implements ICustomerRefuseKeyShopCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: number[] | undefined;

    constructor(data?: ICustomerRefuseKeyShopCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(item);
            }
        }
    }

    static fromJS(data: any): CustomerRefuseKeyShopCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerRefuseKeyShopCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item);
        }
        return data;
    }

    clone(): CustomerRefuseKeyShopCommand {
        const json = this.toJSON();
        let result = new CustomerRefuseKeyShopCommand();
        result.init(json);
        return result;
    }
}

export interface ICustomerRefuseKeyShopCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: number[] | undefined;
}

export class CustomerRegisterCommand implements ICustomerRegisterCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: CustomerRegisterDto;

    constructor(data?: ICustomerRegisterCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? CustomerRegisterDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CustomerRegisterCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerRegisterCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }

    clone(): CustomerRegisterCommand {
        const json = this.toJSON();
        let result = new CustomerRegisterCommand();
        result.init(json);
        return result;
    }
}

export interface ICustomerRegisterCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: CustomerRegisterDto;
}

export class CustomerRegisterDto implements ICustomerRegisterDto {
    userName?: string | undefined;
    fullName?: string | undefined;
    phone?: string | undefined;
    password?: string | undefined;
    email?: string | undefined;

    constructor(data?: ICustomerRegisterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.fullName = _data["fullName"];
            this.phone = _data["phone"];
            this.password = _data["password"];
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): CustomerRegisterDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerRegisterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["fullName"] = this.fullName;
        data["phone"] = this.phone;
        data["password"] = this.password;
        data["email"] = this.email;
        return data;
    }

    clone(): CustomerRegisterDto {
        const json = this.toJSON();
        let result = new CustomerRegisterDto();
        result.init(json);
        return result;
    }
}

export interface ICustomerRegisterDto {
    userName?: string | undefined;
    fullName?: string | undefined;
    phone?: string | undefined;
    password?: string | undefined;
    email?: string | undefined;
}

export class CustomerRegisterKeyShopCommand implements ICustomerRegisterKeyShopCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: number[] | undefined;

    constructor(data?: ICustomerRegisterKeyShopCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(item);
            }
        }
    }

    static fromJS(data: any): CustomerRegisterKeyShopCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerRegisterKeyShopCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item);
        }
        return data;
    }

    clone(): CustomerRegisterKeyShopCommand {
        const json = this.toJSON();
        let result = new CustomerRegisterKeyShopCommand();
        result.init(json);
        return result;
    }
}

export interface ICustomerRegisterKeyShopCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: number[] | undefined;
}

export class CustomerResetPasswordCommand implements ICustomerResetPasswordCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: CustomerResetPasswordDto;

    constructor(data?: ICustomerResetPasswordCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? CustomerResetPasswordDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CustomerResetPasswordCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerResetPasswordCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }

    clone(): CustomerResetPasswordCommand {
        const json = this.toJSON();
        let result = new CustomerResetPasswordCommand();
        result.init(json);
        return result;
    }
}

export interface ICustomerResetPasswordCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: CustomerResetPasswordDto;
}

export class CustomerResetPasswordDto implements ICustomerResetPasswordDto {
    newPassword?: string | undefined;
    mobilePhone?: string | undefined;
    otpCode?: string | undefined;

    constructor(data?: ICustomerResetPasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.newPassword = _data["newPassword"];
            this.mobilePhone = _data["mobilePhone"];
            this.otpCode = _data["otpCode"];
        }
    }

    static fromJS(data: any): CustomerResetPasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerResetPasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["newPassword"] = this.newPassword;
        data["mobilePhone"] = this.mobilePhone;
        data["otpCode"] = this.otpCode;
        return data;
    }

    clone(): CustomerResetPasswordDto {
        const json = this.toJSON();
        let result = new CustomerResetPasswordDto();
        result.init(json);
        return result;
    }
}

export interface ICustomerResetPasswordDto {
    newPassword?: string | undefined;
    mobilePhone?: string | undefined;
    otpCode?: string | undefined;
}

export class CustomerSalesItemCreateCommand implements ICustomerSalesItemCreateCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: CustomerSalesItemCreateDto;

    constructor(data?: ICustomerSalesItemCreateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? CustomerSalesItemCreateDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CustomerSalesItemCreateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerSalesItemCreateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }

    clone(): CustomerSalesItemCreateCommand {
        const json = this.toJSON();
        let result = new CustomerSalesItemCreateCommand();
        result.init(json);
        return result;
    }
}

export interface ICustomerSalesItemCreateCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: CustomerSalesItemCreateDto;
}

export class CustomerSalesItemCreateDto implements ICustomerSalesItemCreateDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    qrCode?: string | undefined;

    constructor(data?: ICustomerSalesItemCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.qrCode = _data["qrCode"];
        }
    }

    static fromJS(data: any): CustomerSalesItemCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerSalesItemCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["qrCode"] = this.qrCode;
        return data;
    }

    clone(): CustomerSalesItemCreateDto {
        const json = this.toJSON();
        let result = new CustomerSalesItemCreateDto();
        result.init(json);
        return result;
    }
}

export interface ICustomerSalesItemCreateDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    qrCode?: string | undefined;
}

export class CustomerValidateActivationKeyShopCommand implements ICustomerValidateActivationKeyShopCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: CustomerValidateActivationKeyShopDto;

    constructor(data?: ICustomerValidateActivationKeyShopCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? CustomerValidateActivationKeyShopDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CustomerValidateActivationKeyShopCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerValidateActivationKeyShopCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }

    clone(): CustomerValidateActivationKeyShopCommand {
        const json = this.toJSON();
        let result = new CustomerValidateActivationKeyShopCommand();
        result.init(json);
        return result;
    }
}

export interface ICustomerValidateActivationKeyShopCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: CustomerValidateActivationKeyShopDto;
}

export class CustomerValidateActivationKeyShopDto implements ICustomerValidateActivationKeyShopDto {
    code?: string | undefined;
    name?: string | undefined;
    authCode?: string | undefined;
    mobilePhone?: string | undefined;
    birthday?: Date;

    constructor(data?: ICustomerValidateActivationKeyShopDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.name = _data["name"];
            this.authCode = _data["authCode"];
            this.mobilePhone = _data["mobilePhone"];
            this.birthday = _data["birthday"] ? new Date(_data["birthday"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CustomerValidateActivationKeyShopDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerValidateActivationKeyShopDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["authCode"] = this.authCode;
        data["mobilePhone"] = this.mobilePhone;
        data["birthday"] = this.birthday ? this.birthday.toISOString() : <any>undefined;
        return data;
    }

    clone(): CustomerValidateActivationKeyShopDto {
        const json = this.toJSON();
        let result = new CustomerValidateActivationKeyShopDto();
        result.init(json);
        return result;
    }
}

export interface ICustomerValidateActivationKeyShopDto {
    code?: string | undefined;
    name?: string | undefined;
    authCode?: string | undefined;
    mobilePhone?: string | undefined;
    birthday?: Date;
}

export class CustomerValidateRecoveryPasswordCommand implements ICustomerValidateRecoveryPasswordCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: CustomerValidateRecoveryPasswordDto;

    constructor(data?: ICustomerValidateRecoveryPasswordCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? CustomerValidateRecoveryPasswordDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CustomerValidateRecoveryPasswordCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerValidateRecoveryPasswordCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }

    clone(): CustomerValidateRecoveryPasswordCommand {
        const json = this.toJSON();
        let result = new CustomerValidateRecoveryPasswordCommand();
        result.init(json);
        return result;
    }
}

export interface ICustomerValidateRecoveryPasswordCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: CustomerValidateRecoveryPasswordDto;
}

export class CustomerValidateRecoveryPasswordDto implements ICustomerValidateRecoveryPasswordDto {
    mobilePhone?: string | undefined;

    constructor(data?: ICustomerValidateRecoveryPasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.mobilePhone = _data["mobilePhone"];
        }
    }

    static fromJS(data: any): CustomerValidateRecoveryPasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerValidateRecoveryPasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mobilePhone"] = this.mobilePhone;
        return data;
    }

    clone(): CustomerValidateRecoveryPasswordDto {
        const json = this.toJSON();
        let result = new CustomerValidateRecoveryPasswordDto();
        result.init(json);
        return result;
    }
}

export interface ICustomerValidateRecoveryPasswordDto {
    mobilePhone?: string | undefined;
}

export class CycleDto implements ICycleDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    number?: string | undefined;
    year?: number;
    isActive?: boolean;
    fromDate?: Date;
    toDate?: Date;

    constructor(data?: ICycleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.number = _data["number"];
            this.year = _data["year"];
            this.isActive = _data["isActive"];
            this.fromDate = _data["fromDate"] ? new Date(_data["fromDate"].toString()) : <any>undefined;
            this.toDate = _data["toDate"] ? new Date(_data["toDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CycleDto {
        data = typeof data === 'object' ? data : {};
        let result = new CycleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["number"] = this.number;
        data["year"] = this.year;
        data["isActive"] = this.isActive;
        data["fromDate"] = this.fromDate ? this.fromDate.toISOString() : <any>undefined;
        data["toDate"] = this.toDate ? this.toDate.toISOString() : <any>undefined;
        return data;
    }

    clone(): CycleDto {
        const json = this.toJSON();
        let result = new CycleDto();
        result.init(json);
        return result;
    }
}

export interface ICycleDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    number?: string | undefined;
    year?: number;
    isActive?: boolean;
    fromDate?: Date;
    toDate?: Date;
}

export class CycleDtoApiResultObject implements ICycleDtoApiResultObject {
    result?: CycleDto;
    success?: boolean;

    constructor(data?: ICycleDtoApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? CycleDto.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): CycleDtoApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new CycleDtoApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data;
    }

    clone(): CycleDtoApiResultObject {
        const json = this.toJSON();
        let result = new CycleDtoApiResultObject();
        result.init(json);
        return result;
    }
}

export interface ICycleDtoApiResultObject {
    result?: CycleDto;
    success?: boolean;
}

export class CycleDtoPagingResult implements ICycleDtoPagingResult {
    items?: CycleDto[] | undefined;
    totalCount?: number;

    constructor(data?: ICycleDtoPagingResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CycleDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): CycleDtoPagingResult {
        data = typeof data === 'object' ? data : {};
        let result = new CycleDtoPagingResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): CycleDtoPagingResult {
        const json = this.toJSON();
        let result = new CycleDtoPagingResult();
        result.init(json);
        return result;
    }
}

export interface ICycleDtoPagingResult {
    items?: CycleDto[] | undefined;
    totalCount?: number;
}

export class CycleDtoPagingResultApiResultObject implements ICycleDtoPagingResultApiResultObject {
    result?: CycleDtoPagingResult;
    success?: boolean;

    constructor(data?: ICycleDtoPagingResultApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? CycleDtoPagingResult.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): CycleDtoPagingResultApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new CycleDtoPagingResultApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data;
    }

    clone(): CycleDtoPagingResultApiResultObject {
        const json = this.toJSON();
        let result = new CycleDtoPagingResultApiResultObject();
        result.init(json);
        return result;
    }
}

export interface ICycleDtoPagingResultApiResultObject {
    result?: CycleDtoPagingResult;
    success?: boolean;
}

export class DistrictDto implements IDistrictDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    provinceId?: number;

    constructor(data?: IDistrictDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.provinceId = _data["provinceId"];
        }
    }

    static fromJS(data: any): DistrictDto {
        data = typeof data === 'object' ? data : {};
        let result = new DistrictDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["provinceId"] = this.provinceId;
        return data;
    }

    clone(): DistrictDto {
        const json = this.toJSON();
        let result = new DistrictDto();
        result.init(json);
        return result;
    }
}

export interface IDistrictDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    provinceId?: number;
}

export class DistrictDtoApiResultObject implements IDistrictDtoApiResultObject {
    result?: DistrictDto;
    success?: boolean;

    constructor(data?: IDistrictDtoApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? DistrictDto.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): DistrictDtoApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new DistrictDtoApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data;
    }

    clone(): DistrictDtoApiResultObject {
        const json = this.toJSON();
        let result = new DistrictDtoApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IDistrictDtoApiResultObject {
    result?: DistrictDto;
    success?: boolean;
}

export class DistrictListDto implements IDistrictListDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    provinceCode?: string | undefined;
    provinceName?: string | undefined;
    provinceId?: number;

    constructor(data?: IDistrictListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.provinceCode = _data["provinceCode"];
            this.provinceName = _data["provinceName"];
            this.provinceId = _data["provinceId"];
        }
    }

    static fromJS(data: any): DistrictListDto {
        data = typeof data === 'object' ? data : {};
        let result = new DistrictListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["provinceCode"] = this.provinceCode;
        data["provinceName"] = this.provinceName;
        data["provinceId"] = this.provinceId;
        return data;
    }

    clone(): DistrictListDto {
        const json = this.toJSON();
        let result = new DistrictListDto();
        result.init(json);
        return result;
    }
}

export interface IDistrictListDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    provinceCode?: string | undefined;
    provinceName?: string | undefined;
    provinceId?: number;
}

export class DistrictListDtoPagingResult implements IDistrictListDtoPagingResult {
    items?: DistrictListDto[] | undefined;
    totalCount?: number;

    constructor(data?: IDistrictListDtoPagingResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(DistrictListDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): DistrictListDtoPagingResult {
        data = typeof data === 'object' ? data : {};
        let result = new DistrictListDtoPagingResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): DistrictListDtoPagingResult {
        const json = this.toJSON();
        let result = new DistrictListDtoPagingResult();
        result.init(json);
        return result;
    }
}

export interface IDistrictListDtoPagingResult {
    items?: DistrictListDto[] | undefined;
    totalCount?: number;
}

export class DistrictListDtoPagingResultApiResultObject implements IDistrictListDtoPagingResultApiResultObject {
    result?: DistrictListDtoPagingResult;
    success?: boolean;

    constructor(data?: IDistrictListDtoPagingResultApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? DistrictListDtoPagingResult.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): DistrictListDtoPagingResultApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new DistrictListDtoPagingResultApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data;
    }

    clone(): DistrictListDtoPagingResultApiResultObject {
        const json = this.toJSON();
        let result = new DistrictListDtoPagingResultApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IDistrictListDtoPagingResultApiResultObject {
    result?: DistrictListDtoPagingResult;
    success?: boolean;
}

export class Int32ApiResultObject implements IInt32ApiResultObject {
    result?: number;
    success?: boolean;

    constructor(data?: IInt32ApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"];
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): Int32ApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new Int32ApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result;
        data["success"] = this.success;
        return data;
    }

    clone(): Int32ApiResultObject {
        const json = this.toJSON();
        let result = new Int32ApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IInt32ApiResultObject {
    result?: number;
    success?: boolean;
}

export class InvestmentAccumulateDto implements IInvestmentAccumulateDto {
    holdingQuantity?: number;
    approvedQuantity?: number;
    requestQuantity?: number;

    constructor(data?: IInvestmentAccumulateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.holdingQuantity = _data["holdingQuantity"];
            this.approvedQuantity = _data["approvedQuantity"];
            this.requestQuantity = _data["requestQuantity"];
        }
    }

    static fromJS(data: any): InvestmentAccumulateDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvestmentAccumulateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["holdingQuantity"] = this.holdingQuantity;
        data["approvedQuantity"] = this.approvedQuantity;
        data["requestQuantity"] = this.requestQuantity;
        return data;
    }

    clone(): InvestmentAccumulateDto {
        const json = this.toJSON();
        let result = new InvestmentAccumulateDto();
        result.init(json);
        return result;
    }
}

export interface IInvestmentAccumulateDto {
    holdingQuantity?: number;
    approvedQuantity?: number;
    requestQuantity?: number;
}

export class InvestmentBranchSettingDto implements IInvestmentBranchSettingDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    isSelected?: boolean;
    isEditablePoint?: boolean;
    branchId?: number;
    branchCode?: string | undefined;
    branchName?: string | undefined;
    zoneId?: number | undefined;
    zoneName?: string | undefined;
    areaId?: number | undefined;
    areaName?: string | undefined;

    constructor(data?: IInvestmentBranchSettingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isSelected = _data["isSelected"];
            this.isEditablePoint = _data["isEditablePoint"];
            this.branchId = _data["branchId"];
            this.branchCode = _data["branchCode"];
            this.branchName = _data["branchName"];
            this.zoneId = _data["zoneId"];
            this.zoneName = _data["zoneName"];
            this.areaId = _data["areaId"];
            this.areaName = _data["areaName"];
        }
    }

    static fromJS(data: any): InvestmentBranchSettingDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvestmentBranchSettingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isSelected"] = this.isSelected;
        data["isEditablePoint"] = this.isEditablePoint;
        data["branchId"] = this.branchId;
        data["branchCode"] = this.branchCode;
        data["branchName"] = this.branchName;
        data["zoneId"] = this.zoneId;
        data["zoneName"] = this.zoneName;
        data["areaId"] = this.areaId;
        data["areaName"] = this.areaName;
        return data;
    }

    clone(): InvestmentBranchSettingDto {
        const json = this.toJSON();
        let result = new InvestmentBranchSettingDto();
        result.init(json);
        return result;
    }
}

export interface IInvestmentBranchSettingDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    isSelected?: boolean;
    isEditablePoint?: boolean;
    branchId?: number;
    branchCode?: string | undefined;
    branchName?: string | undefined;
    zoneId?: number | undefined;
    zoneName?: string | undefined;
    areaId?: number | undefined;
    areaName?: string | undefined;
}

export class InvestmentCustomerSettingDto implements IInvestmentCustomerSettingDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    enableCreateTicketFromShop?: boolean;
    maxInvestAmount?: number;
    amountPerPoint?: number;
    maxInvestmentQueryMonths?: number;
    defaultPointsForTicket?: number;
    isPointEditable?: boolean;
    beginIssueDaysAfterCurrent?: number;
    endIssueDaysBeforeOperation?: number;

    constructor(data?: IInvestmentCustomerSettingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.enableCreateTicketFromShop = _data["enableCreateTicketFromShop"];
            this.maxInvestAmount = _data["maxInvestAmount"];
            this.amountPerPoint = _data["amountPerPoint"];
            this.maxInvestmentQueryMonths = _data["maxInvestmentQueryMonths"];
            this.defaultPointsForTicket = _data["defaultPointsForTicket"];
            this.isPointEditable = _data["isPointEditable"];
            this.beginIssueDaysAfterCurrent = _data["beginIssueDaysAfterCurrent"];
            this.endIssueDaysBeforeOperation = _data["endIssueDaysBeforeOperation"];
        }
    }

    static fromJS(data: any): InvestmentCustomerSettingDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvestmentCustomerSettingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["enableCreateTicketFromShop"] = this.enableCreateTicketFromShop;
        data["maxInvestAmount"] = this.maxInvestAmount;
        data["amountPerPoint"] = this.amountPerPoint;
        data["maxInvestmentQueryMonths"] = this.maxInvestmentQueryMonths;
        data["defaultPointsForTicket"] = this.defaultPointsForTicket;
        data["isPointEditable"] = this.isPointEditable;
        data["beginIssueDaysAfterCurrent"] = this.beginIssueDaysAfterCurrent;
        data["endIssueDaysBeforeOperation"] = this.endIssueDaysBeforeOperation;
        return data;
    }

    clone(): InvestmentCustomerSettingDto {
        const json = this.toJSON();
        let result = new InvestmentCustomerSettingDto();
        result.init(json);
        return result;
    }
}

export interface IInvestmentCustomerSettingDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    enableCreateTicketFromShop?: boolean;
    maxInvestAmount?: number;
    amountPerPoint?: number;
    maxInvestmentQueryMonths?: number;
    defaultPointsForTicket?: number;
    isPointEditable?: boolean;
    beginIssueDaysAfterCurrent?: number;
    endIssueDaysBeforeOperation?: number;
}

export class InvestmentCustomerSettingDtoApiResultObject implements IInvestmentCustomerSettingDtoApiResultObject {
    result?: InvestmentCustomerSettingDto;
    success?: boolean;

    constructor(data?: IInvestmentCustomerSettingDtoApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? InvestmentCustomerSettingDto.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): InvestmentCustomerSettingDtoApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new InvestmentCustomerSettingDtoApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data;
    }

    clone(): InvestmentCustomerSettingDtoApiResultObject {
        const json = this.toJSON();
        let result = new InvestmentCustomerSettingDtoApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IInvestmentCustomerSettingDtoApiResultObject {
    result?: InvestmentCustomerSettingDto;
    success?: boolean;
}

export class InvestmentDto implements IInvestmentDto {
    ticket?: InvestmentAccumulateDto;
    posm?: InvestmentAccumulateDto;
    pg?: InvestmentAccumulateDto;
    goldHour?: InvestmentAccumulateDto;

    constructor(data?: IInvestmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ticket = _data["ticket"] ? InvestmentAccumulateDto.fromJS(_data["ticket"]) : <any>undefined;
            this.posm = _data["posm"] ? InvestmentAccumulateDto.fromJS(_data["posm"]) : <any>undefined;
            this.pg = _data["pg"] ? InvestmentAccumulateDto.fromJS(_data["pg"]) : <any>undefined;
            this.goldHour = _data["goldHour"] ? InvestmentAccumulateDto.fromJS(_data["goldHour"]) : <any>undefined;
        }
    }

    static fromJS(data: any): InvestmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvestmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ticket"] = this.ticket ? this.ticket.toJSON() : <any>undefined;
        data["posm"] = this.posm ? this.posm.toJSON() : <any>undefined;
        data["pg"] = this.pg ? this.pg.toJSON() : <any>undefined;
        data["goldHour"] = this.goldHour ? this.goldHour.toJSON() : <any>undefined;
        return data;
    }

    clone(): InvestmentDto {
        const json = this.toJSON();
        let result = new InvestmentDto();
        result.init(json);
        return result;
    }
}

export interface IInvestmentDto {
    ticket?: InvestmentAccumulateDto;
    posm?: InvestmentAccumulateDto;
    pg?: InvestmentAccumulateDto;
    goldHour?: InvestmentAccumulateDto;
}

export class InvestmentDtoApiResultObject implements IInvestmentDtoApiResultObject {
    result?: InvestmentDto;
    success?: boolean;

    constructor(data?: IInvestmentDtoApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? InvestmentDto.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): InvestmentDtoApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new InvestmentDtoApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data;
    }

    clone(): InvestmentDtoApiResultObject {
        const json = this.toJSON();
        let result = new InvestmentDtoApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IInvestmentDtoApiResultObject {
    result?: InvestmentDto;
    success?: boolean;
}

export class InvestmentSettingDto implements IInvestmentSettingDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    maxInvestAmount?: number;
    amountPerPoint?: number;
    maxInvestmentQueryMonths?: number;
    defaultPointsForTicket?: number;
    checkQrCodeBranch?: boolean;
    beginIssueDaysAfterCurrent?: number;
    endIssueDaysBeforeOperation?: number;
    investmentSettingBranchs?: InvestmentBranchSettingDto[] | undefined;

    constructor(data?: IInvestmentSettingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.maxInvestAmount = _data["maxInvestAmount"];
            this.amountPerPoint = _data["amountPerPoint"];
            this.maxInvestmentQueryMonths = _data["maxInvestmentQueryMonths"];
            this.defaultPointsForTicket = _data["defaultPointsForTicket"];
            this.checkQrCodeBranch = _data["checkQrCodeBranch"];
            this.beginIssueDaysAfterCurrent = _data["beginIssueDaysAfterCurrent"];
            this.endIssueDaysBeforeOperation = _data["endIssueDaysBeforeOperation"];
            if (Array.isArray(_data["investmentSettingBranchs"])) {
                this.investmentSettingBranchs = [] as any;
                for (let item of _data["investmentSettingBranchs"])
                    this.investmentSettingBranchs!.push(InvestmentBranchSettingDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): InvestmentSettingDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvestmentSettingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["maxInvestAmount"] = this.maxInvestAmount;
        data["amountPerPoint"] = this.amountPerPoint;
        data["maxInvestmentQueryMonths"] = this.maxInvestmentQueryMonths;
        data["defaultPointsForTicket"] = this.defaultPointsForTicket;
        data["checkQrCodeBranch"] = this.checkQrCodeBranch;
        data["beginIssueDaysAfterCurrent"] = this.beginIssueDaysAfterCurrent;
        data["endIssueDaysBeforeOperation"] = this.endIssueDaysBeforeOperation;
        if (Array.isArray(this.investmentSettingBranchs)) {
            data["investmentSettingBranchs"] = [];
            for (let item of this.investmentSettingBranchs)
                data["investmentSettingBranchs"].push(item.toJSON());
        }
        return data;
    }

    clone(): InvestmentSettingDto {
        const json = this.toJSON();
        let result = new InvestmentSettingDto();
        result.init(json);
        return result;
    }
}

export interface IInvestmentSettingDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    maxInvestAmount?: number;
    amountPerPoint?: number;
    maxInvestmentQueryMonths?: number;
    defaultPointsForTicket?: number;
    checkQrCodeBranch?: boolean;
    beginIssueDaysAfterCurrent?: number;
    endIssueDaysBeforeOperation?: number;
    investmentSettingBranchs?: InvestmentBranchSettingDto[] | undefined;
}

export class InvestmentSettingDtoApiResultObject implements IInvestmentSettingDtoApiResultObject {
    result?: InvestmentSettingDto;
    success?: boolean;

    constructor(data?: IInvestmentSettingDtoApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? InvestmentSettingDto.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): InvestmentSettingDtoApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new InvestmentSettingDtoApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data;
    }

    clone(): InvestmentSettingDtoApiResultObject {
        const json = this.toJSON();
        let result = new InvestmentSettingDtoApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IInvestmentSettingDtoApiResultObject {
    result?: InvestmentSettingDto;
    success?: boolean;
}

export class MaterialDto implements IMaterialDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    materialTypeId?: number;
    description?: string | undefined;
    value?: number;
    isActive?: boolean;
    isDesign?: boolean;

    constructor(data?: IMaterialDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.materialTypeId = _data["materialTypeId"];
            this.description = _data["description"];
            this.value = _data["value"];
            this.isActive = _data["isActive"];
            this.isDesign = _data["isDesign"];
        }
    }

    static fromJS(data: any): MaterialDto {
        data = typeof data === 'object' ? data : {};
        let result = new MaterialDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["materialTypeId"] = this.materialTypeId;
        data["description"] = this.description;
        data["value"] = this.value;
        data["isActive"] = this.isActive;
        data["isDesign"] = this.isDesign;
        return data;
    }

    clone(): MaterialDto {
        const json = this.toJSON();
        let result = new MaterialDto();
        result.init(json);
        return result;
    }
}

export interface IMaterialDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    materialTypeId?: number;
    description?: string | undefined;
    value?: number;
    isActive?: boolean;
    isDesign?: boolean;
}

export class MaterialDtoApiResultObject implements IMaterialDtoApiResultObject {
    result?: MaterialDto;
    success?: boolean;

    constructor(data?: IMaterialDtoApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? MaterialDto.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): MaterialDtoApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new MaterialDtoApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data;
    }

    clone(): MaterialDtoApiResultObject {
        const json = this.toJSON();
        let result = new MaterialDtoApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IMaterialDtoApiResultObject {
    result?: MaterialDto;
    success?: boolean;
}

export class MaterialListItemDto implements IMaterialListItemDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    materialTypeId?: number;
    description?: string | undefined;
    value?: number;
    isActive?: boolean;
    isDesign?: boolean;
    materialTypeName?: string | undefined;

    constructor(data?: IMaterialListItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.materialTypeId = _data["materialTypeId"];
            this.description = _data["description"];
            this.value = _data["value"];
            this.isActive = _data["isActive"];
            this.isDesign = _data["isDesign"];
            this.materialTypeName = _data["materialTypeName"];
        }
    }

    static fromJS(data: any): MaterialListItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new MaterialListItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["materialTypeId"] = this.materialTypeId;
        data["description"] = this.description;
        data["value"] = this.value;
        data["isActive"] = this.isActive;
        data["isDesign"] = this.isDesign;
        data["materialTypeName"] = this.materialTypeName;
        return data;
    }

    clone(): MaterialListItemDto {
        const json = this.toJSON();
        let result = new MaterialListItemDto();
        result.init(json);
        return result;
    }
}

export interface IMaterialListItemDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    materialTypeId?: number;
    description?: string | undefined;
    value?: number;
    isActive?: boolean;
    isDesign?: boolean;
    materialTypeName?: string | undefined;
}

export class MaterialListItemDtoPagingResult implements IMaterialListItemDtoPagingResult {
    items?: MaterialListItemDto[] | undefined;
    totalCount?: number;

    constructor(data?: IMaterialListItemDtoPagingResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(MaterialListItemDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): MaterialListItemDtoPagingResult {
        data = typeof data === 'object' ? data : {};
        let result = new MaterialListItemDtoPagingResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): MaterialListItemDtoPagingResult {
        const json = this.toJSON();
        let result = new MaterialListItemDtoPagingResult();
        result.init(json);
        return result;
    }
}

export interface IMaterialListItemDtoPagingResult {
    items?: MaterialListItemDto[] | undefined;
    totalCount?: number;
}

export class MaterialListItemDtoPagingResultApiResultObject implements IMaterialListItemDtoPagingResultApiResultObject {
    result?: MaterialListItemDtoPagingResult;
    success?: boolean;

    constructor(data?: IMaterialListItemDtoPagingResultApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? MaterialListItemDtoPagingResult.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): MaterialListItemDtoPagingResultApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new MaterialListItemDtoPagingResultApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data;
    }

    clone(): MaterialListItemDtoPagingResultApiResultObject {
        const json = this.toJSON();
        let result = new MaterialListItemDtoPagingResultApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IMaterialListItemDtoPagingResultApiResultObject {
    result?: MaterialListItemDtoPagingResult;
    success?: boolean;
}

export class MaterialTypeDto implements IMaterialTypeDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    isActive?: boolean;

    constructor(data?: IMaterialTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): MaterialTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new MaterialTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): MaterialTypeDto {
        const json = this.toJSON();
        let result = new MaterialTypeDto();
        result.init(json);
        return result;
    }
}

export interface IMaterialTypeDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    isActive?: boolean;
}

export class MaterialTypeDtoApiResultObject implements IMaterialTypeDtoApiResultObject {
    result?: MaterialTypeDto;
    success?: boolean;

    constructor(data?: IMaterialTypeDtoApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? MaterialTypeDto.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): MaterialTypeDtoApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new MaterialTypeDtoApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data;
    }

    clone(): MaterialTypeDtoApiResultObject {
        const json = this.toJSON();
        let result = new MaterialTypeDtoApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IMaterialTypeDtoApiResultObject {
    result?: MaterialTypeDto;
    success?: boolean;
}

export class MaterialTypeDtoPagingResult implements IMaterialTypeDtoPagingResult {
    items?: MaterialTypeDto[] | undefined;
    totalCount?: number;

    constructor(data?: IMaterialTypeDtoPagingResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(MaterialTypeDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): MaterialTypeDtoPagingResult {
        data = typeof data === 'object' ? data : {};
        let result = new MaterialTypeDtoPagingResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): MaterialTypeDtoPagingResult {
        const json = this.toJSON();
        let result = new MaterialTypeDtoPagingResult();
        result.init(json);
        return result;
    }
}

export interface IMaterialTypeDtoPagingResult {
    items?: MaterialTypeDto[] | undefined;
    totalCount?: number;
}

export class MaterialTypeDtoPagingResultApiResultObject implements IMaterialTypeDtoPagingResultApiResultObject {
    result?: MaterialTypeDtoPagingResult;
    success?: boolean;

    constructor(data?: IMaterialTypeDtoPagingResultApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? MaterialTypeDtoPagingResult.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): MaterialTypeDtoPagingResultApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new MaterialTypeDtoPagingResultApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data;
    }

    clone(): MaterialTypeDtoPagingResultApiResultObject {
        const json = this.toJSON();
        let result = new MaterialTypeDtoPagingResultApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IMaterialTypeDtoPagingResultApiResultObject {
    result?: MaterialTypeDtoPagingResult;
    success?: boolean;
}

export class MaterialUpsertCommand implements IMaterialUpsertCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: UpsertMaterialDto;
    readonly handleType?: string | undefined;

    constructor(data?: IMaterialUpsertCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? UpsertMaterialDto.fromJS(_data["data"]) : <any>undefined;
            (<any>this).handleType = _data["handleType"];
        }
    }

    static fromJS(data: any): MaterialUpsertCommand {
        data = typeof data === 'object' ? data : {};
        let result = new MaterialUpsertCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["handleType"] = this.handleType;
        return data;
    }

    clone(): MaterialUpsertCommand {
        const json = this.toJSON();
        let result = new MaterialUpsertCommand();
        result.init(json);
        return result;
    }
}

export interface IMaterialUpsertCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: UpsertMaterialDto;
    handleType?: string | undefined;
}

export class MonthData implements IMonthData {
    year?: number;
    month?: number;
    amount?: number;

    constructor(data?: IMonthData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.year = _data["year"];
            this.month = _data["month"];
            this.amount = _data["amount"];
        }
    }

    static fromJS(data: any): MonthData {
        data = typeof data === 'object' ? data : {};
        let result = new MonthData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["year"] = this.year;
        data["month"] = this.month;
        data["amount"] = this.amount;
        return data;
    }

    clone(): MonthData {
        const json = this.toJSON();
        let result = new MonthData();
        result.init(json);
        return result;
    }
}

export interface IMonthData {
    year?: number;
    month?: number;
    amount?: number;
}

export class NotificationBranchDto implements INotificationBranchDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    isSelected?: boolean;
    branchId?: number;
    areaName?: string | undefined;
    branchCode?: string | undefined;
    branchName?: string | undefined;
    zoneName?: string | undefined;
    zoneId?: number | undefined;
    areaId?: number | undefined;

    constructor(data?: INotificationBranchDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isSelected = _data["isSelected"];
            this.branchId = _data["branchId"];
            this.areaName = _data["areaName"];
            this.branchCode = _data["branchCode"];
            this.branchName = _data["branchName"];
            this.zoneName = _data["zoneName"];
            this.zoneId = _data["zoneId"];
            this.areaId = _data["areaId"];
        }
    }

    static fromJS(data: any): NotificationBranchDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationBranchDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isSelected"] = this.isSelected;
        data["branchId"] = this.branchId;
        data["areaName"] = this.areaName;
        data["branchCode"] = this.branchCode;
        data["branchName"] = this.branchName;
        data["zoneName"] = this.zoneName;
        data["zoneId"] = this.zoneId;
        data["areaId"] = this.areaId;
        return data;
    }

    clone(): NotificationBranchDto {
        const json = this.toJSON();
        let result = new NotificationBranchDto();
        result.init(json);
        return result;
    }
}

export interface INotificationBranchDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    isSelected?: boolean;
    branchId?: number;
    areaName?: string | undefined;
    branchCode?: string | undefined;
    branchName?: string | undefined;
    zoneName?: string | undefined;
    zoneId?: number | undefined;
    areaId?: number | undefined;
}

export class NotificationBranchUpsertDto implements INotificationBranchUpsertDto {
    id?: number;
    branchId?: number;

    constructor(data?: INotificationBranchUpsertDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.branchId = _data["branchId"];
        }
    }

    static fromJS(data: any): NotificationBranchUpsertDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationBranchUpsertDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["branchId"] = this.branchId;
        return data;
    }

    clone(): NotificationBranchUpsertDto {
        const json = this.toJSON();
        let result = new NotificationBranchUpsertDto();
        result.init(json);
        return result;
    }
}

export interface INotificationBranchUpsertDto {
    id?: number;
    branchId?: number;
}

export class NotificationBranchUpsertDtoCrudListDto implements INotificationBranchUpsertDtoCrudListDto {
    upsertedItems?: NotificationBranchUpsertDto[] | undefined;
    deletedItems?: NotificationBranchUpsertDto[] | undefined;

    constructor(data?: INotificationBranchUpsertDtoCrudListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["upsertedItems"])) {
                this.upsertedItems = [] as any;
                for (let item of _data["upsertedItems"])
                    this.upsertedItems!.push(NotificationBranchUpsertDto.fromJS(item));
            }
            if (Array.isArray(_data["deletedItems"])) {
                this.deletedItems = [] as any;
                for (let item of _data["deletedItems"])
                    this.deletedItems!.push(NotificationBranchUpsertDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): NotificationBranchUpsertDtoCrudListDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationBranchUpsertDtoCrudListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.upsertedItems)) {
            data["upsertedItems"] = [];
            for (let item of this.upsertedItems)
                data["upsertedItems"].push(item.toJSON());
        }
        if (Array.isArray(this.deletedItems)) {
            data["deletedItems"] = [];
            for (let item of this.deletedItems)
                data["deletedItems"].push(item.toJSON());
        }
        return data;
    }

    clone(): NotificationBranchUpsertDtoCrudListDto {
        const json = this.toJSON();
        let result = new NotificationBranchUpsertDtoCrudListDto();
        result.init(json);
        return result;
    }
}

export interface INotificationBranchUpsertDtoCrudListDto {
    upsertedItems?: NotificationBranchUpsertDto[] | undefined;
    deletedItems?: NotificationBranchUpsertDto[] | undefined;
}

export class NotificationDto implements INotificationDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    description?: string | undefined;
    shortContent?: string | undefined;
    content?: string | undefined;
    status?: number;
    objectType?: number;
    notificationBranches?: NotificationBranchDto[] | undefined;

    constructor(data?: INotificationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.description = _data["description"];
            this.shortContent = _data["shortContent"];
            this.content = _data["content"];
            this.status = _data["status"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["notificationBranches"])) {
                this.notificationBranches = [] as any;
                for (let item of _data["notificationBranches"])
                    this.notificationBranches!.push(NotificationBranchDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): NotificationDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["description"] = this.description;
        data["shortContent"] = this.shortContent;
        data["content"] = this.content;
        data["status"] = this.status;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.notificationBranches)) {
            data["notificationBranches"] = [];
            for (let item of this.notificationBranches)
                data["notificationBranches"].push(item.toJSON());
        }
        return data;
    }

    clone(): NotificationDto {
        const json = this.toJSON();
        let result = new NotificationDto();
        result.init(json);
        return result;
    }
}

export interface INotificationDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    description?: string | undefined;
    shortContent?: string | undefined;
    content?: string | undefined;
    status?: number;
    objectType?: number;
    notificationBranches?: NotificationBranchDto[] | undefined;
}

export class NotificationDtoApiResultObject implements INotificationDtoApiResultObject {
    result?: NotificationDto;
    success?: boolean;

    constructor(data?: INotificationDtoApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? NotificationDto.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): NotificationDtoApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationDtoApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data;
    }

    clone(): NotificationDtoApiResultObject {
        const json = this.toJSON();
        let result = new NotificationDtoApiResultObject();
        result.init(json);
        return result;
    }
}

export interface INotificationDtoApiResultObject {
    result?: NotificationDto;
    success?: boolean;
}

export class NotificationListDto implements INotificationListDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    description?: string | undefined;
    shortContent?: string | undefined;
    content?: string | undefined;
    status?: number;
    objectType?: number;

    constructor(data?: INotificationListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.description = _data["description"];
            this.shortContent = _data["shortContent"];
            this.content = _data["content"];
            this.status = _data["status"];
            this.objectType = _data["objectType"];
        }
    }

    static fromJS(data: any): NotificationListDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["description"] = this.description;
        data["shortContent"] = this.shortContent;
        data["content"] = this.content;
        data["status"] = this.status;
        data["objectType"] = this.objectType;
        return data;
    }

    clone(): NotificationListDto {
        const json = this.toJSON();
        let result = new NotificationListDto();
        result.init(json);
        return result;
    }
}

export interface INotificationListDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    description?: string | undefined;
    shortContent?: string | undefined;
    content?: string | undefined;
    status?: number;
    objectType?: number;
}

export class NotificationListDtoPagingResult implements INotificationListDtoPagingResult {
    items?: NotificationListDto[] | undefined;
    totalCount?: number;

    constructor(data?: INotificationListDtoPagingResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(NotificationListDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): NotificationListDtoPagingResult {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationListDtoPagingResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): NotificationListDtoPagingResult {
        const json = this.toJSON();
        let result = new NotificationListDtoPagingResult();
        result.init(json);
        return result;
    }
}

export interface INotificationListDtoPagingResult {
    items?: NotificationListDto[] | undefined;
    totalCount?: number;
}

export class NotificationListDtoPagingResultApiResultObject implements INotificationListDtoPagingResultApiResultObject {
    result?: NotificationListDtoPagingResult;
    success?: boolean;

    constructor(data?: INotificationListDtoPagingResultApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? NotificationListDtoPagingResult.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): NotificationListDtoPagingResultApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationListDtoPagingResultApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data;
    }

    clone(): NotificationListDtoPagingResultApiResultObject {
        const json = this.toJSON();
        let result = new NotificationListDtoPagingResultApiResultObject();
        result.init(json);
        return result;
    }
}

export interface INotificationListDtoPagingResultApiResultObject {
    result?: NotificationListDtoPagingResult;
    success?: boolean;
}

export class NotificationUpsertCommand implements INotificationUpsertCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: NotificationUpsertDto;
    readonly handleType?: string | undefined;

    constructor(data?: INotificationUpsertCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? NotificationUpsertDto.fromJS(_data["data"]) : <any>undefined;
            (<any>this).handleType = _data["handleType"];
        }
    }

    static fromJS(data: any): NotificationUpsertCommand {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationUpsertCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["handleType"] = this.handleType;
        return data;
    }

    clone(): NotificationUpsertCommand {
        const json = this.toJSON();
        let result = new NotificationUpsertCommand();
        result.init(json);
        return result;
    }
}

export interface INotificationUpsertCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: NotificationUpsertDto;
    handleType?: string | undefined;
}

export class NotificationUpsertDto implements INotificationUpsertDto {
    id?: number;
    description?: string | undefined;
    content?: string | undefined;
    shortContent?: string | undefined;
    objectType?: number;
    notificationBranchChanges?: NotificationBranchUpsertDtoCrudListDto;

    constructor(data?: INotificationUpsertDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.description = _data["description"];
            this.content = _data["content"];
            this.shortContent = _data["shortContent"];
            this.objectType = _data["objectType"];
            this.notificationBranchChanges = _data["notificationBranchChanges"] ? NotificationBranchUpsertDtoCrudListDto.fromJS(_data["notificationBranchChanges"]) : <any>undefined;
        }
    }

    static fromJS(data: any): NotificationUpsertDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationUpsertDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["description"] = this.description;
        data["content"] = this.content;
        data["shortContent"] = this.shortContent;
        data["objectType"] = this.objectType;
        data["notificationBranchChanges"] = this.notificationBranchChanges ? this.notificationBranchChanges.toJSON() : <any>undefined;
        return data;
    }

    clone(): NotificationUpsertDto {
        const json = this.toJSON();
        let result = new NotificationUpsertDto();
        result.init(json);
        return result;
    }
}

export interface INotificationUpsertDto {
    id?: number;
    description?: string | undefined;
    content?: string | undefined;
    shortContent?: string | undefined;
    objectType?: number;
    notificationBranchChanges?: NotificationBranchUpsertDtoCrudListDto;
}

export class ObjectApiResultObject implements IObjectApiResultObject {
    result?: any | undefined;
    success?: boolean;

    constructor(data?: IObjectApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"];
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): ObjectApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new ObjectApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result;
        data["success"] = this.success;
        return data;
    }

    clone(): ObjectApiResultObject {
        const json = this.toJSON();
        let result = new ObjectApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IObjectApiResultObject {
    result?: any | undefined;
    success?: boolean;
}

export class OrderCreateCommand implements IOrderCreateCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: OrderCreateDto;

    constructor(data?: IOrderCreateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? OrderCreateDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): OrderCreateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new OrderCreateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }

    clone(): OrderCreateCommand {
        const json = this.toJSON();
        let result = new OrderCreateCommand();
        result.init(json);
        return result;
    }
}

export interface IOrderCreateCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: OrderCreateDto;
}

export class OrderCreateDto implements IOrderCreateDto {
    consumerPhone?: string | undefined;
    consumerName?: string | undefined;
    orderDetails?: OrderDetailCreateDto[] | undefined;

    constructor(data?: IOrderCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.consumerPhone = _data["consumerPhone"];
            this.consumerName = _data["consumerName"];
            if (Array.isArray(_data["orderDetails"])) {
                this.orderDetails = [] as any;
                for (let item of _data["orderDetails"])
                    this.orderDetails!.push(OrderDetailCreateDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OrderCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["consumerPhone"] = this.consumerPhone;
        data["consumerName"] = this.consumerName;
        if (Array.isArray(this.orderDetails)) {
            data["orderDetails"] = [];
            for (let item of this.orderDetails)
                data["orderDetails"].push(item.toJSON());
        }
        return data;
    }

    clone(): OrderCreateDto {
        const json = this.toJSON();
        let result = new OrderCreateDto();
        result.init(json);
        return result;
    }
}

export interface IOrderCreateDto {
    consumerPhone?: string | undefined;
    consumerName?: string | undefined;
    orderDetails?: OrderDetailCreateDto[] | undefined;
}

export class OrderDetailCreateDto implements IOrderDetailCreateDto {
    productCode?: string | undefined;
    qrCode?: string | undefined;
    spoonCode?: string | undefined;

    constructor(data?: IOrderDetailCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productCode = _data["productCode"];
            this.qrCode = _data["qrCode"];
            this.spoonCode = _data["spoonCode"];
        }
    }

    static fromJS(data: any): OrderDetailCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderDetailCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productCode"] = this.productCode;
        data["qrCode"] = this.qrCode;
        data["spoonCode"] = this.spoonCode;
        return data;
    }

    clone(): OrderDetailCreateDto {
        const json = this.toJSON();
        let result = new OrderDetailCreateDto();
        result.init(json);
        return result;
    }
}

export interface IOrderDetailCreateDto {
    productCode?: string | undefined;
    qrCode?: string | undefined;
    spoonCode?: string | undefined;
}

export class OrderDetailDto implements IOrderDetailDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    productId?: number;
    productCode?: string | undefined;
    qrCode?: string | undefined;
    spoonCode?: string | undefined;
    productName?: string | undefined;
    unitName?: string | undefined;
    quantity?: number;
    unitPrice?: number;
    lineAmount?: number;
    api?: string | undefined;
    points?: number;
    availablePoints?: number;
    usedPoints?: number;
    usedForTicket?: boolean;

    constructor(data?: IOrderDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.productId = _data["productId"];
            this.productCode = _data["productCode"];
            this.qrCode = _data["qrCode"];
            this.spoonCode = _data["spoonCode"];
            this.productName = _data["productName"];
            this.unitName = _data["unitName"];
            this.quantity = _data["quantity"];
            this.unitPrice = _data["unitPrice"];
            this.lineAmount = _data["lineAmount"];
            this.api = _data["api"];
            this.points = _data["points"];
            this.availablePoints = _data["availablePoints"];
            this.usedPoints = _data["usedPoints"];
            this.usedForTicket = _data["usedForTicket"];
        }
    }

    static fromJS(data: any): OrderDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["productId"] = this.productId;
        data["productCode"] = this.productCode;
        data["qrCode"] = this.qrCode;
        data["spoonCode"] = this.spoonCode;
        data["productName"] = this.productName;
        data["unitName"] = this.unitName;
        data["quantity"] = this.quantity;
        data["unitPrice"] = this.unitPrice;
        data["lineAmount"] = this.lineAmount;
        data["api"] = this.api;
        data["points"] = this.points;
        data["availablePoints"] = this.availablePoints;
        data["usedPoints"] = this.usedPoints;
        data["usedForTicket"] = this.usedForTicket;
        return data;
    }

    clone(): OrderDetailDto {
        const json = this.toJSON();
        let result = new OrderDetailDto();
        result.init(json);
        return result;
    }
}

export interface IOrderDetailDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    productId?: number;
    productCode?: string | undefined;
    qrCode?: string | undefined;
    spoonCode?: string | undefined;
    productName?: string | undefined;
    unitName?: string | undefined;
    quantity?: number;
    unitPrice?: number;
    lineAmount?: number;
    api?: string | undefined;
    points?: number;
    availablePoints?: number;
    usedPoints?: number;
    usedForTicket?: boolean;
}

export class OrderDetailDtoPagingResult implements IOrderDetailDtoPagingResult {
    items?: OrderDetailDto[] | undefined;
    totalCount?: number;

    constructor(data?: IOrderDetailDtoPagingResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(OrderDetailDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): OrderDetailDtoPagingResult {
        data = typeof data === 'object' ? data : {};
        let result = new OrderDetailDtoPagingResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): OrderDetailDtoPagingResult {
        const json = this.toJSON();
        let result = new OrderDetailDtoPagingResult();
        result.init(json);
        return result;
    }
}

export interface IOrderDetailDtoPagingResult {
    items?: OrderDetailDto[] | undefined;
    totalCount?: number;
}

export class OrderDetailDtoPagingResultApiResultObject implements IOrderDetailDtoPagingResultApiResultObject {
    result?: OrderDetailDtoPagingResult;
    success?: boolean;

    constructor(data?: IOrderDetailDtoPagingResultApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? OrderDetailDtoPagingResult.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): OrderDetailDtoPagingResultApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new OrderDetailDtoPagingResultApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data;
    }

    clone(): OrderDetailDtoPagingResultApiResultObject {
        const json = this.toJSON();
        let result = new OrderDetailDtoPagingResultApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IOrderDetailDtoPagingResultApiResultObject {
    result?: OrderDetailDtoPagingResult;
    success?: boolean;
}

export class OrderDto implements IOrderDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    orderNumber?: string | undefined;
    ticketInvestmentId?: number | undefined;
    customerId?: number;
    branchId?: number;
    orderDate?: Date;
    consumerPhone?: string | undefined;
    consumerName?: string | undefined;
    totalQuantity?: number;
    totalAmount?: number;
    totalPoints?: number;
    totalAvailablePoints?: number;
    totalUsedPoints?: number;
    orderDetails?: OrderDetailDto[] | undefined;
    tickets?: OrderTicketDto[] | undefined;

    constructor(data?: IOrderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.orderNumber = _data["orderNumber"];
            this.ticketInvestmentId = _data["ticketInvestmentId"];
            this.customerId = _data["customerId"];
            this.branchId = _data["branchId"];
            this.orderDate = _data["orderDate"] ? new Date(_data["orderDate"].toString()) : <any>undefined;
            this.consumerPhone = _data["consumerPhone"];
            this.consumerName = _data["consumerName"];
            this.totalQuantity = _data["totalQuantity"];
            this.totalAmount = _data["totalAmount"];
            this.totalPoints = _data["totalPoints"];
            this.totalAvailablePoints = _data["totalAvailablePoints"];
            this.totalUsedPoints = _data["totalUsedPoints"];
            if (Array.isArray(_data["orderDetails"])) {
                this.orderDetails = [] as any;
                for (let item of _data["orderDetails"])
                    this.orderDetails!.push(OrderDetailDto.fromJS(item));
            }
            if (Array.isArray(_data["tickets"])) {
                this.tickets = [] as any;
                for (let item of _data["tickets"])
                    this.tickets!.push(OrderTicketDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["orderNumber"] = this.orderNumber;
        data["ticketInvestmentId"] = this.ticketInvestmentId;
        data["customerId"] = this.customerId;
        data["branchId"] = this.branchId;
        data["orderDate"] = this.orderDate ? this.orderDate.toISOString() : <any>undefined;
        data["consumerPhone"] = this.consumerPhone;
        data["consumerName"] = this.consumerName;
        data["totalQuantity"] = this.totalQuantity;
        data["totalAmount"] = this.totalAmount;
        data["totalPoints"] = this.totalPoints;
        data["totalAvailablePoints"] = this.totalAvailablePoints;
        data["totalUsedPoints"] = this.totalUsedPoints;
        if (Array.isArray(this.orderDetails)) {
            data["orderDetails"] = [];
            for (let item of this.orderDetails)
                data["orderDetails"].push(item.toJSON());
        }
        if (Array.isArray(this.tickets)) {
            data["tickets"] = [];
            for (let item of this.tickets)
                data["tickets"].push(item.toJSON());
        }
        return data;
    }

    clone(): OrderDto {
        const json = this.toJSON();
        let result = new OrderDto();
        result.init(json);
        return result;
    }
}

export interface IOrderDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    orderNumber?: string | undefined;
    ticketInvestmentId?: number | undefined;
    customerId?: number;
    branchId?: number;
    orderDate?: Date;
    consumerPhone?: string | undefined;
    consumerName?: string | undefined;
    totalQuantity?: number;
    totalAmount?: number;
    totalPoints?: number;
    totalAvailablePoints?: number;
    totalUsedPoints?: number;
    orderDetails?: OrderDetailDto[] | undefined;
    tickets?: OrderTicketDto[] | undefined;
}

export class OrderDtoApiResultObject implements IOrderDtoApiResultObject {
    result?: OrderDto;
    success?: boolean;

    constructor(data?: IOrderDtoApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? OrderDto.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): OrderDtoApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new OrderDtoApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data;
    }

    clone(): OrderDtoApiResultObject {
        const json = this.toJSON();
        let result = new OrderDtoApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IOrderDtoApiResultObject {
    result?: OrderDto;
    success?: boolean;
}

export class OrderListItemDto implements IOrderListItemDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    orderNumber?: string | undefined;
    ticketInvestmentId?: number | undefined;
    ticketInvestmentCode?: string | undefined;
    customerId?: number;
    customerCode?: string | undefined;
    customerName?: string | undefined;
    ticketCodes?: string | undefined;
    branchId?: number;
    orderDate?: Date;
    consumerPhone?: string | undefined;
    consumerName?: string | undefined;
    totalQuantity?: number;
    totalAmount?: number;
    totalPoints?: number;
    totalAvailablePoints?: number;
    totalUsedPoints?: number;

    constructor(data?: IOrderListItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.orderNumber = _data["orderNumber"];
            this.ticketInvestmentId = _data["ticketInvestmentId"];
            this.ticketInvestmentCode = _data["ticketInvestmentCode"];
            this.customerId = _data["customerId"];
            this.customerCode = _data["customerCode"];
            this.customerName = _data["customerName"];
            this.ticketCodes = _data["ticketCodes"];
            this.branchId = _data["branchId"];
            this.orderDate = _data["orderDate"] ? new Date(_data["orderDate"].toString()) : <any>undefined;
            this.consumerPhone = _data["consumerPhone"];
            this.consumerName = _data["consumerName"];
            this.totalQuantity = _data["totalQuantity"];
            this.totalAmount = _data["totalAmount"];
            this.totalPoints = _data["totalPoints"];
            this.totalAvailablePoints = _data["totalAvailablePoints"];
            this.totalUsedPoints = _data["totalUsedPoints"];
        }
    }

    static fromJS(data: any): OrderListItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderListItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["orderNumber"] = this.orderNumber;
        data["ticketInvestmentId"] = this.ticketInvestmentId;
        data["ticketInvestmentCode"] = this.ticketInvestmentCode;
        data["customerId"] = this.customerId;
        data["customerCode"] = this.customerCode;
        data["customerName"] = this.customerName;
        data["ticketCodes"] = this.ticketCodes;
        data["branchId"] = this.branchId;
        data["orderDate"] = this.orderDate ? this.orderDate.toISOString() : <any>undefined;
        data["consumerPhone"] = this.consumerPhone;
        data["consumerName"] = this.consumerName;
        data["totalQuantity"] = this.totalQuantity;
        data["totalAmount"] = this.totalAmount;
        data["totalPoints"] = this.totalPoints;
        data["totalAvailablePoints"] = this.totalAvailablePoints;
        data["totalUsedPoints"] = this.totalUsedPoints;
        return data;
    }

    clone(): OrderListItemDto {
        const json = this.toJSON();
        let result = new OrderListItemDto();
        result.init(json);
        return result;
    }
}

export interface IOrderListItemDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    orderNumber?: string | undefined;
    ticketInvestmentId?: number | undefined;
    ticketInvestmentCode?: string | undefined;
    customerId?: number;
    customerCode?: string | undefined;
    customerName?: string | undefined;
    ticketCodes?: string | undefined;
    branchId?: number;
    orderDate?: Date;
    consumerPhone?: string | undefined;
    consumerName?: string | undefined;
    totalQuantity?: number;
    totalAmount?: number;
    totalPoints?: number;
    totalAvailablePoints?: number;
    totalUsedPoints?: number;
}

export class OrderListItemDtoListApiResultObject implements IOrderListItemDtoListApiResultObject {
    result?: OrderListItemDto[] | undefined;
    success?: boolean;

    constructor(data?: IOrderListItemDtoListApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(OrderListItemDto.fromJS(item));
            }
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): OrderListItemDtoListApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new OrderListItemDtoListApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["success"] = this.success;
        return data;
    }

    clone(): OrderListItemDtoListApiResultObject {
        const json = this.toJSON();
        let result = new OrderListItemDtoListApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IOrderListItemDtoListApiResultObject {
    result?: OrderListItemDto[] | undefined;
    success?: boolean;
}

export class OrderListItemDtoPagingResult implements IOrderListItemDtoPagingResult {
    items?: OrderListItemDto[] | undefined;
    totalCount?: number;

    constructor(data?: IOrderListItemDtoPagingResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(OrderListItemDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): OrderListItemDtoPagingResult {
        data = typeof data === 'object' ? data : {};
        let result = new OrderListItemDtoPagingResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): OrderListItemDtoPagingResult {
        const json = this.toJSON();
        let result = new OrderListItemDtoPagingResult();
        result.init(json);
        return result;
    }
}

export interface IOrderListItemDtoPagingResult {
    items?: OrderListItemDto[] | undefined;
    totalCount?: number;
}

export class OrderListItemDtoPagingResultApiResultObject implements IOrderListItemDtoPagingResultApiResultObject {
    result?: OrderListItemDtoPagingResult;
    success?: boolean;

    constructor(data?: IOrderListItemDtoPagingResultApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? OrderListItemDtoPagingResult.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): OrderListItemDtoPagingResultApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new OrderListItemDtoPagingResultApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data;
    }

    clone(): OrderListItemDtoPagingResultApiResultObject {
        const json = this.toJSON();
        let result = new OrderListItemDtoPagingResultApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IOrderListItemDtoPagingResultApiResultObject {
    result?: OrderListItemDtoPagingResult;
    success?: boolean;
}

export class OrderTicketDto implements IOrderTicketDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    ticketCode?: string | undefined;
    ticketId?: number;

    constructor(data?: IOrderTicketDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.ticketCode = _data["ticketCode"];
            this.ticketId = _data["ticketId"];
        }
    }

    static fromJS(data: any): OrderTicketDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderTicketDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["ticketCode"] = this.ticketCode;
        data["ticketId"] = this.ticketId;
        return data;
    }

    clone(): OrderTicketDto {
        const json = this.toJSON();
        let result = new OrderTicketDto();
        result.init(json);
        return result;
    }
}

export interface IOrderTicketDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    ticketCode?: string | undefined;
    ticketId?: number;
}

export class OrderUpdateSpoonCodeCommand implements IOrderUpdateSpoonCodeCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    phone?: string | undefined;
    name?: string | undefined;
    qrCode?: string | undefined;
    spoonCode?: string | undefined;

    constructor(data?: IOrderUpdateSpoonCodeCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.phone = _data["phone"];
            this.name = _data["name"];
            this.qrCode = _data["qrCode"];
            this.spoonCode = _data["spoonCode"];
        }
    }

    static fromJS(data: any): OrderUpdateSpoonCodeCommand {
        data = typeof data === 'object' ? data : {};
        let result = new OrderUpdateSpoonCodeCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["phone"] = this.phone;
        data["name"] = this.name;
        data["qrCode"] = this.qrCode;
        data["spoonCode"] = this.spoonCode;
        return data;
    }

    clone(): OrderUpdateSpoonCodeCommand {
        const json = this.toJSON();
        let result = new OrderUpdateSpoonCodeCommand();
        result.init(json);
        return result;
    }
}

export interface IOrderUpdateSpoonCodeCommand {
    commandId?: string;
    occuredDate?: Date;
    phone?: string | undefined;
    name?: string | undefined;
    qrCode?: string | undefined;
    spoonCode?: string | undefined;
}

export class OrderValidateSpoonCodeCommand implements IOrderValidateSpoonCodeCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    spoonCode?: string | undefined;

    constructor(data?: IOrderValidateSpoonCodeCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.spoonCode = _data["spoonCode"];
        }
    }

    static fromJS(data: any): OrderValidateSpoonCodeCommand {
        data = typeof data === 'object' ? data : {};
        let result = new OrderValidateSpoonCodeCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["spoonCode"] = this.spoonCode;
        return data;
    }

    clone(): OrderValidateSpoonCodeCommand {
        const json = this.toJSON();
        let result = new OrderValidateSpoonCodeCommand();
        result.init(json);
        return result;
    }
}

export interface IOrderValidateSpoonCodeCommand {
    commandId?: string;
    occuredDate?: Date;
    spoonCode?: string | undefined;
}

export class PermissionDto implements IPermissionDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    parentId?: number | undefined;
    isActive?: boolean;

    constructor(data?: IPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.parentId = _data["parentId"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): PermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["description"] = this.description;
        data["parentId"] = this.parentId;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): PermissionDto {
        const json = this.toJSON();
        let result = new PermissionDto();
        result.init(json);
        return result;
    }
}

export interface IPermissionDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    parentId?: number | undefined;
    isActive?: boolean;
}

export class PermissionDtoApiResultObject implements IPermissionDtoApiResultObject {
    result?: PermissionDto;
    success?: boolean;

    constructor(data?: IPermissionDtoApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? PermissionDto.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): PermissionDtoApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDtoApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data;
    }

    clone(): PermissionDtoApiResultObject {
        const json = this.toJSON();
        let result = new PermissionDtoApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IPermissionDtoApiResultObject {
    result?: PermissionDto;
    success?: boolean;
}

export class PermissionDtoPagingResult implements IPermissionDtoPagingResult {
    items?: PermissionDto[] | undefined;
    totalCount?: number;

    constructor(data?: IPermissionDtoPagingResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PermissionDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PermissionDtoPagingResult {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDtoPagingResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): PermissionDtoPagingResult {
        const json = this.toJSON();
        let result = new PermissionDtoPagingResult();
        result.init(json);
        return result;
    }
}

export interface IPermissionDtoPagingResult {
    items?: PermissionDto[] | undefined;
    totalCount?: number;
}

export class PermissionDtoPagingResultApiResultObject implements IPermissionDtoPagingResultApiResultObject {
    result?: PermissionDtoPagingResult;
    success?: boolean;

    constructor(data?: IPermissionDtoPagingResultApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? PermissionDtoPagingResult.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): PermissionDtoPagingResultApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDtoPagingResultApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data;
    }

    clone(): PermissionDtoPagingResultApiResultObject {
        const json = this.toJSON();
        let result = new PermissionDtoPagingResultApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IPermissionDtoPagingResultApiResultObject {
    result?: PermissionDtoPagingResult;
    success?: boolean;
}

export enum PosmCalcType {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
}

export class PosmCatalogDto implements IPosmCatalogDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    posmItemId?: number;
    code?: string | undefined;
    name?: string | undefined;
    link?: string | undefined;

    constructor(data?: IPosmCatalogDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.posmItemId = _data["posmItemId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.link = _data["link"];
        }
    }

    static fromJS(data: any): PosmCatalogDto {
        data = typeof data === 'object' ? data : {};
        let result = new PosmCatalogDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["posmItemId"] = this.posmItemId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["link"] = this.link;
        return data;
    }

    clone(): PosmCatalogDto {
        const json = this.toJSON();
        let result = new PosmCatalogDto();
        result.init(json);
        return result;
    }
}

export interface IPosmCatalogDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    posmItemId?: number;
    code?: string | undefined;
    name?: string | undefined;
    link?: string | undefined;
}

export class PosmCatalogDtoApiResultObject implements IPosmCatalogDtoApiResultObject {
    result?: PosmCatalogDto;
    success?: boolean;

    constructor(data?: IPosmCatalogDtoApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? PosmCatalogDto.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): PosmCatalogDtoApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new PosmCatalogDtoApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data;
    }

    clone(): PosmCatalogDtoApiResultObject {
        const json = this.toJSON();
        let result = new PosmCatalogDtoApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IPosmCatalogDtoApiResultObject {
    result?: PosmCatalogDto;
    success?: boolean;
}

export class PosmCatalogDtoCrudListDto implements IPosmCatalogDtoCrudListDto {
    upsertedItems?: PosmCatalogDto[] | undefined;
    deletedItems?: PosmCatalogDto[] | undefined;

    constructor(data?: IPosmCatalogDtoCrudListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["upsertedItems"])) {
                this.upsertedItems = [] as any;
                for (let item of _data["upsertedItems"])
                    this.upsertedItems!.push(PosmCatalogDto.fromJS(item));
            }
            if (Array.isArray(_data["deletedItems"])) {
                this.deletedItems = [] as any;
                for (let item of _data["deletedItems"])
                    this.deletedItems!.push(PosmCatalogDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PosmCatalogDtoCrudListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PosmCatalogDtoCrudListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.upsertedItems)) {
            data["upsertedItems"] = [];
            for (let item of this.upsertedItems)
                data["upsertedItems"].push(item.toJSON());
        }
        if (Array.isArray(this.deletedItems)) {
            data["deletedItems"] = [];
            for (let item of this.deletedItems)
                data["deletedItems"].push(item.toJSON());
        }
        return data;
    }

    clone(): PosmCatalogDtoCrudListDto {
        const json = this.toJSON();
        let result = new PosmCatalogDtoCrudListDto();
        result.init(json);
        return result;
    }
}

export interface IPosmCatalogDtoCrudListDto {
    upsertedItems?: PosmCatalogDto[] | undefined;
    deletedItems?: PosmCatalogDto[] | undefined;
}

export class PosmCatalogListDto implements IPosmCatalogListDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    posmItemId?: number;
    code?: string | undefined;
    name?: string | undefined;
    link?: string | undefined;
    posmClassName?: string | undefined;

    constructor(data?: IPosmCatalogListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.posmItemId = _data["posmItemId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.link = _data["link"];
            this.posmClassName = _data["posmClassName"];
        }
    }

    static fromJS(data: any): PosmCatalogListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PosmCatalogListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["posmItemId"] = this.posmItemId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["link"] = this.link;
        data["posmClassName"] = this.posmClassName;
        return data;
    }

    clone(): PosmCatalogListDto {
        const json = this.toJSON();
        let result = new PosmCatalogListDto();
        result.init(json);
        return result;
    }
}

export interface IPosmCatalogListDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    posmItemId?: number;
    code?: string | undefined;
    name?: string | undefined;
    link?: string | undefined;
    posmClassName?: string | undefined;
}

export class PosmCatalogListDtoPagingResult implements IPosmCatalogListDtoPagingResult {
    items?: PosmCatalogListDto[] | undefined;
    totalCount?: number;

    constructor(data?: IPosmCatalogListDtoPagingResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PosmCatalogListDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PosmCatalogListDtoPagingResult {
        data = typeof data === 'object' ? data : {};
        let result = new PosmCatalogListDtoPagingResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): PosmCatalogListDtoPagingResult {
        const json = this.toJSON();
        let result = new PosmCatalogListDtoPagingResult();
        result.init(json);
        return result;
    }
}

export interface IPosmCatalogListDtoPagingResult {
    items?: PosmCatalogListDto[] | undefined;
    totalCount?: number;
}

export class PosmCatalogListDtoPagingResultApiResultObject implements IPosmCatalogListDtoPagingResultApiResultObject {
    result?: PosmCatalogListDtoPagingResult;
    success?: boolean;

    constructor(data?: IPosmCatalogListDtoPagingResultApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? PosmCatalogListDtoPagingResult.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): PosmCatalogListDtoPagingResultApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new PosmCatalogListDtoPagingResultApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data;
    }

    clone(): PosmCatalogListDtoPagingResultApiResultObject {
        const json = this.toJSON();
        let result = new PosmCatalogListDtoPagingResultApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IPosmCatalogListDtoPagingResultApiResultObject {
    result?: PosmCatalogListDtoPagingResult;
    success?: boolean;
}

export class PosmClassDto implements IPosmClassDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    includeInfo?: boolean;
    isActive?: boolean;

    constructor(data?: IPosmClassDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.includeInfo = _data["includeInfo"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): PosmClassDto {
        data = typeof data === 'object' ? data : {};
        let result = new PosmClassDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["includeInfo"] = this.includeInfo;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): PosmClassDto {
        const json = this.toJSON();
        let result = new PosmClassDto();
        result.init(json);
        return result;
    }
}

export interface IPosmClassDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    includeInfo?: boolean;
    isActive?: boolean;
}

export class PosmClassDtoApiResultObject implements IPosmClassDtoApiResultObject {
    result?: PosmClassDto;
    success?: boolean;

    constructor(data?: IPosmClassDtoApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? PosmClassDto.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): PosmClassDtoApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new PosmClassDtoApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data;
    }

    clone(): PosmClassDtoApiResultObject {
        const json = this.toJSON();
        let result = new PosmClassDtoApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IPosmClassDtoApiResultObject {
    result?: PosmClassDto;
    success?: boolean;
}

export class PosmClassDtoPagingResult implements IPosmClassDtoPagingResult {
    items?: PosmClassDto[] | undefined;
    totalCount?: number;

    constructor(data?: IPosmClassDtoPagingResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PosmClassDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PosmClassDtoPagingResult {
        data = typeof data === 'object' ? data : {};
        let result = new PosmClassDtoPagingResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): PosmClassDtoPagingResult {
        const json = this.toJSON();
        let result = new PosmClassDtoPagingResult();
        result.init(json);
        return result;
    }
}

export interface IPosmClassDtoPagingResult {
    items?: PosmClassDto[] | undefined;
    totalCount?: number;
}

export class PosmClassDtoPagingResultApiResultObject implements IPosmClassDtoPagingResultApiResultObject {
    result?: PosmClassDtoPagingResult;
    success?: boolean;

    constructor(data?: IPosmClassDtoPagingResultApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? PosmClassDtoPagingResult.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): PosmClassDtoPagingResultApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new PosmClassDtoPagingResultApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data;
    }

    clone(): PosmClassDtoPagingResultApiResultObject {
        const json = this.toJSON();
        let result = new PosmClassDtoPagingResultApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IPosmClassDtoPagingResultApiResultObject {
    result?: PosmClassDtoPagingResult;
    success?: boolean;
}

export class PosmClassUpsertCommand implements IPosmClassUpsertCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: PosmClassUpsertDto;
    readonly handleType?: string | undefined;

    constructor(data?: IPosmClassUpsertCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? PosmClassUpsertDto.fromJS(_data["data"]) : <any>undefined;
            (<any>this).handleType = _data["handleType"];
        }
    }

    static fromJS(data: any): PosmClassUpsertCommand {
        data = typeof data === 'object' ? data : {};
        let result = new PosmClassUpsertCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["handleType"] = this.handleType;
        return data;
    }

    clone(): PosmClassUpsertCommand {
        const json = this.toJSON();
        let result = new PosmClassUpsertCommand();
        result.init(json);
        return result;
    }
}

export interface IPosmClassUpsertCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: PosmClassUpsertDto;
    handleType?: string | undefined;
}

export class PosmClassUpsertDto implements IPosmClassUpsertDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    includeInfo?: boolean;
    isActive?: boolean;

    constructor(data?: IPosmClassUpsertDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.includeInfo = _data["includeInfo"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): PosmClassUpsertDto {
        data = typeof data === 'object' ? data : {};
        let result = new PosmClassUpsertDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["includeInfo"] = this.includeInfo;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): PosmClassUpsertDto {
        const json = this.toJSON();
        let result = new PosmClassUpsertDto();
        result.init(json);
        return result;
    }
}

export interface IPosmClassUpsertDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    includeInfo?: boolean;
    isActive?: boolean;
}

export class PosmInvestmentAsmApproveCommand implements IPosmInvestmentAsmApproveCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: PosmInvestmentAsmApproveDto;

    constructor(data?: IPosmInvestmentAsmApproveCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? PosmInvestmentAsmApproveDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PosmInvestmentAsmApproveCommand {
        data = typeof data === 'object' ? data : {};
        let result = new PosmInvestmentAsmApproveCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }

    clone(): PosmInvestmentAsmApproveCommand {
        const json = this.toJSON();
        let result = new PosmInvestmentAsmApproveCommand();
        result.init(json);
        return result;
    }
}

export interface IPosmInvestmentAsmApproveCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: PosmInvestmentAsmApproveDto;
}

export class PosmInvestmentAsmApproveDto implements IPosmInvestmentAsmApproveDto {
    note?: string | undefined;
    id?: number;

    constructor(data?: IPosmInvestmentAsmApproveDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.note = _data["note"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PosmInvestmentAsmApproveDto {
        data = typeof data === 'object' ? data : {};
        let result = new PosmInvestmentAsmApproveDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["note"] = this.note;
        data["id"] = this.id;
        return data;
    }

    clone(): PosmInvestmentAsmApproveDto {
        const json = this.toJSON();
        let result = new PosmInvestmentAsmApproveDto();
        result.init(json);
        return result;
    }
}

export interface IPosmInvestmentAsmApproveDto {
    note?: string | undefined;
    id?: number;
}

export class PosmInvestmentAsmConfirmAcceptCommand implements IPosmInvestmentAsmConfirmAcceptCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: PosmInvestmentAsmConfirmAcceptDto;

    constructor(data?: IPosmInvestmentAsmConfirmAcceptCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? PosmInvestmentAsmConfirmAcceptDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PosmInvestmentAsmConfirmAcceptCommand {
        data = typeof data === 'object' ? data : {};
        let result = new PosmInvestmentAsmConfirmAcceptCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }

    clone(): PosmInvestmentAsmConfirmAcceptCommand {
        const json = this.toJSON();
        let result = new PosmInvestmentAsmConfirmAcceptCommand();
        result.init(json);
        return result;
    }
}

export interface IPosmInvestmentAsmConfirmAcceptCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: PosmInvestmentAsmConfirmAcceptDto;
}

export class PosmInvestmentAsmConfirmAcceptDto implements IPosmInvestmentAsmConfirmAcceptDto {
    posmInvestmentItemId?: number;
    id?: number;

    constructor(data?: IPosmInvestmentAsmConfirmAcceptDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.posmInvestmentItemId = _data["posmInvestmentItemId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PosmInvestmentAsmConfirmAcceptDto {
        data = typeof data === 'object' ? data : {};
        let result = new PosmInvestmentAsmConfirmAcceptDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["posmInvestmentItemId"] = this.posmInvestmentItemId;
        data["id"] = this.id;
        return data;
    }

    clone(): PosmInvestmentAsmConfirmAcceptDto {
        const json = this.toJSON();
        let result = new PosmInvestmentAsmConfirmAcceptDto();
        result.init(json);
        return result;
    }
}

export interface IPosmInvestmentAsmConfirmAcceptDto {
    posmInvestmentItemId?: number;
    id?: number;
}

export class PosmInvestmentAsmConfirmSuggesDto implements IPosmInvestmentAsmConfirmSuggesDto {
    posmInvestmentItemId?: number;
    id?: number;

    constructor(data?: IPosmInvestmentAsmConfirmSuggesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.posmInvestmentItemId = _data["posmInvestmentItemId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PosmInvestmentAsmConfirmSuggesDto {
        data = typeof data === 'object' ? data : {};
        let result = new PosmInvestmentAsmConfirmSuggesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["posmInvestmentItemId"] = this.posmInvestmentItemId;
        data["id"] = this.id;
        return data;
    }

    clone(): PosmInvestmentAsmConfirmSuggesDto {
        const json = this.toJSON();
        let result = new PosmInvestmentAsmConfirmSuggesDto();
        result.init(json);
        return result;
    }
}

export interface IPosmInvestmentAsmConfirmSuggesDto {
    posmInvestmentItemId?: number;
    id?: number;
}

export class PosmInvestmentAsmConfirmSuggestCommand implements IPosmInvestmentAsmConfirmSuggestCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: PosmInvestmentAsmConfirmSuggesDto;

    constructor(data?: IPosmInvestmentAsmConfirmSuggestCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? PosmInvestmentAsmConfirmSuggesDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PosmInvestmentAsmConfirmSuggestCommand {
        data = typeof data === 'object' ? data : {};
        let result = new PosmInvestmentAsmConfirmSuggestCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }

    clone(): PosmInvestmentAsmConfirmSuggestCommand {
        const json = this.toJSON();
        let result = new PosmInvestmentAsmConfirmSuggestCommand();
        result.init(json);
        return result;
    }
}

export interface IPosmInvestmentAsmConfirmSuggestCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: PosmInvestmentAsmConfirmSuggesDto;
}

export class PosmInvestmentAsmDenyCommand implements IPosmInvestmentAsmDenyCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: PosmInvestmentAsmDenyDto;

    constructor(data?: IPosmInvestmentAsmDenyCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? PosmInvestmentAsmDenyDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PosmInvestmentAsmDenyCommand {
        data = typeof data === 'object' ? data : {};
        let result = new PosmInvestmentAsmDenyCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }

    clone(): PosmInvestmentAsmDenyCommand {
        const json = this.toJSON();
        let result = new PosmInvestmentAsmDenyCommand();
        result.init(json);
        return result;
    }
}

export interface IPosmInvestmentAsmDenyCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: PosmInvestmentAsmDenyDto;
}

export class PosmInvestmentAsmDenyDto implements IPosmInvestmentAsmDenyDto {
    note?: string | undefined;
    id?: number;

    constructor(data?: IPosmInvestmentAsmDenyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.note = _data["note"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PosmInvestmentAsmDenyDto {
        data = typeof data === 'object' ? data : {};
        let result = new PosmInvestmentAsmDenyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["note"] = this.note;
        data["id"] = this.id;
        return data;
    }

    clone(): PosmInvestmentAsmDenyDto {
        const json = this.toJSON();
        let result = new PosmInvestmentAsmDenyDto();
        result.init(json);
        return result;
    }
}

export interface IPosmInvestmentAsmDenyDto {
    note?: string | undefined;
    id?: number;
}

export class PosmInvestmentCompanyRemarkCommand implements IPosmInvestmentCompanyRemarkCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: PosmInvestmentRemarkDto;
    handleType?: string | undefined;

    constructor(data?: IPosmInvestmentCompanyRemarkCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? PosmInvestmentRemarkDto.fromJS(_data["data"]) : <any>undefined;
            this.handleType = _data["handleType"];
        }
    }

    static fromJS(data: any): PosmInvestmentCompanyRemarkCommand {
        data = typeof data === 'object' ? data : {};
        let result = new PosmInvestmentCompanyRemarkCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["handleType"] = this.handleType;
        return data;
    }

    clone(): PosmInvestmentCompanyRemarkCommand {
        const json = this.toJSON();
        let result = new PosmInvestmentCompanyRemarkCommand();
        result.init(json);
        return result;
    }
}

export interface IPosmInvestmentCompanyRemarkCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: PosmInvestmentRemarkDto;
    handleType?: string | undefined;
}

export class PosmInvestmentDirectorApproveCommand implements IPosmInvestmentDirectorApproveCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: PosmInvestmentDirectorApproveDto;

    constructor(data?: IPosmInvestmentDirectorApproveCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? PosmInvestmentDirectorApproveDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PosmInvestmentDirectorApproveCommand {
        data = typeof data === 'object' ? data : {};
        let result = new PosmInvestmentDirectorApproveCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }

    clone(): PosmInvestmentDirectorApproveCommand {
        const json = this.toJSON();
        let result = new PosmInvestmentDirectorApproveCommand();
        result.init(json);
        return result;
    }
}

export interface IPosmInvestmentDirectorApproveCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: PosmInvestmentDirectorApproveDto;
}

export class PosmInvestmentDirectorApproveDto implements IPosmInvestmentDirectorApproveDto {
    note?: string | undefined;
    id?: number;

    constructor(data?: IPosmInvestmentDirectorApproveDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.note = _data["note"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PosmInvestmentDirectorApproveDto {
        data = typeof data === 'object' ? data : {};
        let result = new PosmInvestmentDirectorApproveDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["note"] = this.note;
        data["id"] = this.id;
        return data;
    }

    clone(): PosmInvestmentDirectorApproveDto {
        const json = this.toJSON();
        let result = new PosmInvestmentDirectorApproveDto();
        result.init(json);
        return result;
    }
}

export interface IPosmInvestmentDirectorApproveDto {
    note?: string | undefined;
    id?: number;
}

export class PosmInvestmentDirectorDenyCommand implements IPosmInvestmentDirectorDenyCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: PosmInvestmentDirectorDenyDto;

    constructor(data?: IPosmInvestmentDirectorDenyCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? PosmInvestmentDirectorDenyDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PosmInvestmentDirectorDenyCommand {
        data = typeof data === 'object' ? data : {};
        let result = new PosmInvestmentDirectorDenyCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }

    clone(): PosmInvestmentDirectorDenyCommand {
        const json = this.toJSON();
        let result = new PosmInvestmentDirectorDenyCommand();
        result.init(json);
        return result;
    }
}

export interface IPosmInvestmentDirectorDenyCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: PosmInvestmentDirectorDenyDto;
}

export class PosmInvestmentDirectorDenyDto implements IPosmInvestmentDirectorDenyDto {
    note?: string | undefined;
    id?: number;

    constructor(data?: IPosmInvestmentDirectorDenyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.note = _data["note"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PosmInvestmentDirectorDenyDto {
        data = typeof data === 'object' ? data : {};
        let result = new PosmInvestmentDirectorDenyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["note"] = this.note;
        data["id"] = this.id;
        return data;
    }

    clone(): PosmInvestmentDirectorDenyDto {
        const json = this.toJSON();
        let result = new PosmInvestmentDirectorDenyDto();
        result.init(json);
        return result;
    }
}

export interface IPosmInvestmentDirectorDenyDto {
    note?: string | undefined;
    id?: number;
}

export class PosmInvestmentDirectorMultiApproveCommand implements IPosmInvestmentDirectorMultiApproveCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: PosmInvestmentDirectorMultiApproveDto;

    constructor(data?: IPosmInvestmentDirectorMultiApproveCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? PosmInvestmentDirectorMultiApproveDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PosmInvestmentDirectorMultiApproveCommand {
        data = typeof data === 'object' ? data : {};
        let result = new PosmInvestmentDirectorMultiApproveCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }

    clone(): PosmInvestmentDirectorMultiApproveCommand {
        const json = this.toJSON();
        let result = new PosmInvestmentDirectorMultiApproveCommand();
        result.init(json);
        return result;
    }
}

export interface IPosmInvestmentDirectorMultiApproveCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: PosmInvestmentDirectorMultiApproveDto;
}

export class PosmInvestmentDirectorMultiApproveDto implements IPosmInvestmentDirectorMultiApproveDto {
    note?: string | undefined;
    ids?: number[] | undefined;

    constructor(data?: IPosmInvestmentDirectorMultiApproveDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.note = _data["note"];
            if (Array.isArray(_data["ids"])) {
                this.ids = [] as any;
                for (let item of _data["ids"])
                    this.ids!.push(item);
            }
        }
    }

    static fromJS(data: any): PosmInvestmentDirectorMultiApproveDto {
        data = typeof data === 'object' ? data : {};
        let result = new PosmInvestmentDirectorMultiApproveDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["note"] = this.note;
        if (Array.isArray(this.ids)) {
            data["ids"] = [];
            for (let item of this.ids)
                data["ids"].push(item);
        }
        return data;
    }

    clone(): PosmInvestmentDirectorMultiApproveDto {
        const json = this.toJSON();
        let result = new PosmInvestmentDirectorMultiApproveDto();
        result.init(json);
        return result;
    }
}

export interface IPosmInvestmentDirectorMultiApproveDto {
    note?: string | undefined;
    ids?: number[] | undefined;
}

export class PosmInvestmentDirectorMultiDenyCommand implements IPosmInvestmentDirectorMultiDenyCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: PosmInvestmentDirectorMultiDenyDto;

    constructor(data?: IPosmInvestmentDirectorMultiDenyCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? PosmInvestmentDirectorMultiDenyDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PosmInvestmentDirectorMultiDenyCommand {
        data = typeof data === 'object' ? data : {};
        let result = new PosmInvestmentDirectorMultiDenyCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }

    clone(): PosmInvestmentDirectorMultiDenyCommand {
        const json = this.toJSON();
        let result = new PosmInvestmentDirectorMultiDenyCommand();
        result.init(json);
        return result;
    }
}

export interface IPosmInvestmentDirectorMultiDenyCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: PosmInvestmentDirectorMultiDenyDto;
}

export class PosmInvestmentDirectorMultiDenyDto implements IPosmInvestmentDirectorMultiDenyDto {
    note?: string | undefined;
    ids?: number[] | undefined;

    constructor(data?: IPosmInvestmentDirectorMultiDenyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.note = _data["note"];
            if (Array.isArray(_data["ids"])) {
                this.ids = [] as any;
                for (let item of _data["ids"])
                    this.ids!.push(item);
            }
        }
    }

    static fromJS(data: any): PosmInvestmentDirectorMultiDenyDto {
        data = typeof data === 'object' ? data : {};
        let result = new PosmInvestmentDirectorMultiDenyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["note"] = this.note;
        if (Array.isArray(this.ids)) {
            data["ids"] = [];
            for (let item of this.ids)
                data["ids"].push(item);
        }
        return data;
    }

    clone(): PosmInvestmentDirectorMultiDenyDto {
        const json = this.toJSON();
        let result = new PosmInvestmentDirectorMultiDenyDto();
        result.init(json);
        return result;
    }
}

export interface IPosmInvestmentDirectorMultiDenyDto {
    note?: string | undefined;
    ids?: number[] | undefined;
}

export class PosmInvestmentDto implements IPosmInvestmentDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    customerId?: number;
    customerLocationName?: string | undefined;
    customerLocationId?: number;
    registerStaffId?: number;
    registerDate?: Date;
    budgetId?: number;
    currentSalesAmount?: number;
    note?: string | undefined;
    setupContact1?: string | undefined;
    setupContact2?: string | undefined;
    investmentAmount?: number;
    cycleId?: number;
    shopPanelPhoto1?: string | undefined;
    shopPanelPhoto2?: string | undefined;
    shopPanelPhoto3?: string | undefined;
    shopPanelPhoto4?: string | undefined;
    visibilityPhoto1?: string | undefined;
    visibilityPhoto2?: string | undefined;
    visibilityPhoto3?: string | undefined;
    visibilityPhoto4?: string | undefined;
    visibilityCompetitorPhoto1?: string | undefined;
    visibilityCompetitorPhoto2?: string | undefined;
    visibilityCompetitorPhoto3?: string | undefined;
    visibilityCompetitorPhoto4?: string | undefined;
    approveNote?: string | undefined;
    commitmentAmount?: number;
    readonly cancelReason?: string | undefined;
    customerName?: string | undefined;
    customerCode?: string | undefined;
    efficient?: number | undefined;
    mobilePhone?: string | undefined;
    address?: string | undefined;
    status?: number;
    items?: PosmInvestmentItemDto[] | undefined;
    salesCommitments?: PosmSalesCommitmentDto[] | undefined;

    constructor(data?: IPosmInvestmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.customerId = _data["customerId"];
            this.customerLocationName = _data["customerLocationName"];
            this.customerLocationId = _data["customerLocationId"];
            this.registerStaffId = _data["registerStaffId"];
            this.registerDate = _data["registerDate"] ? new Date(_data["registerDate"].toString()) : <any>undefined;
            this.budgetId = _data["budgetId"];
            this.currentSalesAmount = _data["currentSalesAmount"];
            this.note = _data["note"];
            this.setupContact1 = _data["setupContact1"];
            this.setupContact2 = _data["setupContact2"];
            this.investmentAmount = _data["investmentAmount"];
            this.cycleId = _data["cycleId"];
            this.shopPanelPhoto1 = _data["shopPanelPhoto1"];
            this.shopPanelPhoto2 = _data["shopPanelPhoto2"];
            this.shopPanelPhoto3 = _data["shopPanelPhoto3"];
            this.shopPanelPhoto4 = _data["shopPanelPhoto4"];
            this.visibilityPhoto1 = _data["visibilityPhoto1"];
            this.visibilityPhoto2 = _data["visibilityPhoto2"];
            this.visibilityPhoto3 = _data["visibilityPhoto3"];
            this.visibilityPhoto4 = _data["visibilityPhoto4"];
            this.visibilityCompetitorPhoto1 = _data["visibilityCompetitorPhoto1"];
            this.visibilityCompetitorPhoto2 = _data["visibilityCompetitorPhoto2"];
            this.visibilityCompetitorPhoto3 = _data["visibilityCompetitorPhoto3"];
            this.visibilityCompetitorPhoto4 = _data["visibilityCompetitorPhoto4"];
            this.approveNote = _data["approveNote"];
            this.commitmentAmount = _data["commitmentAmount"];
            (<any>this).cancelReason = _data["cancelReason"];
            this.customerName = _data["customerName"];
            this.customerCode = _data["customerCode"];
            this.efficient = _data["efficient"];
            this.mobilePhone = _data["mobilePhone"];
            this.address = _data["address"];
            this.status = _data["status"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PosmInvestmentItemDto.fromJS(item));
            }
            if (Array.isArray(_data["salesCommitments"])) {
                this.salesCommitments = [] as any;
                for (let item of _data["salesCommitments"])
                    this.salesCommitments!.push(PosmSalesCommitmentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PosmInvestmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new PosmInvestmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["customerId"] = this.customerId;
        data["customerLocationName"] = this.customerLocationName;
        data["customerLocationId"] = this.customerLocationId;
        data["registerStaffId"] = this.registerStaffId;
        data["registerDate"] = this.registerDate ? this.registerDate.toISOString() : <any>undefined;
        data["budgetId"] = this.budgetId;
        data["currentSalesAmount"] = this.currentSalesAmount;
        data["note"] = this.note;
        data["setupContact1"] = this.setupContact1;
        data["setupContact2"] = this.setupContact2;
        data["investmentAmount"] = this.investmentAmount;
        data["cycleId"] = this.cycleId;
        data["shopPanelPhoto1"] = this.shopPanelPhoto1;
        data["shopPanelPhoto2"] = this.shopPanelPhoto2;
        data["shopPanelPhoto3"] = this.shopPanelPhoto3;
        data["shopPanelPhoto4"] = this.shopPanelPhoto4;
        data["visibilityPhoto1"] = this.visibilityPhoto1;
        data["visibilityPhoto2"] = this.visibilityPhoto2;
        data["visibilityPhoto3"] = this.visibilityPhoto3;
        data["visibilityPhoto4"] = this.visibilityPhoto4;
        data["visibilityCompetitorPhoto1"] = this.visibilityCompetitorPhoto1;
        data["visibilityCompetitorPhoto2"] = this.visibilityCompetitorPhoto2;
        data["visibilityCompetitorPhoto3"] = this.visibilityCompetitorPhoto3;
        data["visibilityCompetitorPhoto4"] = this.visibilityCompetitorPhoto4;
        data["approveNote"] = this.approveNote;
        data["commitmentAmount"] = this.commitmentAmount;
        data["cancelReason"] = this.cancelReason;
        data["customerName"] = this.customerName;
        data["customerCode"] = this.customerCode;
        data["efficient"] = this.efficient;
        data["mobilePhone"] = this.mobilePhone;
        data["address"] = this.address;
        data["status"] = this.status;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        if (Array.isArray(this.salesCommitments)) {
            data["salesCommitments"] = [];
            for (let item of this.salesCommitments)
                data["salesCommitments"].push(item.toJSON());
        }
        return data;
    }

    clone(): PosmInvestmentDto {
        const json = this.toJSON();
        let result = new PosmInvestmentDto();
        result.init(json);
        return result;
    }
}

export interface IPosmInvestmentDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    customerId?: number;
    customerLocationName?: string | undefined;
    customerLocationId?: number;
    registerStaffId?: number;
    registerDate?: Date;
    budgetId?: number;
    currentSalesAmount?: number;
    note?: string | undefined;
    setupContact1?: string | undefined;
    setupContact2?: string | undefined;
    investmentAmount?: number;
    cycleId?: number;
    shopPanelPhoto1?: string | undefined;
    shopPanelPhoto2?: string | undefined;
    shopPanelPhoto3?: string | undefined;
    shopPanelPhoto4?: string | undefined;
    visibilityPhoto1?: string | undefined;
    visibilityPhoto2?: string | undefined;
    visibilityPhoto3?: string | undefined;
    visibilityPhoto4?: string | undefined;
    visibilityCompetitorPhoto1?: string | undefined;
    visibilityCompetitorPhoto2?: string | undefined;
    visibilityCompetitorPhoto3?: string | undefined;
    visibilityCompetitorPhoto4?: string | undefined;
    approveNote?: string | undefined;
    commitmentAmount?: number;
    cancelReason?: string | undefined;
    customerName?: string | undefined;
    customerCode?: string | undefined;
    efficient?: number | undefined;
    mobilePhone?: string | undefined;
    address?: string | undefined;
    status?: number;
    items?: PosmInvestmentItemDto[] | undefined;
    salesCommitments?: PosmSalesCommitmentDto[] | undefined;
}

export class PosmInvestmentDtoApiResultObject implements IPosmInvestmentDtoApiResultObject {
    result?: PosmInvestmentDto;
    success?: boolean;

    constructor(data?: IPosmInvestmentDtoApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? PosmInvestmentDto.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): PosmInvestmentDtoApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new PosmInvestmentDtoApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data;
    }

    clone(): PosmInvestmentDtoApiResultObject {
        const json = this.toJSON();
        let result = new PosmInvestmentDtoApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IPosmInvestmentDtoApiResultObject {
    result?: PosmInvestmentDto;
    success?: boolean;
}

export class PosmInvestmentItemDto implements IPosmInvestmentItemDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    posmClassId?: number;
    posmItemId?: number;
    posmItemCode?: string | undefined;
    posmItemName?: string | undefined;
    panelShopName?: string | undefined;
    panelShopPhone?: string | undefined;
    panelShopAddress?: string | undefined;
    panelOtherInfo?: string | undefined;
    panelProductLine?: string | undefined;
    posmCatalogId?: number;
    width?: number | undefined;
    height?: number | undefined;
    depth?: number | undefined;
    sideWidth1?: number | undefined;
    sideWidth2?: number | undefined;
    qty?: number;
    unitPrice?: number;
    actualUnitPrice?: number | undefined;
    totalCost?: number;
    actualTotalCost?: number | undefined;
    size?: number | undefined;
    posmValue?: number;
    setupPlanDate?: Date;
    status?: PosmInvestmentItemStatus;
    requestType?: PosmRequestType;
    unitType?: PosmUnitType;
    calcType?: PosmCalcType;
    inclueInfo?: boolean;
    requestReason?: string | undefined;
    photo1?: string | undefined;
    photo2?: string | undefined;
    photo3?: string | undefined;
    photo4?: string | undefined;
    posmInvestmentId?: number;
    prepareNote?: string | undefined;
    prepareDate?: Date | undefined;
    updateCostReason?: string | undefined;
    operationPhoto1?: string | undefined;
    operationPhoto2?: string | undefined;
    operationPhoto3?: string | undefined;
    operationPhoto4?: string | undefined;
    operationLink?: string | undefined;
    operationNote?: string | undefined;
    operationDate?: Date | undefined;
    acceptancePhoto1?: string | undefined;
    acceptancePhoto2?: string | undefined;
    acceptancePhoto3?: string | undefined;
    acceptancePhoto4?: string | undefined;
    acceptanceDate?: Date | undefined;
    acceptanceNote?: string | undefined;
    vendorId?: number | undefined;
    remarkOfSales?: number | undefined;
    remarkOfCompany?: number | undefined;

    constructor(data?: IPosmInvestmentItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.posmClassId = _data["posmClassId"];
            this.posmItemId = _data["posmItemId"];
            this.posmItemCode = _data["posmItemCode"];
            this.posmItemName = _data["posmItemName"];
            this.panelShopName = _data["panelShopName"];
            this.panelShopPhone = _data["panelShopPhone"];
            this.panelShopAddress = _data["panelShopAddress"];
            this.panelOtherInfo = _data["panelOtherInfo"];
            this.panelProductLine = _data["panelProductLine"];
            this.posmCatalogId = _data["posmCatalogId"];
            this.width = _data["width"];
            this.height = _data["height"];
            this.depth = _data["depth"];
            this.sideWidth1 = _data["sideWidth1"];
            this.sideWidth2 = _data["sideWidth2"];
            this.qty = _data["qty"];
            this.unitPrice = _data["unitPrice"];
            this.actualUnitPrice = _data["actualUnitPrice"];
            this.totalCost = _data["totalCost"];
            this.actualTotalCost = _data["actualTotalCost"];
            this.size = _data["size"];
            this.posmValue = _data["posmValue"];
            this.setupPlanDate = _data["setupPlanDate"] ? new Date(_data["setupPlanDate"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.requestType = _data["requestType"];
            this.unitType = _data["unitType"];
            this.calcType = _data["calcType"];
            this.inclueInfo = _data["inclueInfo"];
            this.requestReason = _data["requestReason"];
            this.photo1 = _data["photo1"];
            this.photo2 = _data["photo2"];
            this.photo3 = _data["photo3"];
            this.photo4 = _data["photo4"];
            this.posmInvestmentId = _data["posmInvestmentId"];
            this.prepareNote = _data["prepareNote"];
            this.prepareDate = _data["prepareDate"] ? new Date(_data["prepareDate"].toString()) : <any>undefined;
            this.updateCostReason = _data["updateCostReason"];
            this.operationPhoto1 = _data["operationPhoto1"];
            this.operationPhoto2 = _data["operationPhoto2"];
            this.operationPhoto3 = _data["operationPhoto3"];
            this.operationPhoto4 = _data["operationPhoto4"];
            this.operationLink = _data["operationLink"];
            this.operationNote = _data["operationNote"];
            this.operationDate = _data["operationDate"] ? new Date(_data["operationDate"].toString()) : <any>undefined;
            this.acceptancePhoto1 = _data["acceptancePhoto1"];
            this.acceptancePhoto2 = _data["acceptancePhoto2"];
            this.acceptancePhoto3 = _data["acceptancePhoto3"];
            this.acceptancePhoto4 = _data["acceptancePhoto4"];
            this.acceptanceDate = _data["acceptanceDate"] ? new Date(_data["acceptanceDate"].toString()) : <any>undefined;
            this.acceptanceNote = _data["acceptanceNote"];
            this.vendorId = _data["vendorId"];
            this.remarkOfSales = _data["remarkOfSales"];
            this.remarkOfCompany = _data["remarkOfCompany"];
        }
    }

    static fromJS(data: any): PosmInvestmentItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new PosmInvestmentItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["posmClassId"] = this.posmClassId;
        data["posmItemId"] = this.posmItemId;
        data["posmItemCode"] = this.posmItemCode;
        data["posmItemName"] = this.posmItemName;
        data["panelShopName"] = this.panelShopName;
        data["panelShopPhone"] = this.panelShopPhone;
        data["panelShopAddress"] = this.panelShopAddress;
        data["panelOtherInfo"] = this.panelOtherInfo;
        data["panelProductLine"] = this.panelProductLine;
        data["posmCatalogId"] = this.posmCatalogId;
        data["width"] = this.width;
        data["height"] = this.height;
        data["depth"] = this.depth;
        data["sideWidth1"] = this.sideWidth1;
        data["sideWidth2"] = this.sideWidth2;
        data["qty"] = this.qty;
        data["unitPrice"] = this.unitPrice;
        data["actualUnitPrice"] = this.actualUnitPrice;
        data["totalCost"] = this.totalCost;
        data["actualTotalCost"] = this.actualTotalCost;
        data["size"] = this.size;
        data["posmValue"] = this.posmValue;
        data["setupPlanDate"] = this.setupPlanDate ? this.setupPlanDate.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["requestType"] = this.requestType;
        data["unitType"] = this.unitType;
        data["calcType"] = this.calcType;
        data["inclueInfo"] = this.inclueInfo;
        data["requestReason"] = this.requestReason;
        data["photo1"] = this.photo1;
        data["photo2"] = this.photo2;
        data["photo3"] = this.photo3;
        data["photo4"] = this.photo4;
        data["posmInvestmentId"] = this.posmInvestmentId;
        data["prepareNote"] = this.prepareNote;
        data["prepareDate"] = this.prepareDate ? this.prepareDate.toISOString() : <any>undefined;
        data["updateCostReason"] = this.updateCostReason;
        data["operationPhoto1"] = this.operationPhoto1;
        data["operationPhoto2"] = this.operationPhoto2;
        data["operationPhoto3"] = this.operationPhoto3;
        data["operationPhoto4"] = this.operationPhoto4;
        data["operationLink"] = this.operationLink;
        data["operationNote"] = this.operationNote;
        data["operationDate"] = this.operationDate ? this.operationDate.toISOString() : <any>undefined;
        data["acceptancePhoto1"] = this.acceptancePhoto1;
        data["acceptancePhoto2"] = this.acceptancePhoto2;
        data["acceptancePhoto3"] = this.acceptancePhoto3;
        data["acceptancePhoto4"] = this.acceptancePhoto4;
        data["acceptanceDate"] = this.acceptanceDate ? this.acceptanceDate.toISOString() : <any>undefined;
        data["acceptanceNote"] = this.acceptanceNote;
        data["vendorId"] = this.vendorId;
        data["remarkOfSales"] = this.remarkOfSales;
        data["remarkOfCompany"] = this.remarkOfCompany;
        return data;
    }

    clone(): PosmInvestmentItemDto {
        const json = this.toJSON();
        let result = new PosmInvestmentItemDto();
        result.init(json);
        return result;
    }
}

export interface IPosmInvestmentItemDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    posmClassId?: number;
    posmItemId?: number;
    posmItemCode?: string | undefined;
    posmItemName?: string | undefined;
    panelShopName?: string | undefined;
    panelShopPhone?: string | undefined;
    panelShopAddress?: string | undefined;
    panelOtherInfo?: string | undefined;
    panelProductLine?: string | undefined;
    posmCatalogId?: number;
    width?: number | undefined;
    height?: number | undefined;
    depth?: number | undefined;
    sideWidth1?: number | undefined;
    sideWidth2?: number | undefined;
    qty?: number;
    unitPrice?: number;
    actualUnitPrice?: number | undefined;
    totalCost?: number;
    actualTotalCost?: number | undefined;
    size?: number | undefined;
    posmValue?: number;
    setupPlanDate?: Date;
    status?: PosmInvestmentItemStatus;
    requestType?: PosmRequestType;
    unitType?: PosmUnitType;
    calcType?: PosmCalcType;
    inclueInfo?: boolean;
    requestReason?: string | undefined;
    photo1?: string | undefined;
    photo2?: string | undefined;
    photo3?: string | undefined;
    photo4?: string | undefined;
    posmInvestmentId?: number;
    prepareNote?: string | undefined;
    prepareDate?: Date | undefined;
    updateCostReason?: string | undefined;
    operationPhoto1?: string | undefined;
    operationPhoto2?: string | undefined;
    operationPhoto3?: string | undefined;
    operationPhoto4?: string | undefined;
    operationLink?: string | undefined;
    operationNote?: string | undefined;
    operationDate?: Date | undefined;
    acceptancePhoto1?: string | undefined;
    acceptancePhoto2?: string | undefined;
    acceptancePhoto3?: string | undefined;
    acceptancePhoto4?: string | undefined;
    acceptanceDate?: Date | undefined;
    acceptanceNote?: string | undefined;
    vendorId?: number | undefined;
    remarkOfSales?: number | undefined;
    remarkOfCompany?: number | undefined;
}

export class PosmInvestmentItemDtoApiResultObject implements IPosmInvestmentItemDtoApiResultObject {
    result?: PosmInvestmentItemDto;
    success?: boolean;

    constructor(data?: IPosmInvestmentItemDtoApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? PosmInvestmentItemDto.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): PosmInvestmentItemDtoApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new PosmInvestmentItemDtoApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data;
    }

    clone(): PosmInvestmentItemDtoApiResultObject {
        const json = this.toJSON();
        let result = new PosmInvestmentItemDtoApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IPosmInvestmentItemDtoApiResultObject {
    result?: PosmInvestmentItemDto;
    success?: boolean;
}

export class PosmInvestmentItemExtDto implements IPosmInvestmentItemExtDto {
    code?: string | undefined;
    registerDate?: Date;
    posmInvestmentItemId?: number;
    posmItemCode?: string | undefined;
    posmItemName?: string | undefined;
    investmentAmount?: number;
    itemStatus?: PosmInvestmentItemStatus;
    status?: PosmInvestmentStatus;
    posmInvestmentCode?: string | undefined;
    posmInvestmentId?: number;
    posmItemId?: number;
    customerId?: number;
    customerCode?: string | undefined;
    customerName?: string | undefined;
    email?: string | undefined;
    mobilePhone?: string | undefined;
    address?: string | undefined;
    actualTotalCost?: number | undefined;
    totalCost?: number;
    qty?: number;
    unitPrice?: number;

    constructor(data?: IPosmInvestmentItemExtDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.registerDate = _data["registerDate"] ? new Date(_data["registerDate"].toString()) : <any>undefined;
            this.posmInvestmentItemId = _data["posmInvestmentItemId"];
            this.posmItemCode = _data["posmItemCode"];
            this.posmItemName = _data["posmItemName"];
            this.investmentAmount = _data["investmentAmount"];
            this.itemStatus = _data["itemStatus"];
            this.status = _data["status"];
            this.posmInvestmentCode = _data["posmInvestmentCode"];
            this.posmInvestmentId = _data["posmInvestmentId"];
            this.posmItemId = _data["posmItemId"];
            this.customerId = _data["customerId"];
            this.customerCode = _data["customerCode"];
            this.customerName = _data["customerName"];
            this.email = _data["email"];
            this.mobilePhone = _data["mobilePhone"];
            this.address = _data["address"];
            this.actualTotalCost = _data["actualTotalCost"];
            this.totalCost = _data["totalCost"];
            this.qty = _data["qty"];
            this.unitPrice = _data["unitPrice"];
        }
    }

    static fromJS(data: any): PosmInvestmentItemExtDto {
        data = typeof data === 'object' ? data : {};
        let result = new PosmInvestmentItemExtDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["registerDate"] = this.registerDate ? this.registerDate.toISOString() : <any>undefined;
        data["posmInvestmentItemId"] = this.posmInvestmentItemId;
        data["posmItemCode"] = this.posmItemCode;
        data["posmItemName"] = this.posmItemName;
        data["investmentAmount"] = this.investmentAmount;
        data["itemStatus"] = this.itemStatus;
        data["status"] = this.status;
        data["posmInvestmentCode"] = this.posmInvestmentCode;
        data["posmInvestmentId"] = this.posmInvestmentId;
        data["posmItemId"] = this.posmItemId;
        data["customerId"] = this.customerId;
        data["customerCode"] = this.customerCode;
        data["customerName"] = this.customerName;
        data["email"] = this.email;
        data["mobilePhone"] = this.mobilePhone;
        data["address"] = this.address;
        data["actualTotalCost"] = this.actualTotalCost;
        data["totalCost"] = this.totalCost;
        data["qty"] = this.qty;
        data["unitPrice"] = this.unitPrice;
        return data;
    }

    clone(): PosmInvestmentItemExtDto {
        const json = this.toJSON();
        let result = new PosmInvestmentItemExtDto();
        result.init(json);
        return result;
    }
}

export interface IPosmInvestmentItemExtDto {
    code?: string | undefined;
    registerDate?: Date;
    posmInvestmentItemId?: number;
    posmItemCode?: string | undefined;
    posmItemName?: string | undefined;
    investmentAmount?: number;
    itemStatus?: PosmInvestmentItemStatus;
    status?: PosmInvestmentStatus;
    posmInvestmentCode?: string | undefined;
    posmInvestmentId?: number;
    posmItemId?: number;
    customerId?: number;
    customerCode?: string | undefined;
    customerName?: string | undefined;
    email?: string | undefined;
    mobilePhone?: string | undefined;
    address?: string | undefined;
    actualTotalCost?: number | undefined;
    totalCost?: number;
    qty?: number;
    unitPrice?: number;
}

export class PosmInvestmentItemExtDtoPagingResult implements IPosmInvestmentItemExtDtoPagingResult {
    items?: PosmInvestmentItemExtDto[] | undefined;
    totalCount?: number;

    constructor(data?: IPosmInvestmentItemExtDtoPagingResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PosmInvestmentItemExtDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PosmInvestmentItemExtDtoPagingResult {
        data = typeof data === 'object' ? data : {};
        let result = new PosmInvestmentItemExtDtoPagingResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): PosmInvestmentItemExtDtoPagingResult {
        const json = this.toJSON();
        let result = new PosmInvestmentItemExtDtoPagingResult();
        result.init(json);
        return result;
    }
}

export interface IPosmInvestmentItemExtDtoPagingResult {
    items?: PosmInvestmentItemExtDto[] | undefined;
    totalCount?: number;
}

export class PosmInvestmentItemExtDtoPagingResultApiResultObject implements IPosmInvestmentItemExtDtoPagingResultApiResultObject {
    result?: PosmInvestmentItemExtDtoPagingResult;
    success?: boolean;

    constructor(data?: IPosmInvestmentItemExtDtoPagingResultApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? PosmInvestmentItemExtDtoPagingResult.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): PosmInvestmentItemExtDtoPagingResultApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new PosmInvestmentItemExtDtoPagingResultApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data;
    }

    clone(): PosmInvestmentItemExtDtoPagingResultApiResultObject {
        const json = this.toJSON();
        let result = new PosmInvestmentItemExtDtoPagingResultApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IPosmInvestmentItemExtDtoPagingResultApiResultObject {
    result?: PosmInvestmentItemExtDtoPagingResult;
    success?: boolean;
}

export class PosmInvestmentItemHistoryDto implements IPosmInvestmentItemHistoryDto {
    requestItems?: PosmInvestmnetItemHistoryItemDto[] | undefined;
    approveItems?: PosmInvestmnetItemHistoryItemDto[] | undefined;
    prepareItems?: PosmInvestmnetItemHistoryItemDto[] | undefined;
    operationItems?: PosmInvestmnetItemHistoryItemDto[] | undefined;
    acceptanceItems?: PosmInvestmnetItemHistoryItemDto[] | undefined;

    constructor(data?: IPosmInvestmentItemHistoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["requestItems"])) {
                this.requestItems = [] as any;
                for (let item of _data["requestItems"])
                    this.requestItems!.push(PosmInvestmnetItemHistoryItemDto.fromJS(item));
            }
            if (Array.isArray(_data["approveItems"])) {
                this.approveItems = [] as any;
                for (let item of _data["approveItems"])
                    this.approveItems!.push(PosmInvestmnetItemHistoryItemDto.fromJS(item));
            }
            if (Array.isArray(_data["prepareItems"])) {
                this.prepareItems = [] as any;
                for (let item of _data["prepareItems"])
                    this.prepareItems!.push(PosmInvestmnetItemHistoryItemDto.fromJS(item));
            }
            if (Array.isArray(_data["operationItems"])) {
                this.operationItems = [] as any;
                for (let item of _data["operationItems"])
                    this.operationItems!.push(PosmInvestmnetItemHistoryItemDto.fromJS(item));
            }
            if (Array.isArray(_data["acceptanceItems"])) {
                this.acceptanceItems = [] as any;
                for (let item of _data["acceptanceItems"])
                    this.acceptanceItems!.push(PosmInvestmnetItemHistoryItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PosmInvestmentItemHistoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new PosmInvestmentItemHistoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.requestItems)) {
            data["requestItems"] = [];
            for (let item of this.requestItems)
                data["requestItems"].push(item.toJSON());
        }
        if (Array.isArray(this.approveItems)) {
            data["approveItems"] = [];
            for (let item of this.approveItems)
                data["approveItems"].push(item.toJSON());
        }
        if (Array.isArray(this.prepareItems)) {
            data["prepareItems"] = [];
            for (let item of this.prepareItems)
                data["prepareItems"].push(item.toJSON());
        }
        if (Array.isArray(this.operationItems)) {
            data["operationItems"] = [];
            for (let item of this.operationItems)
                data["operationItems"].push(item.toJSON());
        }
        if (Array.isArray(this.acceptanceItems)) {
            data["acceptanceItems"] = [];
            for (let item of this.acceptanceItems)
                data["acceptanceItems"].push(item.toJSON());
        }
        return data;
    }

    clone(): PosmInvestmentItemHistoryDto {
        const json = this.toJSON();
        let result = new PosmInvestmentItemHistoryDto();
        result.init(json);
        return result;
    }
}

export interface IPosmInvestmentItemHistoryDto {
    requestItems?: PosmInvestmnetItemHistoryItemDto[] | undefined;
    approveItems?: PosmInvestmnetItemHistoryItemDto[] | undefined;
    prepareItems?: PosmInvestmnetItemHistoryItemDto[] | undefined;
    operationItems?: PosmInvestmnetItemHistoryItemDto[] | undefined;
    acceptanceItems?: PosmInvestmnetItemHistoryItemDto[] | undefined;
}

export class PosmInvestmentItemHistoryDtoApiResultObject implements IPosmInvestmentItemHistoryDtoApiResultObject {
    result?: PosmInvestmentItemHistoryDto;
    success?: boolean;

    constructor(data?: IPosmInvestmentItemHistoryDtoApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? PosmInvestmentItemHistoryDto.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): PosmInvestmentItemHistoryDtoApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new PosmInvestmentItemHistoryDtoApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data;
    }

    clone(): PosmInvestmentItemHistoryDtoApiResultObject {
        const json = this.toJSON();
        let result = new PosmInvestmentItemHistoryDtoApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IPosmInvestmentItemHistoryDtoApiResultObject {
    result?: PosmInvestmentItemHistoryDto;
    success?: boolean;
}

export class PosmInvestmentItemOperationDto implements IPosmInvestmentItemOperationDto {
    id?: number;
    posmCatalogId?: number;
    operationPhoto1?: string | undefined;
    operationPhoto2?: string | undefined;
    operationPhoto3?: string | undefined;
    operationPhoto4?: string | undefined;
    operationLink?: string | undefined;
    operationNote?: string | undefined;
    operationDate?: Date | undefined;
    confirmUserName?: string | undefined;

    constructor(data?: IPosmInvestmentItemOperationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.posmCatalogId = _data["posmCatalogId"];
            this.operationPhoto1 = _data["operationPhoto1"];
            this.operationPhoto2 = _data["operationPhoto2"];
            this.operationPhoto3 = _data["operationPhoto3"];
            this.operationPhoto4 = _data["operationPhoto4"];
            this.operationLink = _data["operationLink"];
            this.operationNote = _data["operationNote"];
            this.operationDate = _data["operationDate"] ? new Date(_data["operationDate"].toString()) : <any>undefined;
            this.confirmUserName = _data["confirmUserName"];
        }
    }

    static fromJS(data: any): PosmInvestmentItemOperationDto {
        data = typeof data === 'object' ? data : {};
        let result = new PosmInvestmentItemOperationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["posmCatalogId"] = this.posmCatalogId;
        data["operationPhoto1"] = this.operationPhoto1;
        data["operationPhoto2"] = this.operationPhoto2;
        data["operationPhoto3"] = this.operationPhoto3;
        data["operationPhoto4"] = this.operationPhoto4;
        data["operationLink"] = this.operationLink;
        data["operationNote"] = this.operationNote;
        data["operationDate"] = this.operationDate ? this.operationDate.toISOString() : <any>undefined;
        data["confirmUserName"] = this.confirmUserName;
        return data;
    }

    clone(): PosmInvestmentItemOperationDto {
        const json = this.toJSON();
        let result = new PosmInvestmentItemOperationDto();
        result.init(json);
        return result;
    }
}

export interface IPosmInvestmentItemOperationDto {
    id?: number;
    posmCatalogId?: number;
    operationPhoto1?: string | undefined;
    operationPhoto2?: string | undefined;
    operationPhoto3?: string | undefined;
    operationPhoto4?: string | undefined;
    operationLink?: string | undefined;
    operationNote?: string | undefined;
    operationDate?: Date | undefined;
    confirmUserName?: string | undefined;
}

export class PosmInvestmentItemOperationDtoApiResultObject implements IPosmInvestmentItemOperationDtoApiResultObject {
    result?: PosmInvestmentItemOperationDto;
    success?: boolean;

    constructor(data?: IPosmInvestmentItemOperationDtoApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? PosmInvestmentItemOperationDto.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): PosmInvestmentItemOperationDtoApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new PosmInvestmentItemOperationDtoApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data;
    }

    clone(): PosmInvestmentItemOperationDtoApiResultObject {
        const json = this.toJSON();
        let result = new PosmInvestmentItemOperationDtoApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IPosmInvestmentItemOperationDtoApiResultObject {
    result?: PosmInvestmentItemOperationDto;
    success?: boolean;
}

export enum PosmInvestmentItemStatus {
    _10 = 10,
    _20 = 20,
    _30 = 30,
    _40 = 40,
    _50 = 50,
    _60 = 60,
    _70 = 70,
    _80 = 80,
    _90 = 90,
    _100 = 100,
    _110 = 110,
    _120 = 120,
    _130 = 130,
    _140 = 140,
    _150 = 150,
    _160 = 160,
    _170 = 170,
    _180 = 180,
    _190 = 190,
    _200 = 200,
    _210 = 210,
}

export class PosmInvestmentListDto implements IPosmInvestmentListDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    customerId?: number;
    customerCode?: string | undefined;
    customerName?: string | undefined;
    email?: string | undefined;
    mobilePhone?: string | undefined;
    address?: string | undefined;
    registerStaffId?: number;
    registerStaffName?: string | undefined;
    budgetId?: number;
    customerLocationId?: number;
    currentSalesAmount?: number;
    investmentAmount?: number;
    cycleId?: number;
    status?: PosmInvestmentStatus;
    areaName?: string | undefined;
    zoneName?: string | undefined;

    constructor(data?: IPosmInvestmentListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.customerId = _data["customerId"];
            this.customerCode = _data["customerCode"];
            this.customerName = _data["customerName"];
            this.email = _data["email"];
            this.mobilePhone = _data["mobilePhone"];
            this.address = _data["address"];
            this.registerStaffId = _data["registerStaffId"];
            this.registerStaffName = _data["registerStaffName"];
            this.budgetId = _data["budgetId"];
            this.customerLocationId = _data["customerLocationId"];
            this.currentSalesAmount = _data["currentSalesAmount"];
            this.investmentAmount = _data["investmentAmount"];
            this.cycleId = _data["cycleId"];
            this.status = _data["status"];
            this.areaName = _data["areaName"];
            this.zoneName = _data["zoneName"];
        }
    }

    static fromJS(data: any): PosmInvestmentListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PosmInvestmentListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["customerId"] = this.customerId;
        data["customerCode"] = this.customerCode;
        data["customerName"] = this.customerName;
        data["email"] = this.email;
        data["mobilePhone"] = this.mobilePhone;
        data["address"] = this.address;
        data["registerStaffId"] = this.registerStaffId;
        data["registerStaffName"] = this.registerStaffName;
        data["budgetId"] = this.budgetId;
        data["customerLocationId"] = this.customerLocationId;
        data["currentSalesAmount"] = this.currentSalesAmount;
        data["investmentAmount"] = this.investmentAmount;
        data["cycleId"] = this.cycleId;
        data["status"] = this.status;
        data["areaName"] = this.areaName;
        data["zoneName"] = this.zoneName;
        return data;
    }

    clone(): PosmInvestmentListDto {
        const json = this.toJSON();
        let result = new PosmInvestmentListDto();
        result.init(json);
        return result;
    }
}

export interface IPosmInvestmentListDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    customerId?: number;
    customerCode?: string | undefined;
    customerName?: string | undefined;
    email?: string | undefined;
    mobilePhone?: string | undefined;
    address?: string | undefined;
    registerStaffId?: number;
    registerStaffName?: string | undefined;
    budgetId?: number;
    customerLocationId?: number;
    currentSalesAmount?: number;
    investmentAmount?: number;
    cycleId?: number;
    status?: PosmInvestmentStatus;
    areaName?: string | undefined;
    zoneName?: string | undefined;
}

export class PosmInvestmentListDtoPagingResult implements IPosmInvestmentListDtoPagingResult {
    items?: PosmInvestmentListDto[] | undefined;
    totalCount?: number;

    constructor(data?: IPosmInvestmentListDtoPagingResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PosmInvestmentListDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PosmInvestmentListDtoPagingResult {
        data = typeof data === 'object' ? data : {};
        let result = new PosmInvestmentListDtoPagingResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): PosmInvestmentListDtoPagingResult {
        const json = this.toJSON();
        let result = new PosmInvestmentListDtoPagingResult();
        result.init(json);
        return result;
    }
}

export interface IPosmInvestmentListDtoPagingResult {
    items?: PosmInvestmentListDto[] | undefined;
    totalCount?: number;
}

export class PosmInvestmentListDtoPagingResultApiResultObject implements IPosmInvestmentListDtoPagingResultApiResultObject {
    result?: PosmInvestmentListDtoPagingResult;
    success?: boolean;

    constructor(data?: IPosmInvestmentListDtoPagingResultApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? PosmInvestmentListDtoPagingResult.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): PosmInvestmentListDtoPagingResultApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new PosmInvestmentListDtoPagingResultApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data;
    }

    clone(): PosmInvestmentListDtoPagingResultApiResultObject {
        const json = this.toJSON();
        let result = new PosmInvestmentListDtoPagingResultApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IPosmInvestmentListDtoPagingResultApiResultObject {
    result?: PosmInvestmentListDtoPagingResult;
    success?: boolean;
}

export class PosmInvestmentMarketingConfirmProduceCommand implements IPosmInvestmentMarketingConfirmProduceCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: PosmInvestmentMarketingConfirmProduceDto;

    constructor(data?: IPosmInvestmentMarketingConfirmProduceCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? PosmInvestmentMarketingConfirmProduceDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PosmInvestmentMarketingConfirmProduceCommand {
        data = typeof data === 'object' ? data : {};
        let result = new PosmInvestmentMarketingConfirmProduceCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }

    clone(): PosmInvestmentMarketingConfirmProduceCommand {
        const json = this.toJSON();
        let result = new PosmInvestmentMarketingConfirmProduceCommand();
        result.init(json);
        return result;
    }
}

export interface IPosmInvestmentMarketingConfirmProduceCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: PosmInvestmentMarketingConfirmProduceDto;
}

export class PosmInvestmentMarketingConfirmProduceDto implements IPosmInvestmentMarketingConfirmProduceDto {
    posmInvestmentItemId?: number;
    photo1?: string | undefined;
    photo2?: string | undefined;
    photo3?: string | undefined;
    photo4?: string | undefined;
    link?: string | undefined;
    note?: string | undefined;
    id?: number;

    constructor(data?: IPosmInvestmentMarketingConfirmProduceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.posmInvestmentItemId = _data["posmInvestmentItemId"];
            this.photo1 = _data["photo1"];
            this.photo2 = _data["photo2"];
            this.photo3 = _data["photo3"];
            this.photo4 = _data["photo4"];
            this.link = _data["link"];
            this.note = _data["note"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PosmInvestmentMarketingConfirmProduceDto {
        data = typeof data === 'object' ? data : {};
        let result = new PosmInvestmentMarketingConfirmProduceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["posmInvestmentItemId"] = this.posmInvestmentItemId;
        data["photo1"] = this.photo1;
        data["photo2"] = this.photo2;
        data["photo3"] = this.photo3;
        data["photo4"] = this.photo4;
        data["link"] = this.link;
        data["note"] = this.note;
        data["id"] = this.id;
        return data;
    }

    clone(): PosmInvestmentMarketingConfirmProduceDto {
        const json = this.toJSON();
        let result = new PosmInvestmentMarketingConfirmProduceDto();
        result.init(json);
        return result;
    }
}

export interface IPosmInvestmentMarketingConfirmProduceDto {
    posmInvestmentItemId?: number;
    photo1?: string | undefined;
    photo2?: string | undefined;
    photo3?: string | undefined;
    photo4?: string | undefined;
    link?: string | undefined;
    note?: string | undefined;
    id?: number;
}

export class PosmInvestmentRegisterCommand implements IPosmInvestmentRegisterCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: PosmInvestmentRegisterDto;

    constructor(data?: IPosmInvestmentRegisterCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? PosmInvestmentRegisterDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PosmInvestmentRegisterCommand {
        data = typeof data === 'object' ? data : {};
        let result = new PosmInvestmentRegisterCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }

    clone(): PosmInvestmentRegisterCommand {
        const json = this.toJSON();
        let result = new PosmInvestmentRegisterCommand();
        result.init(json);
        return result;
    }
}

export interface IPosmInvestmentRegisterCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: PosmInvestmentRegisterDto;
}

export class PosmInvestmentRegisterDto implements IPosmInvestmentRegisterDto {
    customerId?: number;
    customerLocationId?: number;
    currentSalesAmount?: number;
    shopPanelPhoto1?: string | undefined;
    shopPanelPhoto2?: string | undefined;
    shopPanelPhoto3?: string | undefined;
    shopPanelPhoto4?: string | undefined;
    visibilityPhoto1?: string | undefined;
    visibilityPhoto2?: string | undefined;
    visibilityPhoto3?: string | undefined;
    visibilityPhoto4?: string | undefined;
    visibilityCompetitorPhoto1?: string | undefined;
    visibilityCompetitorPhoto2?: string | undefined;
    visibilityCompetitorPhoto3?: string | undefined;
    visibilityCompetitorPhoto4?: string | undefined;
    note?: string | undefined;
    setupContact1?: string | undefined;
    setupContact2?: string | undefined;
    salesCommitments?: PosmInvestmentRegisterSalesCommitmentDto[] | undefined;
    items?: PosmInvestmentRegisterItemDto[] | undefined;

    constructor(data?: IPosmInvestmentRegisterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.customerId = _data["customerId"];
            this.customerLocationId = _data["customerLocationId"];
            this.currentSalesAmount = _data["currentSalesAmount"];
            this.shopPanelPhoto1 = _data["shopPanelPhoto1"];
            this.shopPanelPhoto2 = _data["shopPanelPhoto2"];
            this.shopPanelPhoto3 = _data["shopPanelPhoto3"];
            this.shopPanelPhoto4 = _data["shopPanelPhoto4"];
            this.visibilityPhoto1 = _data["visibilityPhoto1"];
            this.visibilityPhoto2 = _data["visibilityPhoto2"];
            this.visibilityPhoto3 = _data["visibilityPhoto3"];
            this.visibilityPhoto4 = _data["visibilityPhoto4"];
            this.visibilityCompetitorPhoto1 = _data["visibilityCompetitorPhoto1"];
            this.visibilityCompetitorPhoto2 = _data["visibilityCompetitorPhoto2"];
            this.visibilityCompetitorPhoto3 = _data["visibilityCompetitorPhoto3"];
            this.visibilityCompetitorPhoto4 = _data["visibilityCompetitorPhoto4"];
            this.note = _data["note"];
            this.setupContact1 = _data["setupContact1"];
            this.setupContact2 = _data["setupContact2"];
            if (Array.isArray(_data["salesCommitments"])) {
                this.salesCommitments = [] as any;
                for (let item of _data["salesCommitments"])
                    this.salesCommitments!.push(PosmInvestmentRegisterSalesCommitmentDto.fromJS(item));
            }
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PosmInvestmentRegisterItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PosmInvestmentRegisterDto {
        data = typeof data === 'object' ? data : {};
        let result = new PosmInvestmentRegisterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerId"] = this.customerId;
        data["customerLocationId"] = this.customerLocationId;
        data["currentSalesAmount"] = this.currentSalesAmount;
        data["shopPanelPhoto1"] = this.shopPanelPhoto1;
        data["shopPanelPhoto2"] = this.shopPanelPhoto2;
        data["shopPanelPhoto3"] = this.shopPanelPhoto3;
        data["shopPanelPhoto4"] = this.shopPanelPhoto4;
        data["visibilityPhoto1"] = this.visibilityPhoto1;
        data["visibilityPhoto2"] = this.visibilityPhoto2;
        data["visibilityPhoto3"] = this.visibilityPhoto3;
        data["visibilityPhoto4"] = this.visibilityPhoto4;
        data["visibilityCompetitorPhoto1"] = this.visibilityCompetitorPhoto1;
        data["visibilityCompetitorPhoto2"] = this.visibilityCompetitorPhoto2;
        data["visibilityCompetitorPhoto3"] = this.visibilityCompetitorPhoto3;
        data["visibilityCompetitorPhoto4"] = this.visibilityCompetitorPhoto4;
        data["note"] = this.note;
        data["setupContact1"] = this.setupContact1;
        data["setupContact2"] = this.setupContact2;
        if (Array.isArray(this.salesCommitments)) {
            data["salesCommitments"] = [];
            for (let item of this.salesCommitments)
                data["salesCommitments"].push(item.toJSON());
        }
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): PosmInvestmentRegisterDto {
        const json = this.toJSON();
        let result = new PosmInvestmentRegisterDto();
        result.init(json);
        return result;
    }
}

export interface IPosmInvestmentRegisterDto {
    customerId?: number;
    customerLocationId?: number;
    currentSalesAmount?: number;
    shopPanelPhoto1?: string | undefined;
    shopPanelPhoto2?: string | undefined;
    shopPanelPhoto3?: string | undefined;
    shopPanelPhoto4?: string | undefined;
    visibilityPhoto1?: string | undefined;
    visibilityPhoto2?: string | undefined;
    visibilityPhoto3?: string | undefined;
    visibilityPhoto4?: string | undefined;
    visibilityCompetitorPhoto1?: string | undefined;
    visibilityCompetitorPhoto2?: string | undefined;
    visibilityCompetitorPhoto3?: string | undefined;
    visibilityCompetitorPhoto4?: string | undefined;
    note?: string | undefined;
    setupContact1?: string | undefined;
    setupContact2?: string | undefined;
    salesCommitments?: PosmInvestmentRegisterSalesCommitmentDto[] | undefined;
    items?: PosmInvestmentRegisterItemDto[] | undefined;
}

export class PosmInvestmentRegisterItemDto implements IPosmInvestmentRegisterItemDto {
    panelShopName?: string | undefined;
    panelShopPhone?: string | undefined;
    panelShopAddress?: string | undefined;
    panelOtherInfo?: string | undefined;
    panelProductLine?: string | undefined;
    posmCatalogId?: number;
    width?: number | undefined;
    height?: number | undefined;
    depth?: number | undefined;
    sideWidth1?: number | undefined;
    sideWidth2?: number | undefined;
    qty?: number;
    unitPrice?: number;
    setupPlanDate?: Date;
    requestType?: PosmRequestType;
    requestReason?: string | undefined;
    photo1?: string | undefined;
    photo2?: string | undefined;
    photo3?: string | undefined;
    photo4?: string | undefined;

    constructor(data?: IPosmInvestmentRegisterItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.panelShopName = _data["panelShopName"];
            this.panelShopPhone = _data["panelShopPhone"];
            this.panelShopAddress = _data["panelShopAddress"];
            this.panelOtherInfo = _data["panelOtherInfo"];
            this.panelProductLine = _data["panelProductLine"];
            this.posmCatalogId = _data["posmCatalogId"];
            this.width = _data["width"];
            this.height = _data["height"];
            this.depth = _data["depth"];
            this.sideWidth1 = _data["sideWidth1"];
            this.sideWidth2 = _data["sideWidth2"];
            this.qty = _data["qty"];
            this.unitPrice = _data["unitPrice"];
            this.setupPlanDate = _data["setupPlanDate"] ? new Date(_data["setupPlanDate"].toString()) : <any>undefined;
            this.requestType = _data["requestType"];
            this.requestReason = _data["requestReason"];
            this.photo1 = _data["photo1"];
            this.photo2 = _data["photo2"];
            this.photo3 = _data["photo3"];
            this.photo4 = _data["photo4"];
        }
    }

    static fromJS(data: any): PosmInvestmentRegisterItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new PosmInvestmentRegisterItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["panelShopName"] = this.panelShopName;
        data["panelShopPhone"] = this.panelShopPhone;
        data["panelShopAddress"] = this.panelShopAddress;
        data["panelOtherInfo"] = this.panelOtherInfo;
        data["panelProductLine"] = this.panelProductLine;
        data["posmCatalogId"] = this.posmCatalogId;
        data["width"] = this.width;
        data["height"] = this.height;
        data["depth"] = this.depth;
        data["sideWidth1"] = this.sideWidth1;
        data["sideWidth2"] = this.sideWidth2;
        data["qty"] = this.qty;
        data["unitPrice"] = this.unitPrice;
        data["setupPlanDate"] = this.setupPlanDate ? this.setupPlanDate.toISOString() : <any>undefined;
        data["requestType"] = this.requestType;
        data["requestReason"] = this.requestReason;
        data["photo1"] = this.photo1;
        data["photo2"] = this.photo2;
        data["photo3"] = this.photo3;
        data["photo4"] = this.photo4;
        return data;
    }

    clone(): PosmInvestmentRegisterItemDto {
        const json = this.toJSON();
        let result = new PosmInvestmentRegisterItemDto();
        result.init(json);
        return result;
    }
}

export interface IPosmInvestmentRegisterItemDto {
    panelShopName?: string | undefined;
    panelShopPhone?: string | undefined;
    panelShopAddress?: string | undefined;
    panelOtherInfo?: string | undefined;
    panelProductLine?: string | undefined;
    posmCatalogId?: number;
    width?: number | undefined;
    height?: number | undefined;
    depth?: number | undefined;
    sideWidth1?: number | undefined;
    sideWidth2?: number | undefined;
    qty?: number;
    unitPrice?: number;
    setupPlanDate?: Date;
    requestType?: PosmRequestType;
    requestReason?: string | undefined;
    photo1?: string | undefined;
    photo2?: string | undefined;
    photo3?: string | undefined;
    photo4?: string | undefined;
}

export class PosmInvestmentRegisterSalesCommitmentDto implements IPosmInvestmentRegisterSalesCommitmentDto {
    year?: number;
    month?: number;
    amount?: number;

    constructor(data?: IPosmInvestmentRegisterSalesCommitmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.year = _data["year"];
            this.month = _data["month"];
            this.amount = _data["amount"];
        }
    }

    static fromJS(data: any): PosmInvestmentRegisterSalesCommitmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new PosmInvestmentRegisterSalesCommitmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["year"] = this.year;
        data["month"] = this.month;
        data["amount"] = this.amount;
        return data;
    }

    clone(): PosmInvestmentRegisterSalesCommitmentDto {
        const json = this.toJSON();
        let result = new PosmInvestmentRegisterSalesCommitmentDto();
        result.init(json);
        return result;
    }
}

export interface IPosmInvestmentRegisterSalesCommitmentDto {
    year?: number;
    month?: number;
    amount?: number;
}

export class PosmInvestmentRemarkDto implements IPosmInvestmentRemarkDto {
    posmInvestmentId?: number;
    posmInvestmentItemId?: number;
    remark?: number;

    constructor(data?: IPosmInvestmentRemarkDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.posmInvestmentId = _data["posmInvestmentId"];
            this.posmInvestmentItemId = _data["posmInvestmentItemId"];
            this.remark = _data["remark"];
        }
    }

    static fromJS(data: any): PosmInvestmentRemarkDto {
        data = typeof data === 'object' ? data : {};
        let result = new PosmInvestmentRemarkDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["posmInvestmentId"] = this.posmInvestmentId;
        data["posmInvestmentItemId"] = this.posmInvestmentItemId;
        data["remark"] = this.remark;
        return data;
    }

    clone(): PosmInvestmentRemarkDto {
        const json = this.toJSON();
        let result = new PosmInvestmentRemarkDto();
        result.init(json);
        return result;
    }
}

export interface IPosmInvestmentRemarkDto {
    posmInvestmentId?: number;
    posmInvestmentItemId?: number;
    remark?: number;
}

export class PosmInvestmentRsmApproveCommand implements IPosmInvestmentRsmApproveCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: PosmInvestmentRsmApproveDto;

    constructor(data?: IPosmInvestmentRsmApproveCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? PosmInvestmentRsmApproveDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PosmInvestmentRsmApproveCommand {
        data = typeof data === 'object' ? data : {};
        let result = new PosmInvestmentRsmApproveCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }

    clone(): PosmInvestmentRsmApproveCommand {
        const json = this.toJSON();
        let result = new PosmInvestmentRsmApproveCommand();
        result.init(json);
        return result;
    }
}

export interface IPosmInvestmentRsmApproveCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: PosmInvestmentRsmApproveDto;
}

export class PosmInvestmentRsmApproveDto implements IPosmInvestmentRsmApproveDto {
    note?: string | undefined;
    id?: number;

    constructor(data?: IPosmInvestmentRsmApproveDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.note = _data["note"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PosmInvestmentRsmApproveDto {
        data = typeof data === 'object' ? data : {};
        let result = new PosmInvestmentRsmApproveDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["note"] = this.note;
        data["id"] = this.id;
        return data;
    }

    clone(): PosmInvestmentRsmApproveDto {
        const json = this.toJSON();
        let result = new PosmInvestmentRsmApproveDto();
        result.init(json);
        return result;
    }
}

export interface IPosmInvestmentRsmApproveDto {
    note?: string | undefined;
    id?: number;
}

export class PosmInvestmentRsmConfirmSuggesDto implements IPosmInvestmentRsmConfirmSuggesDto {
    posmInvestmentItemId?: number;
    id?: number;

    constructor(data?: IPosmInvestmentRsmConfirmSuggesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.posmInvestmentItemId = _data["posmInvestmentItemId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PosmInvestmentRsmConfirmSuggesDto {
        data = typeof data === 'object' ? data : {};
        let result = new PosmInvestmentRsmConfirmSuggesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["posmInvestmentItemId"] = this.posmInvestmentItemId;
        data["id"] = this.id;
        return data;
    }

    clone(): PosmInvestmentRsmConfirmSuggesDto {
        const json = this.toJSON();
        let result = new PosmInvestmentRsmConfirmSuggesDto();
        result.init(json);
        return result;
    }
}

export interface IPosmInvestmentRsmConfirmSuggesDto {
    posmInvestmentItemId?: number;
    id?: number;
}

export class PosmInvestmentRsmConfirmSuggestCommand implements IPosmInvestmentRsmConfirmSuggestCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: PosmInvestmentRsmConfirmSuggesDto;

    constructor(data?: IPosmInvestmentRsmConfirmSuggestCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? PosmInvestmentRsmConfirmSuggesDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PosmInvestmentRsmConfirmSuggestCommand {
        data = typeof data === 'object' ? data : {};
        let result = new PosmInvestmentRsmConfirmSuggestCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }

    clone(): PosmInvestmentRsmConfirmSuggestCommand {
        const json = this.toJSON();
        let result = new PosmInvestmentRsmConfirmSuggestCommand();
        result.init(json);
        return result;
    }
}

export interface IPosmInvestmentRsmConfirmSuggestCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: PosmInvestmentRsmConfirmSuggesDto;
}

export class PosmInvestmentRsmDenyCommand implements IPosmInvestmentRsmDenyCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: PosmInvestmentRsmDenyDto;

    constructor(data?: IPosmInvestmentRsmDenyCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? PosmInvestmentRsmDenyDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PosmInvestmentRsmDenyCommand {
        data = typeof data === 'object' ? data : {};
        let result = new PosmInvestmentRsmDenyCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }

    clone(): PosmInvestmentRsmDenyCommand {
        const json = this.toJSON();
        let result = new PosmInvestmentRsmDenyCommand();
        result.init(json);
        return result;
    }
}

export interface IPosmInvestmentRsmDenyCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: PosmInvestmentRsmDenyDto;
}

export class PosmInvestmentRsmDenyDto implements IPosmInvestmentRsmDenyDto {
    note?: string | undefined;
    id?: number;

    constructor(data?: IPosmInvestmentRsmDenyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.note = _data["note"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PosmInvestmentRsmDenyDto {
        data = typeof data === 'object' ? data : {};
        let result = new PosmInvestmentRsmDenyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["note"] = this.note;
        data["id"] = this.id;
        return data;
    }

    clone(): PosmInvestmentRsmDenyDto {
        const json = this.toJSON();
        let result = new PosmInvestmentRsmDenyDto();
        result.init(json);
        return result;
    }
}

export interface IPosmInvestmentRsmDenyDto {
    note?: string | undefined;
    id?: number;
}

export class PosmInvestmentSalesRemarkCommand implements IPosmInvestmentSalesRemarkCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: PosmInvestmentRemarkDto;
    handleType?: string | undefined;

    constructor(data?: IPosmInvestmentSalesRemarkCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? PosmInvestmentRemarkDto.fromJS(_data["data"]) : <any>undefined;
            this.handleType = _data["handleType"];
        }
    }

    static fromJS(data: any): PosmInvestmentSalesRemarkCommand {
        data = typeof data === 'object' ? data : {};
        let result = new PosmInvestmentSalesRemarkCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["handleType"] = this.handleType;
        return data;
    }

    clone(): PosmInvestmentSalesRemarkCommand {
        const json = this.toJSON();
        let result = new PosmInvestmentSalesRemarkCommand();
        result.init(json);
        return result;
    }
}

export interface IPosmInvestmentSalesRemarkCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: PosmInvestmentRemarkDto;
    handleType?: string | undefined;
}

export enum PosmInvestmentStatus {
    _10 = 10,
    _20 = 20,
    _30 = 30,
    _40 = 40,
    _50 = 50,
    _60 = 60,
    _70 = 70,
    _80 = 80,
    _90 = 90,
    _100 = 100,
    _150 = 150,
    _160 = 160,
    _170 = 170,
    _180 = 180,
    _190 = 190,
    _200 = 200,
    _210 = 210,
}

export class PosmInvestmentSupAcceptCommand implements IPosmInvestmentSupAcceptCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: PosmInvestmentSupAcceptDto;

    constructor(data?: IPosmInvestmentSupAcceptCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? PosmInvestmentSupAcceptDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PosmInvestmentSupAcceptCommand {
        data = typeof data === 'object' ? data : {};
        let result = new PosmInvestmentSupAcceptCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }

    clone(): PosmInvestmentSupAcceptCommand {
        const json = this.toJSON();
        let result = new PosmInvestmentSupAcceptCommand();
        result.init(json);
        return result;
    }
}

export interface IPosmInvestmentSupAcceptCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: PosmInvestmentSupAcceptDto;
}

export class PosmInvestmentSupAcceptDto implements IPosmInvestmentSupAcceptDto {
    posmInvestmentItemId?: number;
    id?: number;
    note?: string | undefined;
    photo1?: string | undefined;
    photo2?: string | undefined;
    photo3?: string | undefined;
    photo4?: string | undefined;

    constructor(data?: IPosmInvestmentSupAcceptDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.posmInvestmentItemId = _data["posmInvestmentItemId"];
            this.id = _data["id"];
            this.note = _data["note"];
            this.photo1 = _data["photo1"];
            this.photo2 = _data["photo2"];
            this.photo3 = _data["photo3"];
            this.photo4 = _data["photo4"];
        }
    }

    static fromJS(data: any): PosmInvestmentSupAcceptDto {
        data = typeof data === 'object' ? data : {};
        let result = new PosmInvestmentSupAcceptDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["posmInvestmentItemId"] = this.posmInvestmentItemId;
        data["id"] = this.id;
        data["note"] = this.note;
        data["photo1"] = this.photo1;
        data["photo2"] = this.photo2;
        data["photo3"] = this.photo3;
        data["photo4"] = this.photo4;
        return data;
    }

    clone(): PosmInvestmentSupAcceptDto {
        const json = this.toJSON();
        let result = new PosmInvestmentSupAcceptDto();
        result.init(json);
        return result;
    }
}

export interface IPosmInvestmentSupAcceptDto {
    posmInvestmentItemId?: number;
    id?: number;
    note?: string | undefined;
    photo1?: string | undefined;
    photo2?: string | undefined;
    photo3?: string | undefined;
    photo4?: string | undefined;
}

export class PosmInvestmentSupConfirmProduceCommand implements IPosmInvestmentSupConfirmProduceCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: PosmInvestmentSupConfirmProduceDto;

    constructor(data?: IPosmInvestmentSupConfirmProduceCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? PosmInvestmentSupConfirmProduceDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PosmInvestmentSupConfirmProduceCommand {
        data = typeof data === 'object' ? data : {};
        let result = new PosmInvestmentSupConfirmProduceCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }

    clone(): PosmInvestmentSupConfirmProduceCommand {
        const json = this.toJSON();
        let result = new PosmInvestmentSupConfirmProduceCommand();
        result.init(json);
        return result;
    }
}

export interface IPosmInvestmentSupConfirmProduceCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: PosmInvestmentSupConfirmProduceDto;
}

export class PosmInvestmentSupConfirmProduceDto implements IPosmInvestmentSupConfirmProduceDto {
    posmInvestmentItemId?: number;
    id?: number;

    constructor(data?: IPosmInvestmentSupConfirmProduceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.posmInvestmentItemId = _data["posmInvestmentItemId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PosmInvestmentSupConfirmProduceDto {
        data = typeof data === 'object' ? data : {};
        let result = new PosmInvestmentSupConfirmProduceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["posmInvestmentItemId"] = this.posmInvestmentItemId;
        data["id"] = this.id;
        return data;
    }

    clone(): PosmInvestmentSupConfirmProduceDto {
        const json = this.toJSON();
        let result = new PosmInvestmentSupConfirmProduceDto();
        result.init(json);
        return result;
    }
}

export interface IPosmInvestmentSupConfirmProduceDto {
    posmInvestmentItemId?: number;
    id?: number;
}

export class PosmInvestmentSupplyConfirmProduceCommand implements IPosmInvestmentSupplyConfirmProduceCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: PosmInvestmentSupplyConfirmProduceDto;

    constructor(data?: IPosmInvestmentSupplyConfirmProduceCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? PosmInvestmentSupplyConfirmProduceDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PosmInvestmentSupplyConfirmProduceCommand {
        data = typeof data === 'object' ? data : {};
        let result = new PosmInvestmentSupplyConfirmProduceCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }

    clone(): PosmInvestmentSupplyConfirmProduceCommand {
        const json = this.toJSON();
        let result = new PosmInvestmentSupplyConfirmProduceCommand();
        result.init(json);
        return result;
    }
}

export interface IPosmInvestmentSupplyConfirmProduceCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: PosmInvestmentSupplyConfirmProduceDto;
}

export class PosmInvestmentSupplyConfirmProduceDto implements IPosmInvestmentSupplyConfirmProduceDto {
    posmInvestmentItemId?: number;
    id?: number;

    constructor(data?: IPosmInvestmentSupplyConfirmProduceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.posmInvestmentItemId = _data["posmInvestmentItemId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PosmInvestmentSupplyConfirmProduceDto {
        data = typeof data === 'object' ? data : {};
        let result = new PosmInvestmentSupplyConfirmProduceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["posmInvestmentItemId"] = this.posmInvestmentItemId;
        data["id"] = this.id;
        return data;
    }

    clone(): PosmInvestmentSupplyConfirmProduceDto {
        const json = this.toJSON();
        let result = new PosmInvestmentSupplyConfirmProduceDto();
        result.init(json);
        return result;
    }
}

export interface IPosmInvestmentSupplyConfirmProduceDto {
    posmInvestmentItemId?: number;
    id?: number;
}

export class PosmInvestmentSupplyConfirmRequestCommand implements IPosmInvestmentSupplyConfirmRequestCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: PosmInvestmentSupplyConfirmRequestDto;

    constructor(data?: IPosmInvestmentSupplyConfirmRequestCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? PosmInvestmentSupplyConfirmRequestDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PosmInvestmentSupplyConfirmRequestCommand {
        data = typeof data === 'object' ? data : {};
        let result = new PosmInvestmentSupplyConfirmRequestCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }

    clone(): PosmInvestmentSupplyConfirmRequestCommand {
        const json = this.toJSON();
        let result = new PosmInvestmentSupplyConfirmRequestCommand();
        result.init(json);
        return result;
    }
}

export interface IPosmInvestmentSupplyConfirmRequestCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: PosmInvestmentSupplyConfirmRequestDto;
}

export class PosmInvestmentSupplyConfirmRequestDto implements IPosmInvestmentSupplyConfirmRequestDto {
    vendorId?: number;
    note?: string | undefined;
    actualUnitPrice?: number;
    posmInvestmentItemId?: number;
    id?: number;

    constructor(data?: IPosmInvestmentSupplyConfirmRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.vendorId = _data["vendorId"];
            this.note = _data["note"];
            this.actualUnitPrice = _data["actualUnitPrice"];
            this.posmInvestmentItemId = _data["posmInvestmentItemId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PosmInvestmentSupplyConfirmRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new PosmInvestmentSupplyConfirmRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vendorId"] = this.vendorId;
        data["note"] = this.note;
        data["actualUnitPrice"] = this.actualUnitPrice;
        data["posmInvestmentItemId"] = this.posmInvestmentItemId;
        data["id"] = this.id;
        return data;
    }

    clone(): PosmInvestmentSupplyConfirmRequestDto {
        const json = this.toJSON();
        let result = new PosmInvestmentSupplyConfirmRequestDto();
        result.init(json);
        return result;
    }
}

export interface IPosmInvestmentSupplyConfirmRequestDto {
    vendorId?: number;
    note?: string | undefined;
    actualUnitPrice?: number;
    posmInvestmentItemId?: number;
    id?: number;
}

export class PosmInvestmentSupplyDenyRequestCommand implements IPosmInvestmentSupplyDenyRequestCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: PosmInvestmentSupplyDenyRequestDto;

    constructor(data?: IPosmInvestmentSupplyDenyRequestCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? PosmInvestmentSupplyDenyRequestDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PosmInvestmentSupplyDenyRequestCommand {
        data = typeof data === 'object' ? data : {};
        let result = new PosmInvestmentSupplyDenyRequestCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }

    clone(): PosmInvestmentSupplyDenyRequestCommand {
        const json = this.toJSON();
        let result = new PosmInvestmentSupplyDenyRequestCommand();
        result.init(json);
        return result;
    }
}

export interface IPosmInvestmentSupplyDenyRequestCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: PosmInvestmentSupplyDenyRequestDto;
}

export class PosmInvestmentSupplyDenyRequestDto implements IPosmInvestmentSupplyDenyRequestDto {
    vendorId?: number;
    note?: string | undefined;
    actualUnitPrice?: number;
    posmInvestmentItemId?: number;
    id?: number;

    constructor(data?: IPosmInvestmentSupplyDenyRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.vendorId = _data["vendorId"];
            this.note = _data["note"];
            this.actualUnitPrice = _data["actualUnitPrice"];
            this.posmInvestmentItemId = _data["posmInvestmentItemId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PosmInvestmentSupplyDenyRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new PosmInvestmentSupplyDenyRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vendorId"] = this.vendorId;
        data["note"] = this.note;
        data["actualUnitPrice"] = this.actualUnitPrice;
        data["posmInvestmentItemId"] = this.posmInvestmentItemId;
        data["id"] = this.id;
        return data;
    }

    clone(): PosmInvestmentSupplyDenyRequestDto {
        const json = this.toJSON();
        let result = new PosmInvestmentSupplyDenyRequestDto();
        result.init(json);
        return result;
    }
}

export interface IPosmInvestmentSupplyDenyRequestDto {
    vendorId?: number;
    note?: string | undefined;
    actualUnitPrice?: number;
    posmInvestmentItemId?: number;
    id?: number;
}

export class PosmInvestmentSupSuggesDto implements IPosmInvestmentSupSuggesDto {
    posmInvestmentItemId?: number;
    reason?: string | undefined;
    id?: number;

    constructor(data?: IPosmInvestmentSupSuggesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.posmInvestmentItemId = _data["posmInvestmentItemId"];
            this.reason = _data["reason"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PosmInvestmentSupSuggesDto {
        data = typeof data === 'object' ? data : {};
        let result = new PosmInvestmentSupSuggesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["posmInvestmentItemId"] = this.posmInvestmentItemId;
        data["reason"] = this.reason;
        data["id"] = this.id;
        return data;
    }

    clone(): PosmInvestmentSupSuggesDto {
        const json = this.toJSON();
        let result = new PosmInvestmentSupSuggesDto();
        result.init(json);
        return result;
    }
}

export interface IPosmInvestmentSupSuggesDto {
    posmInvestmentItemId?: number;
    reason?: string | undefined;
    id?: number;
}

export class PosmInvestmentSupSuggestCommand implements IPosmInvestmentSupSuggestCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: PosmInvestmentSupSuggesDto;

    constructor(data?: IPosmInvestmentSupSuggestCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? PosmInvestmentSupSuggesDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PosmInvestmentSupSuggestCommand {
        data = typeof data === 'object' ? data : {};
        let result = new PosmInvestmentSupSuggestCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }

    clone(): PosmInvestmentSupSuggestCommand {
        const json = this.toJSON();
        let result = new PosmInvestmentSupSuggestCommand();
        result.init(json);
        return result;
    }
}

export interface IPosmInvestmentSupSuggestCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: PosmInvestmentSupSuggesDto;
}

export class PosmInvestmentTradeApproveCommand implements IPosmInvestmentTradeApproveCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: PosmInvestmentTradeApproveDto;

    constructor(data?: IPosmInvestmentTradeApproveCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? PosmInvestmentTradeApproveDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PosmInvestmentTradeApproveCommand {
        data = typeof data === 'object' ? data : {};
        let result = new PosmInvestmentTradeApproveCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }

    clone(): PosmInvestmentTradeApproveCommand {
        const json = this.toJSON();
        let result = new PosmInvestmentTradeApproveCommand();
        result.init(json);
        return result;
    }
}

export interface IPosmInvestmentTradeApproveCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: PosmInvestmentTradeApproveDto;
}

export class PosmInvestmentTradeApproveDto implements IPosmInvestmentTradeApproveDto {
    note?: string | undefined;
    id?: number;

    constructor(data?: IPosmInvestmentTradeApproveDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.note = _data["note"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PosmInvestmentTradeApproveDto {
        data = typeof data === 'object' ? data : {};
        let result = new PosmInvestmentTradeApproveDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["note"] = this.note;
        data["id"] = this.id;
        return data;
    }

    clone(): PosmInvestmentTradeApproveDto {
        const json = this.toJSON();
        let result = new PosmInvestmentTradeApproveDto();
        result.init(json);
        return result;
    }
}

export interface IPosmInvestmentTradeApproveDto {
    note?: string | undefined;
    id?: number;
}

export class PosmInvestmentTradeConfirmAcceptCommand implements IPosmInvestmentTradeConfirmAcceptCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: PosmInvestmentTradeConfirmAcceptDto;

    constructor(data?: IPosmInvestmentTradeConfirmAcceptCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? PosmInvestmentTradeConfirmAcceptDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PosmInvestmentTradeConfirmAcceptCommand {
        data = typeof data === 'object' ? data : {};
        let result = new PosmInvestmentTradeConfirmAcceptCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }

    clone(): PosmInvestmentTradeConfirmAcceptCommand {
        const json = this.toJSON();
        let result = new PosmInvestmentTradeConfirmAcceptCommand();
        result.init(json);
        return result;
    }
}

export interface IPosmInvestmentTradeConfirmAcceptCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: PosmInvestmentTradeConfirmAcceptDto;
}

export class PosmInvestmentTradeConfirmAcceptDto implements IPosmInvestmentTradeConfirmAcceptDto {
    posmInvestmentItemId?: number;
    id?: number;

    constructor(data?: IPosmInvestmentTradeConfirmAcceptDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.posmInvestmentItemId = _data["posmInvestmentItemId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PosmInvestmentTradeConfirmAcceptDto {
        data = typeof data === 'object' ? data : {};
        let result = new PosmInvestmentTradeConfirmAcceptDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["posmInvestmentItemId"] = this.posmInvestmentItemId;
        data["id"] = this.id;
        return data;
    }

    clone(): PosmInvestmentTradeConfirmAcceptDto {
        const json = this.toJSON();
        let result = new PosmInvestmentTradeConfirmAcceptDto();
        result.init(json);
        return result;
    }
}

export interface IPosmInvestmentTradeConfirmAcceptDto {
    posmInvestmentItemId?: number;
    id?: number;
}

export class PosmInvestmentTradeConfirmSuggesDto implements IPosmInvestmentTradeConfirmSuggesDto {
    posmInvestmentItemId?: number;
    id?: number;

    constructor(data?: IPosmInvestmentTradeConfirmSuggesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.posmInvestmentItemId = _data["posmInvestmentItemId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PosmInvestmentTradeConfirmSuggesDto {
        data = typeof data === 'object' ? data : {};
        let result = new PosmInvestmentTradeConfirmSuggesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["posmInvestmentItemId"] = this.posmInvestmentItemId;
        data["id"] = this.id;
        return data;
    }

    clone(): PosmInvestmentTradeConfirmSuggesDto {
        const json = this.toJSON();
        let result = new PosmInvestmentTradeConfirmSuggesDto();
        result.init(json);
        return result;
    }
}

export interface IPosmInvestmentTradeConfirmSuggesDto {
    posmInvestmentItemId?: number;
    id?: number;
}

export class PosmInvestmentTradeConfirmSuggestCommand implements IPosmInvestmentTradeConfirmSuggestCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: PosmInvestmentTradeConfirmSuggesDto;

    constructor(data?: IPosmInvestmentTradeConfirmSuggestCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? PosmInvestmentTradeConfirmSuggesDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PosmInvestmentTradeConfirmSuggestCommand {
        data = typeof data === 'object' ? data : {};
        let result = new PosmInvestmentTradeConfirmSuggestCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }

    clone(): PosmInvestmentTradeConfirmSuggestCommand {
        const json = this.toJSON();
        let result = new PosmInvestmentTradeConfirmSuggestCommand();
        result.init(json);
        return result;
    }
}

export interface IPosmInvestmentTradeConfirmSuggestCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: PosmInvestmentTradeConfirmSuggesDto;
}

export class PosmInvestmentTradeDenyCommand implements IPosmInvestmentTradeDenyCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: PosmInvestmentTradeDenyDto;

    constructor(data?: IPosmInvestmentTradeDenyCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? PosmInvestmentTradeDenyDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PosmInvestmentTradeDenyCommand {
        data = typeof data === 'object' ? data : {};
        let result = new PosmInvestmentTradeDenyCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }

    clone(): PosmInvestmentTradeDenyCommand {
        const json = this.toJSON();
        let result = new PosmInvestmentTradeDenyCommand();
        result.init(json);
        return result;
    }
}

export interface IPosmInvestmentTradeDenyCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: PosmInvestmentTradeDenyDto;
}

export class PosmInvestmentTradeDenyDto implements IPosmInvestmentTradeDenyDto {
    note?: string | undefined;
    id?: number;

    constructor(data?: IPosmInvestmentTradeDenyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.note = _data["note"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PosmInvestmentTradeDenyDto {
        data = typeof data === 'object' ? data : {};
        let result = new PosmInvestmentTradeDenyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["note"] = this.note;
        data["id"] = this.id;
        return data;
    }

    clone(): PosmInvestmentTradeDenyDto {
        const json = this.toJSON();
        let result = new PosmInvestmentTradeDenyDto();
        result.init(json);
        return result;
    }
}

export interface IPosmInvestmentTradeDenyDto {
    note?: string | undefined;
    id?: number;
}

export class PosmInvestmentTradeMultiApproveCommand implements IPosmInvestmentTradeMultiApproveCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: PosmInvestmentTradeMultiApproveDto;

    constructor(data?: IPosmInvestmentTradeMultiApproveCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? PosmInvestmentTradeMultiApproveDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PosmInvestmentTradeMultiApproveCommand {
        data = typeof data === 'object' ? data : {};
        let result = new PosmInvestmentTradeMultiApproveCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }

    clone(): PosmInvestmentTradeMultiApproveCommand {
        const json = this.toJSON();
        let result = new PosmInvestmentTradeMultiApproveCommand();
        result.init(json);
        return result;
    }
}

export interface IPosmInvestmentTradeMultiApproveCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: PosmInvestmentTradeMultiApproveDto;
}

export class PosmInvestmentTradeMultiApproveDto implements IPosmInvestmentTradeMultiApproveDto {
    note?: string | undefined;
    ids?: number[] | undefined;

    constructor(data?: IPosmInvestmentTradeMultiApproveDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.note = _data["note"];
            if (Array.isArray(_data["ids"])) {
                this.ids = [] as any;
                for (let item of _data["ids"])
                    this.ids!.push(item);
            }
        }
    }

    static fromJS(data: any): PosmInvestmentTradeMultiApproveDto {
        data = typeof data === 'object' ? data : {};
        let result = new PosmInvestmentTradeMultiApproveDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["note"] = this.note;
        if (Array.isArray(this.ids)) {
            data["ids"] = [];
            for (let item of this.ids)
                data["ids"].push(item);
        }
        return data;
    }

    clone(): PosmInvestmentTradeMultiApproveDto {
        const json = this.toJSON();
        let result = new PosmInvestmentTradeMultiApproveDto();
        result.init(json);
        return result;
    }
}

export interface IPosmInvestmentTradeMultiApproveDto {
    note?: string | undefined;
    ids?: number[] | undefined;
}

export class PosmInvestmentTradeMultiConfirmAcceptCommand implements IPosmInvestmentTradeMultiConfirmAcceptCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: PosmInvestmentTradeMultiConfirmAcceptDto;

    constructor(data?: IPosmInvestmentTradeMultiConfirmAcceptCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? PosmInvestmentTradeMultiConfirmAcceptDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PosmInvestmentTradeMultiConfirmAcceptCommand {
        data = typeof data === 'object' ? data : {};
        let result = new PosmInvestmentTradeMultiConfirmAcceptCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }

    clone(): PosmInvestmentTradeMultiConfirmAcceptCommand {
        const json = this.toJSON();
        let result = new PosmInvestmentTradeMultiConfirmAcceptCommand();
        result.init(json);
        return result;
    }
}

export interface IPosmInvestmentTradeMultiConfirmAcceptCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: PosmInvestmentTradeMultiConfirmAcceptDto;
}

export class PosmInvestmentTradeMultiConfirmAcceptDto implements IPosmInvestmentTradeMultiConfirmAcceptDto {
    note?: string | undefined;
    ids?: number[] | undefined;

    constructor(data?: IPosmInvestmentTradeMultiConfirmAcceptDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.note = _data["note"];
            if (Array.isArray(_data["ids"])) {
                this.ids = [] as any;
                for (let item of _data["ids"])
                    this.ids!.push(item);
            }
        }
    }

    static fromJS(data: any): PosmInvestmentTradeMultiConfirmAcceptDto {
        data = typeof data === 'object' ? data : {};
        let result = new PosmInvestmentTradeMultiConfirmAcceptDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["note"] = this.note;
        if (Array.isArray(this.ids)) {
            data["ids"] = [];
            for (let item of this.ids)
                data["ids"].push(item);
        }
        return data;
    }

    clone(): PosmInvestmentTradeMultiConfirmAcceptDto {
        const json = this.toJSON();
        let result = new PosmInvestmentTradeMultiConfirmAcceptDto();
        result.init(json);
        return result;
    }
}

export interface IPosmInvestmentTradeMultiConfirmAcceptDto {
    note?: string | undefined;
    ids?: number[] | undefined;
}

export class PosmInvestmentTradeMultiDenyCommand implements IPosmInvestmentTradeMultiDenyCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: PosmInvestmentTradeMultiDenyDto;

    constructor(data?: IPosmInvestmentTradeMultiDenyCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? PosmInvestmentTradeMultiDenyDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PosmInvestmentTradeMultiDenyCommand {
        data = typeof data === 'object' ? data : {};
        let result = new PosmInvestmentTradeMultiDenyCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }

    clone(): PosmInvestmentTradeMultiDenyCommand {
        const json = this.toJSON();
        let result = new PosmInvestmentTradeMultiDenyCommand();
        result.init(json);
        return result;
    }
}

export interface IPosmInvestmentTradeMultiDenyCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: PosmInvestmentTradeMultiDenyDto;
}

export class PosmInvestmentTradeMultiDenyDto implements IPosmInvestmentTradeMultiDenyDto {
    note?: string | undefined;
    ids?: number[] | undefined;

    constructor(data?: IPosmInvestmentTradeMultiDenyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.note = _data["note"];
            if (Array.isArray(_data["ids"])) {
                this.ids = [] as any;
                for (let item of _data["ids"])
                    this.ids!.push(item);
            }
        }
    }

    static fromJS(data: any): PosmInvestmentTradeMultiDenyDto {
        data = typeof data === 'object' ? data : {};
        let result = new PosmInvestmentTradeMultiDenyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["note"] = this.note;
        if (Array.isArray(this.ids)) {
            data["ids"] = [];
            for (let item of this.ids)
                data["ids"].push(item);
        }
        return data;
    }

    clone(): PosmInvestmentTradeMultiDenyDto {
        const json = this.toJSON();
        let result = new PosmInvestmentTradeMultiDenyDto();
        result.init(json);
        return result;
    }
}

export interface IPosmInvestmentTradeMultiDenyDto {
    note?: string | undefined;
    ids?: number[] | undefined;
}

export class PosmInvestmnetItemHistoryItemDto implements IPosmInvestmnetItemHistoryItemDto {
    id?: number;
    status?: PosmInvestmentItemStatus;
    data?: string | undefined;
    creationUser?: string | undefined;
    creationRole?: string | undefined;
    creationTime?: Date;
    lastModifierUser?: string | undefined;
    remarkOfSales?: number | undefined;
    remarkOfCompany?: number | undefined;

    constructor(data?: IPosmInvestmnetItemHistoryItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.status = _data["status"];
            this.data = _data["data"];
            this.creationUser = _data["creationUser"];
            this.creationRole = _data["creationRole"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"];
            this.remarkOfSales = _data["remarkOfSales"];
            this.remarkOfCompany = _data["remarkOfCompany"];
        }
    }

    static fromJS(data: any): PosmInvestmnetItemHistoryItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new PosmInvestmnetItemHistoryItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["status"] = this.status;
        data["data"] = this.data;
        data["creationUser"] = this.creationUser;
        data["creationRole"] = this.creationRole;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser;
        data["remarkOfSales"] = this.remarkOfSales;
        data["remarkOfCompany"] = this.remarkOfCompany;
        return data;
    }

    clone(): PosmInvestmnetItemHistoryItemDto {
        const json = this.toJSON();
        let result = new PosmInvestmnetItemHistoryItemDto();
        result.init(json);
        return result;
    }
}

export interface IPosmInvestmnetItemHistoryItemDto {
    id?: number;
    status?: PosmInvestmentItemStatus;
    data?: string | undefined;
    creationUser?: string | undefined;
    creationRole?: string | undefined;
    creationTime?: Date;
    lastModifierUser?: string | undefined;
    remarkOfSales?: number | undefined;
    remarkOfCompany?: number | undefined;
}

export class PosmItemDto implements IPosmItemDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    posmClassId?: number;
    posmTypeId?: number | undefined;
    isActive?: boolean;
    link?: string | undefined;
    unitType?: PosmUnitType;
    calcType?: PosmCalcType;
    catalogs?: PosmCatalogDto[] | undefined;

    constructor(data?: IPosmItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.posmClassId = _data["posmClassId"];
            this.posmTypeId = _data["posmTypeId"];
            this.isActive = _data["isActive"];
            this.link = _data["link"];
            this.unitType = _data["unitType"];
            this.calcType = _data["calcType"];
            if (Array.isArray(_data["catalogs"])) {
                this.catalogs = [] as any;
                for (let item of _data["catalogs"])
                    this.catalogs!.push(PosmCatalogDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PosmItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new PosmItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["posmClassId"] = this.posmClassId;
        data["posmTypeId"] = this.posmTypeId;
        data["isActive"] = this.isActive;
        data["link"] = this.link;
        data["unitType"] = this.unitType;
        data["calcType"] = this.calcType;
        if (Array.isArray(this.catalogs)) {
            data["catalogs"] = [];
            for (let item of this.catalogs)
                data["catalogs"].push(item.toJSON());
        }
        return data;
    }

    clone(): PosmItemDto {
        const json = this.toJSON();
        let result = new PosmItemDto();
        result.init(json);
        return result;
    }
}

export interface IPosmItemDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    posmClassId?: number;
    posmTypeId?: number | undefined;
    isActive?: boolean;
    link?: string | undefined;
    unitType?: PosmUnitType;
    calcType?: PosmCalcType;
    catalogs?: PosmCatalogDto[] | undefined;
}

export class PosmItemDtoApiResultObject implements IPosmItemDtoApiResultObject {
    result?: PosmItemDto;
    success?: boolean;

    constructor(data?: IPosmItemDtoApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? PosmItemDto.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): PosmItemDtoApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new PosmItemDtoApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data;
    }

    clone(): PosmItemDtoApiResultObject {
        const json = this.toJSON();
        let result = new PosmItemDtoApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IPosmItemDtoApiResultObject {
    result?: PosmItemDto;
    success?: boolean;
}

export class PosmItemListDto implements IPosmItemListDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    posmClassId?: number;
    posmTypeId?: number | undefined;
    isActive?: boolean;
    link?: string | undefined;
    unitType?: PosmUnitType;
    calcType?: PosmCalcType;
    catalogs?: PosmCatalogDto[] | undefined;
    posmClassName?: string | undefined;

    constructor(data?: IPosmItemListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.posmClassId = _data["posmClassId"];
            this.posmTypeId = _data["posmTypeId"];
            this.isActive = _data["isActive"];
            this.link = _data["link"];
            this.unitType = _data["unitType"];
            this.calcType = _data["calcType"];
            if (Array.isArray(_data["catalogs"])) {
                this.catalogs = [] as any;
                for (let item of _data["catalogs"])
                    this.catalogs!.push(PosmCatalogDto.fromJS(item));
            }
            this.posmClassName = _data["posmClassName"];
        }
    }

    static fromJS(data: any): PosmItemListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PosmItemListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["posmClassId"] = this.posmClassId;
        data["posmTypeId"] = this.posmTypeId;
        data["isActive"] = this.isActive;
        data["link"] = this.link;
        data["unitType"] = this.unitType;
        data["calcType"] = this.calcType;
        if (Array.isArray(this.catalogs)) {
            data["catalogs"] = [];
            for (let item of this.catalogs)
                data["catalogs"].push(item.toJSON());
        }
        data["posmClassName"] = this.posmClassName;
        return data;
    }

    clone(): PosmItemListDto {
        const json = this.toJSON();
        let result = new PosmItemListDto();
        result.init(json);
        return result;
    }
}

export interface IPosmItemListDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    posmClassId?: number;
    posmTypeId?: number | undefined;
    isActive?: boolean;
    link?: string | undefined;
    unitType?: PosmUnitType;
    calcType?: PosmCalcType;
    catalogs?: PosmCatalogDto[] | undefined;
    posmClassName?: string | undefined;
}

export class PosmItemListDtoPagingResult implements IPosmItemListDtoPagingResult {
    items?: PosmItemListDto[] | undefined;
    totalCount?: number;

    constructor(data?: IPosmItemListDtoPagingResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PosmItemListDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PosmItemListDtoPagingResult {
        data = typeof data === 'object' ? data : {};
        let result = new PosmItemListDtoPagingResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): PosmItemListDtoPagingResult {
        const json = this.toJSON();
        let result = new PosmItemListDtoPagingResult();
        result.init(json);
        return result;
    }
}

export interface IPosmItemListDtoPagingResult {
    items?: PosmItemListDto[] | undefined;
    totalCount?: number;
}

export class PosmItemListDtoPagingResultApiResultObject implements IPosmItemListDtoPagingResultApiResultObject {
    result?: PosmItemListDtoPagingResult;
    success?: boolean;

    constructor(data?: IPosmItemListDtoPagingResultApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? PosmItemListDtoPagingResult.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): PosmItemListDtoPagingResultApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new PosmItemListDtoPagingResultApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data;
    }

    clone(): PosmItemListDtoPagingResultApiResultObject {
        const json = this.toJSON();
        let result = new PosmItemListDtoPagingResultApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IPosmItemListDtoPagingResultApiResultObject {
    result?: PosmItemListDtoPagingResult;
    success?: boolean;
}

export class PosmItemUpsertCommand implements IPosmItemUpsertCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: PosmItemUpsertDto;
    readonly handleType?: string | undefined;

    constructor(data?: IPosmItemUpsertCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? PosmItemUpsertDto.fromJS(_data["data"]) : <any>undefined;
            (<any>this).handleType = _data["handleType"];
        }
    }

    static fromJS(data: any): PosmItemUpsertCommand {
        data = typeof data === 'object' ? data : {};
        let result = new PosmItemUpsertCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["handleType"] = this.handleType;
        return data;
    }

    clone(): PosmItemUpsertCommand {
        const json = this.toJSON();
        let result = new PosmItemUpsertCommand();
        result.init(json);
        return result;
    }
}

export interface IPosmItemUpsertCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: PosmItemUpsertDto;
    handleType?: string | undefined;
}

export class PosmItemUpsertDto implements IPosmItemUpsertDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    posmClassId?: number;
    posmTypeId?: number | undefined;
    isActive?: boolean;
    link?: string | undefined;
    unitType?: PosmUnitType;
    calcType?: PosmCalcType;
    catalogs?: PosmCatalogDto[] | undefined;
    catalogChanges?: PosmCatalogDtoCrudListDto;

    constructor(data?: IPosmItemUpsertDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.posmClassId = _data["posmClassId"];
            this.posmTypeId = _data["posmTypeId"];
            this.isActive = _data["isActive"];
            this.link = _data["link"];
            this.unitType = _data["unitType"];
            this.calcType = _data["calcType"];
            if (Array.isArray(_data["catalogs"])) {
                this.catalogs = [] as any;
                for (let item of _data["catalogs"])
                    this.catalogs!.push(PosmCatalogDto.fromJS(item));
            }
            this.catalogChanges = _data["catalogChanges"] ? PosmCatalogDtoCrudListDto.fromJS(_data["catalogChanges"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PosmItemUpsertDto {
        data = typeof data === 'object' ? data : {};
        let result = new PosmItemUpsertDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["posmClassId"] = this.posmClassId;
        data["posmTypeId"] = this.posmTypeId;
        data["isActive"] = this.isActive;
        data["link"] = this.link;
        data["unitType"] = this.unitType;
        data["calcType"] = this.calcType;
        if (Array.isArray(this.catalogs)) {
            data["catalogs"] = [];
            for (let item of this.catalogs)
                data["catalogs"].push(item.toJSON());
        }
        data["catalogChanges"] = this.catalogChanges ? this.catalogChanges.toJSON() : <any>undefined;
        return data;
    }

    clone(): PosmItemUpsertDto {
        const json = this.toJSON();
        let result = new PosmItemUpsertDto();
        result.init(json);
        return result;
    }
}

export interface IPosmItemUpsertDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    posmClassId?: number;
    posmTypeId?: number | undefined;
    isActive?: boolean;
    link?: string | undefined;
    unitType?: PosmUnitType;
    calcType?: PosmCalcType;
    catalogs?: PosmCatalogDto[] | undefined;
    catalogChanges?: PosmCatalogDtoCrudListDto;
}

export class PosmPriceDetailDto implements IPosmPriceDetailDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    posmItemId?: number;
    price?: number;
    code?: string | undefined;
    name?: string | undefined;
    unitType?: PosmUnitType;
    calcType?: PosmCalcType;

    constructor(data?: IPosmPriceDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.posmItemId = _data["posmItemId"];
            this.price = _data["price"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.unitType = _data["unitType"];
            this.calcType = _data["calcType"];
        }
    }

    static fromJS(data: any): PosmPriceDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new PosmPriceDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["posmItemId"] = this.posmItemId;
        data["price"] = this.price;
        data["code"] = this.code;
        data["name"] = this.name;
        data["unitType"] = this.unitType;
        data["calcType"] = this.calcType;
        return data;
    }

    clone(): PosmPriceDetailDto {
        const json = this.toJSON();
        let result = new PosmPriceDetailDto();
        result.init(json);
        return result;
    }
}

export interface IPosmPriceDetailDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    posmItemId?: number;
    price?: number;
    code?: string | undefined;
    name?: string | undefined;
    unitType?: PosmUnitType;
    calcType?: PosmCalcType;
}

export class PosmPriceDetailUpsertDto implements IPosmPriceDetailUpsertDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    posmItemId?: number;
    price?: number;

    constructor(data?: IPosmPriceDetailUpsertDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.posmItemId = _data["posmItemId"];
            this.price = _data["price"];
        }
    }

    static fromJS(data: any): PosmPriceDetailUpsertDto {
        data = typeof data === 'object' ? data : {};
        let result = new PosmPriceDetailUpsertDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["posmItemId"] = this.posmItemId;
        data["price"] = this.price;
        return data;
    }

    clone(): PosmPriceDetailUpsertDto {
        const json = this.toJSON();
        let result = new PosmPriceDetailUpsertDto();
        result.init(json);
        return result;
    }
}

export interface IPosmPriceDetailUpsertDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    posmItemId?: number;
    price?: number;
}

export class PosmPriceDetailUpsertDtoCrudListDto implements IPosmPriceDetailUpsertDtoCrudListDto {
    upsertedItems?: PosmPriceDetailUpsertDto[] | undefined;
    deletedItems?: PosmPriceDetailUpsertDto[] | undefined;

    constructor(data?: IPosmPriceDetailUpsertDtoCrudListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["upsertedItems"])) {
                this.upsertedItems = [] as any;
                for (let item of _data["upsertedItems"])
                    this.upsertedItems!.push(PosmPriceDetailUpsertDto.fromJS(item));
            }
            if (Array.isArray(_data["deletedItems"])) {
                this.deletedItems = [] as any;
                for (let item of _data["deletedItems"])
                    this.deletedItems!.push(PosmPriceDetailUpsertDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PosmPriceDetailUpsertDtoCrudListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PosmPriceDetailUpsertDtoCrudListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.upsertedItems)) {
            data["upsertedItems"] = [];
            for (let item of this.upsertedItems)
                data["upsertedItems"].push(item.toJSON());
        }
        if (Array.isArray(this.deletedItems)) {
            data["deletedItems"] = [];
            for (let item of this.deletedItems)
                data["deletedItems"].push(item.toJSON());
        }
        return data;
    }

    clone(): PosmPriceDetailUpsertDtoCrudListDto {
        const json = this.toJSON();
        let result = new PosmPriceDetailUpsertDtoCrudListDto();
        result.init(json);
        return result;
    }
}

export interface IPosmPriceDetailUpsertDtoCrudListDto {
    upsertedItems?: PosmPriceDetailUpsertDto[] | undefined;
    deletedItems?: PosmPriceDetailUpsertDto[] | undefined;
}

export class PosmPriceHeaderDto implements IPosmPriceHeaderDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    fromDate?: Date;
    toDate?: Date;
    isActive?: boolean;
    details?: PosmPriceDetailDto[] | undefined;

    constructor(data?: IPosmPriceHeaderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.fromDate = _data["fromDate"] ? new Date(_data["fromDate"].toString()) : <any>undefined;
            this.toDate = _data["toDate"] ? new Date(_data["toDate"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["details"])) {
                this.details = [] as any;
                for (let item of _data["details"])
                    this.details!.push(PosmPriceDetailDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PosmPriceHeaderDto {
        data = typeof data === 'object' ? data : {};
        let result = new PosmPriceHeaderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["fromDate"] = this.fromDate ? this.fromDate.toISOString() : <any>undefined;
        data["toDate"] = this.toDate ? this.toDate.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.details)) {
            data["details"] = [];
            for (let item of this.details)
                data["details"].push(item.toJSON());
        }
        return data;
    }

    clone(): PosmPriceHeaderDto {
        const json = this.toJSON();
        let result = new PosmPriceHeaderDto();
        result.init(json);
        return result;
    }
}

export interface IPosmPriceHeaderDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    fromDate?: Date;
    toDate?: Date;
    isActive?: boolean;
    details?: PosmPriceDetailDto[] | undefined;
}

export class PosmPriceHeaderDtoApiResultObject implements IPosmPriceHeaderDtoApiResultObject {
    result?: PosmPriceHeaderDto;
    success?: boolean;

    constructor(data?: IPosmPriceHeaderDtoApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? PosmPriceHeaderDto.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): PosmPriceHeaderDtoApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new PosmPriceHeaderDtoApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data;
    }

    clone(): PosmPriceHeaderDtoApiResultObject {
        const json = this.toJSON();
        let result = new PosmPriceHeaderDtoApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IPosmPriceHeaderDtoApiResultObject {
    result?: PosmPriceHeaderDto;
    success?: boolean;
}

export class PosmPriceHeaderListDto implements IPosmPriceHeaderListDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    fromDate?: Date;
    toDate?: Date;
    isActive?: boolean;

    constructor(data?: IPosmPriceHeaderListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.fromDate = _data["fromDate"] ? new Date(_data["fromDate"].toString()) : <any>undefined;
            this.toDate = _data["toDate"] ? new Date(_data["toDate"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): PosmPriceHeaderListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PosmPriceHeaderListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["fromDate"] = this.fromDate ? this.fromDate.toISOString() : <any>undefined;
        data["toDate"] = this.toDate ? this.toDate.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): PosmPriceHeaderListDto {
        const json = this.toJSON();
        let result = new PosmPriceHeaderListDto();
        result.init(json);
        return result;
    }
}

export interface IPosmPriceHeaderListDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    fromDate?: Date;
    toDate?: Date;
    isActive?: boolean;
}

export class PosmPriceHeaderListDtoPagingResult implements IPosmPriceHeaderListDtoPagingResult {
    items?: PosmPriceHeaderListDto[] | undefined;
    totalCount?: number;

    constructor(data?: IPosmPriceHeaderListDtoPagingResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PosmPriceHeaderListDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PosmPriceHeaderListDtoPagingResult {
        data = typeof data === 'object' ? data : {};
        let result = new PosmPriceHeaderListDtoPagingResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): PosmPriceHeaderListDtoPagingResult {
        const json = this.toJSON();
        let result = new PosmPriceHeaderListDtoPagingResult();
        result.init(json);
        return result;
    }
}

export interface IPosmPriceHeaderListDtoPagingResult {
    items?: PosmPriceHeaderListDto[] | undefined;
    totalCount?: number;
}

export class PosmPriceHeaderListDtoPagingResultApiResultObject implements IPosmPriceHeaderListDtoPagingResultApiResultObject {
    result?: PosmPriceHeaderListDtoPagingResult;
    success?: boolean;

    constructor(data?: IPosmPriceHeaderListDtoPagingResultApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? PosmPriceHeaderListDtoPagingResult.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): PosmPriceHeaderListDtoPagingResultApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new PosmPriceHeaderListDtoPagingResultApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data;
    }

    clone(): PosmPriceHeaderListDtoPagingResultApiResultObject {
        const json = this.toJSON();
        let result = new PosmPriceHeaderListDtoPagingResultApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IPosmPriceHeaderListDtoPagingResultApiResultObject {
    result?: PosmPriceHeaderListDtoPagingResult;
    success?: boolean;
}

export class PosmPriceUpsertCommand implements IPosmPriceUpsertCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: PosmPriceUpsertDto;
    readonly handleType?: string | undefined;

    constructor(data?: IPosmPriceUpsertCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? PosmPriceUpsertDto.fromJS(_data["data"]) : <any>undefined;
            (<any>this).handleType = _data["handleType"];
        }
    }

    static fromJS(data: any): PosmPriceUpsertCommand {
        data = typeof data === 'object' ? data : {};
        let result = new PosmPriceUpsertCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["handleType"] = this.handleType;
        return data;
    }

    clone(): PosmPriceUpsertCommand {
        const json = this.toJSON();
        let result = new PosmPriceUpsertCommand();
        result.init(json);
        return result;
    }
}

export interface IPosmPriceUpsertCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: PosmPriceUpsertDto;
    handleType?: string | undefined;
}

export class PosmPriceUpsertDto implements IPosmPriceUpsertDto {
    id?: number;
    code?: string | undefined;
    name?: string | undefined;
    isActive?: boolean;
    fromDate?: Date;
    toDate?: Date;
    detailChanges?: PosmPriceDetailUpsertDtoCrudListDto;

    constructor(data?: IPosmPriceUpsertDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
            this.fromDate = _data["fromDate"] ? new Date(_data["fromDate"].toString()) : <any>undefined;
            this.toDate = _data["toDate"] ? new Date(_data["toDate"].toString()) : <any>undefined;
            this.detailChanges = _data["detailChanges"] ? PosmPriceDetailUpsertDtoCrudListDto.fromJS(_data["detailChanges"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PosmPriceUpsertDto {
        data = typeof data === 'object' ? data : {};
        let result = new PosmPriceUpsertDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        data["fromDate"] = this.fromDate ? this.fromDate.toISOString() : <any>undefined;
        data["toDate"] = this.toDate ? this.toDate.toISOString() : <any>undefined;
        data["detailChanges"] = this.detailChanges ? this.detailChanges.toJSON() : <any>undefined;
        return data;
    }

    clone(): PosmPriceUpsertDto {
        const json = this.toJSON();
        let result = new PosmPriceUpsertDto();
        result.init(json);
        return result;
    }
}

export interface IPosmPriceUpsertDto {
    id?: number;
    code?: string | undefined;
    name?: string | undefined;
    isActive?: boolean;
    fromDate?: Date;
    toDate?: Date;
    detailChanges?: PosmPriceDetailUpsertDtoCrudListDto;
}

export enum PosmRequestType {
    _1 = 1,
    _2 = 2,
}

export class PosmSalesCommitmentDto implements IPosmSalesCommitmentDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    year?: number;
    month?: number;
    amount?: number;

    constructor(data?: IPosmSalesCommitmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.year = _data["year"];
            this.month = _data["month"];
            this.amount = _data["amount"];
        }
    }

    static fromJS(data: any): PosmSalesCommitmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new PosmSalesCommitmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["year"] = this.year;
        data["month"] = this.month;
        data["amount"] = this.amount;
        return data;
    }

    clone(): PosmSalesCommitmentDto {
        const json = this.toJSON();
        let result = new PosmSalesCommitmentDto();
        result.init(json);
        return result;
    }
}

export interface IPosmSalesCommitmentDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    year?: number;
    month?: number;
    amount?: number;
}

export class PosmTypeDto implements IPosmTypeDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    isActive?: boolean;

    constructor(data?: IPosmTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): PosmTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new PosmTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): PosmTypeDto {
        const json = this.toJSON();
        let result = new PosmTypeDto();
        result.init(json);
        return result;
    }
}

export interface IPosmTypeDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    isActive?: boolean;
}

export class PosmTypeDtoApiResultObject implements IPosmTypeDtoApiResultObject {
    result?: PosmTypeDto;
    success?: boolean;

    constructor(data?: IPosmTypeDtoApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? PosmTypeDto.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): PosmTypeDtoApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new PosmTypeDtoApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data;
    }

    clone(): PosmTypeDtoApiResultObject {
        const json = this.toJSON();
        let result = new PosmTypeDtoApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IPosmTypeDtoApiResultObject {
    result?: PosmTypeDto;
    success?: boolean;
}

export class PosmTypeDtoPagingResult implements IPosmTypeDtoPagingResult {
    items?: PosmTypeDto[] | undefined;
    totalCount?: number;

    constructor(data?: IPosmTypeDtoPagingResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PosmTypeDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PosmTypeDtoPagingResult {
        data = typeof data === 'object' ? data : {};
        let result = new PosmTypeDtoPagingResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): PosmTypeDtoPagingResult {
        const json = this.toJSON();
        let result = new PosmTypeDtoPagingResult();
        result.init(json);
        return result;
    }
}

export interface IPosmTypeDtoPagingResult {
    items?: PosmTypeDto[] | undefined;
    totalCount?: number;
}

export class PosmTypeDtoPagingResultApiResultObject implements IPosmTypeDtoPagingResultApiResultObject {
    result?: PosmTypeDtoPagingResult;
    success?: boolean;

    constructor(data?: IPosmTypeDtoPagingResultApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? PosmTypeDtoPagingResult.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): PosmTypeDtoPagingResultApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new PosmTypeDtoPagingResultApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data;
    }

    clone(): PosmTypeDtoPagingResultApiResultObject {
        const json = this.toJSON();
        let result = new PosmTypeDtoPagingResultApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IPosmTypeDtoPagingResultApiResultObject {
    result?: PosmTypeDtoPagingResult;
    success?: boolean;
}

export class PosmTypeUpsertCommand implements IPosmTypeUpsertCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: PosmTypeUpsertDto;
    readonly handleType?: string | undefined;

    constructor(data?: IPosmTypeUpsertCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? PosmTypeUpsertDto.fromJS(_data["data"]) : <any>undefined;
            (<any>this).handleType = _data["handleType"];
        }
    }

    static fromJS(data: any): PosmTypeUpsertCommand {
        data = typeof data === 'object' ? data : {};
        let result = new PosmTypeUpsertCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["handleType"] = this.handleType;
        return data;
    }

    clone(): PosmTypeUpsertCommand {
        const json = this.toJSON();
        let result = new PosmTypeUpsertCommand();
        result.init(json);
        return result;
    }
}

export interface IPosmTypeUpsertCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: PosmTypeUpsertDto;
    handleType?: string | undefined;
}

export class PosmTypeUpsertDto implements IPosmTypeUpsertDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    isActive?: boolean;

    constructor(data?: IPosmTypeUpsertDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): PosmTypeUpsertDto {
        data = typeof data === 'object' ? data : {};
        let result = new PosmTypeUpsertDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): PosmTypeUpsertDto {
        const json = this.toJSON();
        let result = new PosmTypeUpsertDto();
        result.init(json);
        return result;
    }
}

export interface IPosmTypeUpsertDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    isActive?: boolean;
}

export enum PosmUnitType {
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class ProductBaseDto implements IProductBaseDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    isActive?: boolean;
    unit?: string | undefined;
    caseUnit?: string | undefined;
    packSize?: number;
    productClassId?: number | undefined;
    subProductClassId?: number | undefined;
    brandId?: number | undefined;
    updateDate?: Date;
    point?: number;

    constructor(data?: IProductBaseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.isActive = _data["isActive"];
            this.unit = _data["unit"];
            this.caseUnit = _data["caseUnit"];
            this.packSize = _data["packSize"];
            this.productClassId = _data["productClassId"];
            this.subProductClassId = _data["subProductClassId"];
            this.brandId = _data["brandId"];
            this.updateDate = _data["updateDate"] ? new Date(_data["updateDate"].toString()) : <any>undefined;
            this.point = _data["point"];
        }
    }

    static fromJS(data: any): ProductBaseDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductBaseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["description"] = this.description;
        data["isActive"] = this.isActive;
        data["unit"] = this.unit;
        data["caseUnit"] = this.caseUnit;
        data["packSize"] = this.packSize;
        data["productClassId"] = this.productClassId;
        data["subProductClassId"] = this.subProductClassId;
        data["brandId"] = this.brandId;
        data["updateDate"] = this.updateDate ? this.updateDate.toISOString() : <any>undefined;
        data["point"] = this.point;
        return data;
    }

    clone(): ProductBaseDto {
        const json = this.toJSON();
        let result = new ProductBaseDto();
        result.init(json);
        return result;
    }
}

export interface IProductBaseDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    isActive?: boolean;
    unit?: string | undefined;
    caseUnit?: string | undefined;
    packSize?: number;
    productClassId?: number | undefined;
    subProductClassId?: number | undefined;
    brandId?: number | undefined;
    updateDate?: Date;
    point?: number;
}

export class ProductBaseDtoApiResultObject implements IProductBaseDtoApiResultObject {
    result?: ProductBaseDto;
    success?: boolean;

    constructor(data?: IProductBaseDtoApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? ProductBaseDto.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): ProductBaseDtoApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new ProductBaseDtoApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data;
    }

    clone(): ProductBaseDtoApiResultObject {
        const json = this.toJSON();
        let result = new ProductBaseDtoApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IProductBaseDtoApiResultObject {
    result?: ProductBaseDto;
    success?: boolean;
}

export class ProductClassDto implements IProductClassDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    rewardCode?: string | undefined;
    isActive?: boolean;

    constructor(data?: IProductClassDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.rewardCode = _data["rewardCode"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): ProductClassDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductClassDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["rewardCode"] = this.rewardCode;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): ProductClassDto {
        const json = this.toJSON();
        let result = new ProductClassDto();
        result.init(json);
        return result;
    }
}

export interface IProductClassDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    rewardCode?: string | undefined;
    isActive?: boolean;
}

export class ProductClassDtoApiResultObject implements IProductClassDtoApiResultObject {
    result?: ProductClassDto;
    success?: boolean;

    constructor(data?: IProductClassDtoApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? ProductClassDto.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): ProductClassDtoApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new ProductClassDtoApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data;
    }

    clone(): ProductClassDtoApiResultObject {
        const json = this.toJSON();
        let result = new ProductClassDtoApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IProductClassDtoApiResultObject {
    result?: ProductClassDto;
    success?: boolean;
}

export class ProductClassDtoPagingResult implements IProductClassDtoPagingResult {
    items?: ProductClassDto[] | undefined;
    totalCount?: number;

    constructor(data?: IProductClassDtoPagingResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProductClassDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ProductClassDtoPagingResult {
        data = typeof data === 'object' ? data : {};
        let result = new ProductClassDtoPagingResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ProductClassDtoPagingResult {
        const json = this.toJSON();
        let result = new ProductClassDtoPagingResult();
        result.init(json);
        return result;
    }
}

export interface IProductClassDtoPagingResult {
    items?: ProductClassDto[] | undefined;
    totalCount?: number;
}

export class ProductClassDtoPagingResultApiResultObject implements IProductClassDtoPagingResultApiResultObject {
    result?: ProductClassDtoPagingResult;
    success?: boolean;

    constructor(data?: IProductClassDtoPagingResultApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? ProductClassDtoPagingResult.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): ProductClassDtoPagingResultApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new ProductClassDtoPagingResultApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data;
    }

    clone(): ProductClassDtoPagingResultApiResultObject {
        const json = this.toJSON();
        let result = new ProductClassDtoPagingResultApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IProductClassDtoPagingResultApiResultObject {
    result?: ProductClassDtoPagingResult;
    success?: boolean;
}

export class ProductInfoDto implements IProductInfoDto {
    readonly qrCode?: string | undefined;
    readonly productCode?: string | undefined;
    readonly name?: string | undefined;
    readonly unit?: string | undefined;
    readonly quantity?: number;
    readonly point?: number;

    constructor(data?: IProductInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).qrCode = _data["qrCode"];
            (<any>this).productCode = _data["productCode"];
            (<any>this).name = _data["name"];
            (<any>this).unit = _data["unit"];
            (<any>this).quantity = _data["quantity"];
            (<any>this).point = _data["point"];
        }
    }

    static fromJS(data: any): ProductInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["qrCode"] = this.qrCode;
        data["productCode"] = this.productCode;
        data["name"] = this.name;
        data["unit"] = this.unit;
        data["quantity"] = this.quantity;
        data["point"] = this.point;
        return data;
    }

    clone(): ProductInfoDto {
        const json = this.toJSON();
        let result = new ProductInfoDto();
        result.init(json);
        return result;
    }
}

export interface IProductInfoDto {
    qrCode?: string | undefined;
    productCode?: string | undefined;
    name?: string | undefined;
    unit?: string | undefined;
    quantity?: number;
    point?: number;
}

export class ProductInfoDtoApiResultObject implements IProductInfoDtoApiResultObject {
    result?: ProductInfoDto;
    success?: boolean;

    constructor(data?: IProductInfoDtoApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? ProductInfoDto.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): ProductInfoDtoApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new ProductInfoDtoApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data;
    }

    clone(): ProductInfoDtoApiResultObject {
        const json = this.toJSON();
        let result = new ProductInfoDtoApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IProductInfoDtoApiResultObject {
    result?: ProductInfoDto;
    success?: boolean;
}

export class ProductItemDto implements IProductItemDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    isActive?: boolean;
    unit?: string | undefined;
    caseUnit?: string | undefined;
    packSize?: number;
    productClassId?: number | undefined;
    subProductClassId?: number | undefined;
    brandId?: number | undefined;
    updateDate?: Date;
    point?: number;
    brandName?: string | undefined;
    productClassName?: string | undefined;
    subProductClassName?: string | undefined;
    status?: string | undefined;

    constructor(data?: IProductItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.isActive = _data["isActive"];
            this.unit = _data["unit"];
            this.caseUnit = _data["caseUnit"];
            this.packSize = _data["packSize"];
            this.productClassId = _data["productClassId"];
            this.subProductClassId = _data["subProductClassId"];
            this.brandId = _data["brandId"];
            this.updateDate = _data["updateDate"] ? new Date(_data["updateDate"].toString()) : <any>undefined;
            this.point = _data["point"];
            this.brandName = _data["brandName"];
            this.productClassName = _data["productClassName"];
            this.subProductClassName = _data["subProductClassName"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): ProductItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["description"] = this.description;
        data["isActive"] = this.isActive;
        data["unit"] = this.unit;
        data["caseUnit"] = this.caseUnit;
        data["packSize"] = this.packSize;
        data["productClassId"] = this.productClassId;
        data["subProductClassId"] = this.subProductClassId;
        data["brandId"] = this.brandId;
        data["updateDate"] = this.updateDate ? this.updateDate.toISOString() : <any>undefined;
        data["point"] = this.point;
        data["brandName"] = this.brandName;
        data["productClassName"] = this.productClassName;
        data["subProductClassName"] = this.subProductClassName;
        data["status"] = this.status;
        return data;
    }

    clone(): ProductItemDto {
        const json = this.toJSON();
        let result = new ProductItemDto();
        result.init(json);
        return result;
    }
}

export interface IProductItemDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    isActive?: boolean;
    unit?: string | undefined;
    caseUnit?: string | undefined;
    packSize?: number;
    productClassId?: number | undefined;
    subProductClassId?: number | undefined;
    brandId?: number | undefined;
    updateDate?: Date;
    point?: number;
    brandName?: string | undefined;
    productClassName?: string | undefined;
    subProductClassName?: string | undefined;
    status?: string | undefined;
}

export class ProductItemDtoApiResultObject implements IProductItemDtoApiResultObject {
    result?: ProductItemDto;
    success?: boolean;

    constructor(data?: IProductItemDtoApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? ProductItemDto.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): ProductItemDtoApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new ProductItemDtoApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data;
    }

    clone(): ProductItemDtoApiResultObject {
        const json = this.toJSON();
        let result = new ProductItemDtoApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IProductItemDtoApiResultObject {
    result?: ProductItemDto;
    success?: boolean;
}

export class ProductListItemDto implements IProductListItemDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    isActive?: boolean;
    unit?: string | undefined;
    caseUnit?: string | undefined;
    packSize?: number;
    productClassId?: number | undefined;
    subProductClassId?: number | undefined;
    brandId?: number | undefined;
    updateDate?: Date;
    point?: number;
    brandName?: string | undefined;
    productClassName?: string | undefined;
    productClassCode?: string | undefined;
    subProductClassName?: string | undefined;

    constructor(data?: IProductListItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.isActive = _data["isActive"];
            this.unit = _data["unit"];
            this.caseUnit = _data["caseUnit"];
            this.packSize = _data["packSize"];
            this.productClassId = _data["productClassId"];
            this.subProductClassId = _data["subProductClassId"];
            this.brandId = _data["brandId"];
            this.updateDate = _data["updateDate"] ? new Date(_data["updateDate"].toString()) : <any>undefined;
            this.point = _data["point"];
            this.brandName = _data["brandName"];
            this.productClassName = _data["productClassName"];
            this.productClassCode = _data["productClassCode"];
            this.subProductClassName = _data["subProductClassName"];
        }
    }

    static fromJS(data: any): ProductListItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductListItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["description"] = this.description;
        data["isActive"] = this.isActive;
        data["unit"] = this.unit;
        data["caseUnit"] = this.caseUnit;
        data["packSize"] = this.packSize;
        data["productClassId"] = this.productClassId;
        data["subProductClassId"] = this.subProductClassId;
        data["brandId"] = this.brandId;
        data["updateDate"] = this.updateDate ? this.updateDate.toISOString() : <any>undefined;
        data["point"] = this.point;
        data["brandName"] = this.brandName;
        data["productClassName"] = this.productClassName;
        data["productClassCode"] = this.productClassCode;
        data["subProductClassName"] = this.subProductClassName;
        return data;
    }

    clone(): ProductListItemDto {
        const json = this.toJSON();
        let result = new ProductListItemDto();
        result.init(json);
        return result;
    }
}

export interface IProductListItemDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    isActive?: boolean;
    unit?: string | undefined;
    caseUnit?: string | undefined;
    packSize?: number;
    productClassId?: number | undefined;
    subProductClassId?: number | undefined;
    brandId?: number | undefined;
    updateDate?: Date;
    point?: number;
    brandName?: string | undefined;
    productClassName?: string | undefined;
    productClassCode?: string | undefined;
    subProductClassName?: string | undefined;
}

export class ProductListItemDtoPagingResult implements IProductListItemDtoPagingResult {
    items?: ProductListItemDto[] | undefined;
    totalCount?: number;

    constructor(data?: IProductListItemDtoPagingResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProductListItemDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ProductListItemDtoPagingResult {
        data = typeof data === 'object' ? data : {};
        let result = new ProductListItemDtoPagingResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ProductListItemDtoPagingResult {
        const json = this.toJSON();
        let result = new ProductListItemDtoPagingResult();
        result.init(json);
        return result;
    }
}

export interface IProductListItemDtoPagingResult {
    items?: ProductListItemDto[] | undefined;
    totalCount?: number;
}

export class ProductListItemDtoPagingResultApiResultObject implements IProductListItemDtoPagingResultApiResultObject {
    result?: ProductListItemDtoPagingResult;
    success?: boolean;

    constructor(data?: IProductListItemDtoPagingResultApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? ProductListItemDtoPagingResult.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): ProductListItemDtoPagingResultApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new ProductListItemDtoPagingResultApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data;
    }

    clone(): ProductListItemDtoPagingResultApiResultObject {
        const json = this.toJSON();
        let result = new ProductListItemDtoPagingResultApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IProductListItemDtoPagingResultApiResultObject {
    result?: ProductListItemDtoPagingResult;
    success?: boolean;
}

export class ProductPointDto implements IProductPointDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    productId?: number;
    productCode?: string | undefined;
    productName?: string | undefined;
    unit?: string | undefined;
    productClassId?: number | undefined;
    productClassName?: string | undefined;
    subProductClassName?: string | undefined;
    points?: number;
    fromDate?: Date;
    toDate?: Date;
    isActive?: boolean;

    constructor(data?: IProductPointDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.productId = _data["productId"];
            this.productCode = _data["productCode"];
            this.productName = _data["productName"];
            this.unit = _data["unit"];
            this.productClassId = _data["productClassId"];
            this.productClassName = _data["productClassName"];
            this.subProductClassName = _data["subProductClassName"];
            this.points = _data["points"];
            this.fromDate = _data["fromDate"] ? new Date(_data["fromDate"].toString()) : <any>undefined;
            this.toDate = _data["toDate"] ? new Date(_data["toDate"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): ProductPointDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductPointDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["productId"] = this.productId;
        data["productCode"] = this.productCode;
        data["productName"] = this.productName;
        data["unit"] = this.unit;
        data["productClassId"] = this.productClassId;
        data["productClassName"] = this.productClassName;
        data["subProductClassName"] = this.subProductClassName;
        data["points"] = this.points;
        data["fromDate"] = this.fromDate ? this.fromDate.toISOString() : <any>undefined;
        data["toDate"] = this.toDate ? this.toDate.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): ProductPointDto {
        const json = this.toJSON();
        let result = new ProductPointDto();
        result.init(json);
        return result;
    }
}

export interface IProductPointDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    productId?: number;
    productCode?: string | undefined;
    productName?: string | undefined;
    unit?: string | undefined;
    productClassId?: number | undefined;
    productClassName?: string | undefined;
    subProductClassName?: string | undefined;
    points?: number;
    fromDate?: Date;
    toDate?: Date;
    isActive?: boolean;
}

export class ProductPointDtoApiResultObject implements IProductPointDtoApiResultObject {
    result?: ProductPointDto;
    success?: boolean;

    constructor(data?: IProductPointDtoApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? ProductPointDto.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): ProductPointDtoApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new ProductPointDtoApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data;
    }

    clone(): ProductPointDtoApiResultObject {
        const json = this.toJSON();
        let result = new ProductPointDtoApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IProductPointDtoApiResultObject {
    result?: ProductPointDto;
    success?: boolean;
}

export class ProductPointListItemDto implements IProductPointListItemDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    productId?: number;
    productCode?: string | undefined;
    productName?: string | undefined;
    unit?: string | undefined;
    productClassId?: number | undefined;
    productClassName?: string | undefined;
    subProductClassName?: string | undefined;
    points?: number;
    fromDate?: Date;
    toDate?: Date;
    isActive?: boolean;

    constructor(data?: IProductPointListItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.productId = _data["productId"];
            this.productCode = _data["productCode"];
            this.productName = _data["productName"];
            this.unit = _data["unit"];
            this.productClassId = _data["productClassId"];
            this.productClassName = _data["productClassName"];
            this.subProductClassName = _data["subProductClassName"];
            this.points = _data["points"];
            this.fromDate = _data["fromDate"] ? new Date(_data["fromDate"].toString()) : <any>undefined;
            this.toDate = _data["toDate"] ? new Date(_data["toDate"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): ProductPointListItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductPointListItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["productId"] = this.productId;
        data["productCode"] = this.productCode;
        data["productName"] = this.productName;
        data["unit"] = this.unit;
        data["productClassId"] = this.productClassId;
        data["productClassName"] = this.productClassName;
        data["subProductClassName"] = this.subProductClassName;
        data["points"] = this.points;
        data["fromDate"] = this.fromDate ? this.fromDate.toISOString() : <any>undefined;
        data["toDate"] = this.toDate ? this.toDate.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): ProductPointListItemDto {
        const json = this.toJSON();
        let result = new ProductPointListItemDto();
        result.init(json);
        return result;
    }
}

export interface IProductPointListItemDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    productId?: number;
    productCode?: string | undefined;
    productName?: string | undefined;
    unit?: string | undefined;
    productClassId?: number | undefined;
    productClassName?: string | undefined;
    subProductClassName?: string | undefined;
    points?: number;
    fromDate?: Date;
    toDate?: Date;
    isActive?: boolean;
}

export class ProductPointListItemDtoPagingResult implements IProductPointListItemDtoPagingResult {
    items?: ProductPointListItemDto[] | undefined;
    totalCount?: number;

    constructor(data?: IProductPointListItemDtoPagingResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProductPointListItemDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ProductPointListItemDtoPagingResult {
        data = typeof data === 'object' ? data : {};
        let result = new ProductPointListItemDtoPagingResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ProductPointListItemDtoPagingResult {
        const json = this.toJSON();
        let result = new ProductPointListItemDtoPagingResult();
        result.init(json);
        return result;
    }
}

export interface IProductPointListItemDtoPagingResult {
    items?: ProductPointListItemDto[] | undefined;
    totalCount?: number;
}

export class ProductPointListItemDtoPagingResultApiResultObject implements IProductPointListItemDtoPagingResultApiResultObject {
    result?: ProductPointListItemDtoPagingResult;
    success?: boolean;

    constructor(data?: IProductPointListItemDtoPagingResultApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? ProductPointListItemDtoPagingResult.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): ProductPointListItemDtoPagingResultApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new ProductPointListItemDtoPagingResultApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data;
    }

    clone(): ProductPointListItemDtoPagingResultApiResultObject {
        const json = this.toJSON();
        let result = new ProductPointListItemDtoPagingResultApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IProductPointListItemDtoPagingResultApiResultObject {
    result?: ProductPointListItemDtoPagingResult;
    success?: boolean;
}

export class ProductPointUpsertCommand implements IProductPointUpsertCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: ProductPointUpsertDto;
    readonly handleType?: string | undefined;

    constructor(data?: IProductPointUpsertCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? ProductPointUpsertDto.fromJS(_data["data"]) : <any>undefined;
            (<any>this).handleType = _data["handleType"];
        }
    }

    static fromJS(data: any): ProductPointUpsertCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ProductPointUpsertCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["handleType"] = this.handleType;
        return data;
    }

    clone(): ProductPointUpsertCommand {
        const json = this.toJSON();
        let result = new ProductPointUpsertCommand();
        result.init(json);
        return result;
    }
}

export interface IProductPointUpsertCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: ProductPointUpsertDto;
    handleType?: string | undefined;
}

export class ProductPointUpsertDto implements IProductPointUpsertDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    productId?: number;
    productCode?: string | undefined;
    productName?: string | undefined;
    unit?: string | undefined;
    productClassId?: number | undefined;
    productClassName?: string | undefined;
    subProductClassName?: string | undefined;
    points?: number;
    fromDate?: Date;
    toDate?: Date;
    isActive?: boolean;

    constructor(data?: IProductPointUpsertDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.productId = _data["productId"];
            this.productCode = _data["productCode"];
            this.productName = _data["productName"];
            this.unit = _data["unit"];
            this.productClassId = _data["productClassId"];
            this.productClassName = _data["productClassName"];
            this.subProductClassName = _data["subProductClassName"];
            this.points = _data["points"];
            this.fromDate = _data["fromDate"] ? new Date(_data["fromDate"].toString()) : <any>undefined;
            this.toDate = _data["toDate"] ? new Date(_data["toDate"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): ProductPointUpsertDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductPointUpsertDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["productId"] = this.productId;
        data["productCode"] = this.productCode;
        data["productName"] = this.productName;
        data["unit"] = this.unit;
        data["productClassId"] = this.productClassId;
        data["productClassName"] = this.productClassName;
        data["subProductClassName"] = this.subProductClassName;
        data["points"] = this.points;
        data["fromDate"] = this.fromDate ? this.fromDate.toISOString() : <any>undefined;
        data["toDate"] = this.toDate ? this.toDate.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): ProductPointUpsertDto {
        const json = this.toJSON();
        let result = new ProductPointUpsertDto();
        result.init(json);
        return result;
    }
}

export interface IProductPointUpsertDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    productId?: number;
    productCode?: string | undefined;
    productName?: string | undefined;
    unit?: string | undefined;
    productClassId?: number | undefined;
    productClassName?: string | undefined;
    subProductClassName?: string | undefined;
    points?: number;
    fromDate?: Date;
    toDate?: Date;
    isActive?: boolean;
}

export class ProductUnitDto implements IProductUnitDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    isActive?: boolean;

    constructor(data?: IProductUnitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): ProductUnitDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductUnitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): ProductUnitDto {
        const json = this.toJSON();
        let result = new ProductUnitDto();
        result.init(json);
        return result;
    }
}

export interface IProductUnitDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    isActive?: boolean;
}

export class ProductUnitDtoApiResultObject implements IProductUnitDtoApiResultObject {
    result?: ProductUnitDto;
    success?: boolean;

    constructor(data?: IProductUnitDtoApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? ProductUnitDto.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): ProductUnitDtoApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new ProductUnitDtoApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data;
    }

    clone(): ProductUnitDtoApiResultObject {
        const json = this.toJSON();
        let result = new ProductUnitDtoApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IProductUnitDtoApiResultObject {
    result?: ProductUnitDto;
    success?: boolean;
}

export class ProductUnitDtoPagingResult implements IProductUnitDtoPagingResult {
    items?: ProductUnitDto[] | undefined;
    totalCount?: number;

    constructor(data?: IProductUnitDtoPagingResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProductUnitDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ProductUnitDtoPagingResult {
        data = typeof data === 'object' ? data : {};
        let result = new ProductUnitDtoPagingResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ProductUnitDtoPagingResult {
        const json = this.toJSON();
        let result = new ProductUnitDtoPagingResult();
        result.init(json);
        return result;
    }
}

export interface IProductUnitDtoPagingResult {
    items?: ProductUnitDto[] | undefined;
    totalCount?: number;
}

export class ProductUnitDtoPagingResultApiResultObject implements IProductUnitDtoPagingResultApiResultObject {
    result?: ProductUnitDtoPagingResult;
    success?: boolean;

    constructor(data?: IProductUnitDtoPagingResultApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? ProductUnitDtoPagingResult.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): ProductUnitDtoPagingResultApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new ProductUnitDtoPagingResultApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data;
    }

    clone(): ProductUnitDtoPagingResultApiResultObject {
        const json = this.toJSON();
        let result = new ProductUnitDtoPagingResultApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IProductUnitDtoPagingResultApiResultObject {
    result?: ProductUnitDtoPagingResult;
    success?: boolean;
}

export class ProvinceDto implements IProvinceDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;

    constructor(data?: IProvinceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ProvinceDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProvinceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["name"] = this.name;
        return data;
    }

    clone(): ProvinceDto {
        const json = this.toJSON();
        let result = new ProvinceDto();
        result.init(json);
        return result;
    }
}

export interface IProvinceDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
}

export class ProvinceDtoApiResultObject implements IProvinceDtoApiResultObject {
    result?: ProvinceDto;
    success?: boolean;

    constructor(data?: IProvinceDtoApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? ProvinceDto.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): ProvinceDtoApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new ProvinceDtoApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data;
    }

    clone(): ProvinceDtoApiResultObject {
        const json = this.toJSON();
        let result = new ProvinceDtoApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IProvinceDtoApiResultObject {
    result?: ProvinceDto;
    success?: boolean;
}

export class ProvinceDtoPagingResult implements IProvinceDtoPagingResult {
    items?: ProvinceDto[] | undefined;
    totalCount?: number;

    constructor(data?: IProvinceDtoPagingResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProvinceDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ProvinceDtoPagingResult {
        data = typeof data === 'object' ? data : {};
        let result = new ProvinceDtoPagingResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ProvinceDtoPagingResult {
        const json = this.toJSON();
        let result = new ProvinceDtoPagingResult();
        result.init(json);
        return result;
    }
}

export interface IProvinceDtoPagingResult {
    items?: ProvinceDto[] | undefined;
    totalCount?: number;
}

export class ProvinceDtoPagingResultApiResultObject implements IProvinceDtoPagingResultApiResultObject {
    result?: ProvinceDtoPagingResult;
    success?: boolean;

    constructor(data?: IProvinceDtoPagingResultApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? ProvinceDtoPagingResult.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): ProvinceDtoPagingResultApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new ProvinceDtoPagingResultApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data;
    }

    clone(): ProvinceDtoPagingResultApiResultObject {
        const json = this.toJSON();
        let result = new ProvinceDtoPagingResultApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IProvinceDtoPagingResultApiResultObject {
    result?: ProvinceDtoPagingResult;
    success?: boolean;
}

export class ResetPasswordCommand implements IResetPasswordCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    password?: string | undefined;
    token?: string | undefined;

    constructor(data?: IResetPasswordCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.password = _data["password"];
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): ResetPasswordCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["password"] = this.password;
        data["token"] = this.token;
        return data;
    }

    clone(): ResetPasswordCommand {
        const json = this.toJSON();
        let result = new ResetPasswordCommand();
        result.init(json);
        return result;
    }
}

export interface IResetPasswordCommand {
    commandId?: string;
    occuredDate?: Date;
    password?: string | undefined;
    token?: string | undefined;
}

export class RewardBranchDto implements IRewardBranchDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    isSelected?: boolean;
    branchId?: number;
    areaName?: string | undefined;
    branchCode?: string | undefined;
    branchName?: string | undefined;
    zoneName?: string | undefined;
    zoneId?: number | undefined;
    areaId?: number | undefined;

    constructor(data?: IRewardBranchDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isSelected = _data["isSelected"];
            this.branchId = _data["branchId"];
            this.areaName = _data["areaName"];
            this.branchCode = _data["branchCode"];
            this.branchName = _data["branchName"];
            this.zoneName = _data["zoneName"];
            this.zoneId = _data["zoneId"];
            this.areaId = _data["areaId"];
        }
    }

    static fromJS(data: any): RewardBranchDto {
        data = typeof data === 'object' ? data : {};
        let result = new RewardBranchDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isSelected"] = this.isSelected;
        data["branchId"] = this.branchId;
        data["areaName"] = this.areaName;
        data["branchCode"] = this.branchCode;
        data["branchName"] = this.branchName;
        data["zoneName"] = this.zoneName;
        data["zoneId"] = this.zoneId;
        data["areaId"] = this.areaId;
        return data;
    }

    clone(): RewardBranchDto {
        const json = this.toJSON();
        let result = new RewardBranchDto();
        result.init(json);
        return result;
    }
}

export interface IRewardBranchDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    isSelected?: boolean;
    branchId?: number;
    areaName?: string | undefined;
    branchCode?: string | undefined;
    branchName?: string | undefined;
    zoneName?: string | undefined;
    zoneId?: number | undefined;
    areaId?: number | undefined;
}

export class RewardBranchUpSertDto implements IRewardBranchUpSertDto {
    id?: number;
    branchId?: number;

    constructor(data?: IRewardBranchUpSertDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.branchId = _data["branchId"];
        }
    }

    static fromJS(data: any): RewardBranchUpSertDto {
        data = typeof data === 'object' ? data : {};
        let result = new RewardBranchUpSertDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["branchId"] = this.branchId;
        return data;
    }

    clone(): RewardBranchUpSertDto {
        const json = this.toJSON();
        let result = new RewardBranchUpSertDto();
        result.init(json);
        return result;
    }
}

export interface IRewardBranchUpSertDto {
    id?: number;
    branchId?: number;
}

export class RewardBranchUpSertDtoCrudListDto implements IRewardBranchUpSertDtoCrudListDto {
    upsertedItems?: RewardBranchUpSertDto[] | undefined;
    deletedItems?: RewardBranchUpSertDto[] | undefined;

    constructor(data?: IRewardBranchUpSertDtoCrudListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["upsertedItems"])) {
                this.upsertedItems = [] as any;
                for (let item of _data["upsertedItems"])
                    this.upsertedItems!.push(RewardBranchUpSertDto.fromJS(item));
            }
            if (Array.isArray(_data["deletedItems"])) {
                this.deletedItems = [] as any;
                for (let item of _data["deletedItems"])
                    this.deletedItems!.push(RewardBranchUpSertDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RewardBranchUpSertDtoCrudListDto {
        data = typeof data === 'object' ? data : {};
        let result = new RewardBranchUpSertDtoCrudListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.upsertedItems)) {
            data["upsertedItems"] = [];
            for (let item of this.upsertedItems)
                data["upsertedItems"].push(item.toJSON());
        }
        if (Array.isArray(this.deletedItems)) {
            data["deletedItems"] = [];
            for (let item of this.deletedItems)
                data["deletedItems"].push(item.toJSON());
        }
        return data;
    }

    clone(): RewardBranchUpSertDtoCrudListDto {
        const json = this.toJSON();
        let result = new RewardBranchUpSertDtoCrudListDto();
        result.init(json);
        return result;
    }
}

export interface IRewardBranchUpSertDtoCrudListDto {
    upsertedItems?: RewardBranchUpSertDto[] | undefined;
    deletedItems?: RewardBranchUpSertDto[] | undefined;
}

export class RewardItemDto implements IRewardItemDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    documentLink?: string | undefined;
    productUnitId?: number | undefined;
    productUnitCode?: string | undefined;
    productUnitName?: string | undefined;
    price?: number;
    quantity?: number;
    productId?: number | undefined;
    productCode?: string | undefined;
    productName?: string | undefined;

    constructor(data?: IRewardItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.documentLink = _data["documentLink"];
            this.productUnitId = _data["productUnitId"];
            this.productUnitCode = _data["productUnitCode"];
            this.productUnitName = _data["productUnitName"];
            this.price = _data["price"];
            this.quantity = _data["quantity"];
            this.productId = _data["productId"];
            this.productCode = _data["productCode"];
            this.productName = _data["productName"];
        }
    }

    static fromJS(data: any): RewardItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new RewardItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["documentLink"] = this.documentLink;
        data["productUnitId"] = this.productUnitId;
        data["productUnitCode"] = this.productUnitCode;
        data["productUnitName"] = this.productUnitName;
        data["price"] = this.price;
        data["quantity"] = this.quantity;
        data["productId"] = this.productId;
        data["productCode"] = this.productCode;
        data["productName"] = this.productName;
        return data;
    }

    clone(): RewardItemDto {
        const json = this.toJSON();
        let result = new RewardItemDto();
        result.init(json);
        return result;
    }
}

export interface IRewardItemDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    documentLink?: string | undefined;
    productUnitId?: number | undefined;
    productUnitCode?: string | undefined;
    productUnitName?: string | undefined;
    price?: number;
    quantity?: number;
    productId?: number | undefined;
    productCode?: string | undefined;
    productName?: string | undefined;
}

export class RewardItemUpsertDto implements IRewardItemUpsertDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    documentLink?: string | undefined;
    productUnitId?: number | undefined;
    price?: number;
    quantity?: number;
    productId?: number | undefined;

    constructor(data?: IRewardItemUpsertDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.documentLink = _data["documentLink"];
            this.productUnitId = _data["productUnitId"];
            this.price = _data["price"];
            this.quantity = _data["quantity"];
            this.productId = _data["productId"];
        }
    }

    static fromJS(data: any): RewardItemUpsertDto {
        data = typeof data === 'object' ? data : {};
        let result = new RewardItemUpsertDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["documentLink"] = this.documentLink;
        data["productUnitId"] = this.productUnitId;
        data["price"] = this.price;
        data["quantity"] = this.quantity;
        data["productId"] = this.productId;
        return data;
    }

    clone(): RewardItemUpsertDto {
        const json = this.toJSON();
        let result = new RewardItemUpsertDto();
        result.init(json);
        return result;
    }
}

export interface IRewardItemUpsertDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    documentLink?: string | undefined;
    productUnitId?: number | undefined;
    price?: number;
    quantity?: number;
    productId?: number | undefined;
}

export class RewardItemUpsertDtoCrudListDto implements IRewardItemUpsertDtoCrudListDto {
    upsertedItems?: RewardItemUpsertDto[] | undefined;
    deletedItems?: RewardItemUpsertDto[] | undefined;

    constructor(data?: IRewardItemUpsertDtoCrudListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["upsertedItems"])) {
                this.upsertedItems = [] as any;
                for (let item of _data["upsertedItems"])
                    this.upsertedItems!.push(RewardItemUpsertDto.fromJS(item));
            }
            if (Array.isArray(_data["deletedItems"])) {
                this.deletedItems = [] as any;
                for (let item of _data["deletedItems"])
                    this.deletedItems!.push(RewardItemUpsertDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RewardItemUpsertDtoCrudListDto {
        data = typeof data === 'object' ? data : {};
        let result = new RewardItemUpsertDtoCrudListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.upsertedItems)) {
            data["upsertedItems"] = [];
            for (let item of this.upsertedItems)
                data["upsertedItems"].push(item.toJSON());
        }
        if (Array.isArray(this.deletedItems)) {
            data["deletedItems"] = [];
            for (let item of this.deletedItems)
                data["deletedItems"].push(item.toJSON());
        }
        return data;
    }

    clone(): RewardItemUpsertDtoCrudListDto {
        const json = this.toJSON();
        let result = new RewardItemUpsertDtoCrudListDto();
        result.init(json);
        return result;
    }
}

export interface IRewardItemUpsertDtoCrudListDto {
    upsertedItems?: RewardItemUpsertDto[] | undefined;
    deletedItems?: RewardItemUpsertDto[] | undefined;
}

export class RewardPackageDto implements IRewardPackageDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    isActive?: boolean;
    type?: number;
    fromDate?: Date;
    toDate?: Date;
    totalAmount?: number;
    totalTickets?: number;
    rewardItems?: RewardItemDto[] | undefined;
    rewardBranches?: RewardBranchDto[] | undefined;

    constructor(data?: IRewardPackageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
            this.type = _data["type"];
            this.fromDate = _data["fromDate"] ? new Date(_data["fromDate"].toString()) : <any>undefined;
            this.toDate = _data["toDate"] ? new Date(_data["toDate"].toString()) : <any>undefined;
            this.totalAmount = _data["totalAmount"];
            this.totalTickets = _data["totalTickets"];
            if (Array.isArray(_data["rewardItems"])) {
                this.rewardItems = [] as any;
                for (let item of _data["rewardItems"])
                    this.rewardItems!.push(RewardItemDto.fromJS(item));
            }
            if (Array.isArray(_data["rewardBranches"])) {
                this.rewardBranches = [] as any;
                for (let item of _data["rewardBranches"])
                    this.rewardBranches!.push(RewardBranchDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RewardPackageDto {
        data = typeof data === 'object' ? data : {};
        let result = new RewardPackageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        data["type"] = this.type;
        data["fromDate"] = this.fromDate ? this.fromDate.toISOString() : <any>undefined;
        data["toDate"] = this.toDate ? this.toDate.toISOString() : <any>undefined;
        data["totalAmount"] = this.totalAmount;
        data["totalTickets"] = this.totalTickets;
        if (Array.isArray(this.rewardItems)) {
            data["rewardItems"] = [];
            for (let item of this.rewardItems)
                data["rewardItems"].push(item.toJSON());
        }
        if (Array.isArray(this.rewardBranches)) {
            data["rewardBranches"] = [];
            for (let item of this.rewardBranches)
                data["rewardBranches"].push(item.toJSON());
        }
        return data;
    }

    clone(): RewardPackageDto {
        const json = this.toJSON();
        let result = new RewardPackageDto();
        result.init(json);
        return result;
    }
}

export interface IRewardPackageDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    isActive?: boolean;
    type?: number;
    fromDate?: Date;
    toDate?: Date;
    totalAmount?: number;
    totalTickets?: number;
    rewardItems?: RewardItemDto[] | undefined;
    rewardBranches?: RewardBranchDto[] | undefined;
}

export class RewardPackageDtoApiResultObject implements IRewardPackageDtoApiResultObject {
    result?: RewardPackageDto;
    success?: boolean;

    constructor(data?: IRewardPackageDtoApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? RewardPackageDto.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): RewardPackageDtoApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new RewardPackageDtoApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data;
    }

    clone(): RewardPackageDtoApiResultObject {
        const json = this.toJSON();
        let result = new RewardPackageDtoApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IRewardPackageDtoApiResultObject {
    result?: RewardPackageDto;
    success?: boolean;
}

export class RewardPackageListDto implements IRewardPackageListDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    isActive?: boolean;
    type?: number;
    fromDate?: Date;
    toDate?: Date;
    totalAmount?: number;
    totalTickets?: number;

    constructor(data?: IRewardPackageListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
            this.type = _data["type"];
            this.fromDate = _data["fromDate"] ? new Date(_data["fromDate"].toString()) : <any>undefined;
            this.toDate = _data["toDate"] ? new Date(_data["toDate"].toString()) : <any>undefined;
            this.totalAmount = _data["totalAmount"];
            this.totalTickets = _data["totalTickets"];
        }
    }

    static fromJS(data: any): RewardPackageListDto {
        data = typeof data === 'object' ? data : {};
        let result = new RewardPackageListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        data["type"] = this.type;
        data["fromDate"] = this.fromDate ? this.fromDate.toISOString() : <any>undefined;
        data["toDate"] = this.toDate ? this.toDate.toISOString() : <any>undefined;
        data["totalAmount"] = this.totalAmount;
        data["totalTickets"] = this.totalTickets;
        return data;
    }

    clone(): RewardPackageListDto {
        const json = this.toJSON();
        let result = new RewardPackageListDto();
        result.init(json);
        return result;
    }
}

export interface IRewardPackageListDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    isActive?: boolean;
    type?: number;
    fromDate?: Date;
    toDate?: Date;
    totalAmount?: number;
    totalTickets?: number;
}

export class RewardPackageListDtoPagingResult implements IRewardPackageListDtoPagingResult {
    items?: RewardPackageListDto[] | undefined;
    totalCount?: number;

    constructor(data?: IRewardPackageListDtoPagingResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(RewardPackageListDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): RewardPackageListDtoPagingResult {
        data = typeof data === 'object' ? data : {};
        let result = new RewardPackageListDtoPagingResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): RewardPackageListDtoPagingResult {
        const json = this.toJSON();
        let result = new RewardPackageListDtoPagingResult();
        result.init(json);
        return result;
    }
}

export interface IRewardPackageListDtoPagingResult {
    items?: RewardPackageListDto[] | undefined;
    totalCount?: number;
}

export class RewardPackageListDtoPagingResultApiResultObject implements IRewardPackageListDtoPagingResultApiResultObject {
    result?: RewardPackageListDtoPagingResult;
    success?: boolean;

    constructor(data?: IRewardPackageListDtoPagingResultApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? RewardPackageListDtoPagingResult.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): RewardPackageListDtoPagingResultApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new RewardPackageListDtoPagingResultApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data;
    }

    clone(): RewardPackageListDtoPagingResultApiResultObject {
        const json = this.toJSON();
        let result = new RewardPackageListDtoPagingResultApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IRewardPackageListDtoPagingResultApiResultObject {
    result?: RewardPackageListDtoPagingResult;
    success?: boolean;
}

export class RewardPackageUpsertCommand implements IRewardPackageUpsertCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: RewardPackageUpsertDto;
    readonly handleType?: string | undefined;

    constructor(data?: IRewardPackageUpsertCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? RewardPackageUpsertDto.fromJS(_data["data"]) : <any>undefined;
            (<any>this).handleType = _data["handleType"];
        }
    }

    static fromJS(data: any): RewardPackageUpsertCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RewardPackageUpsertCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["handleType"] = this.handleType;
        return data;
    }

    clone(): RewardPackageUpsertCommand {
        const json = this.toJSON();
        let result = new RewardPackageUpsertCommand();
        result.init(json);
        return result;
    }
}

export interface IRewardPackageUpsertCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: RewardPackageUpsertDto;
    handleType?: string | undefined;
}

export class RewardPackageUpsertDto implements IRewardPackageUpsertDto {
    id?: number;
    code?: string | undefined;
    name?: string | undefined;
    isActive?: boolean;
    type?: number;
    fromDate?: Date;
    toDate?: Date;
    rewardItemChanges?: RewardItemUpsertDtoCrudListDto;
    rewardBranchChanges?: RewardBranchUpSertDtoCrudListDto;

    constructor(data?: IRewardPackageUpsertDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
            this.type = _data["type"];
            this.fromDate = _data["fromDate"] ? new Date(_data["fromDate"].toString()) : <any>undefined;
            this.toDate = _data["toDate"] ? new Date(_data["toDate"].toString()) : <any>undefined;
            this.rewardItemChanges = _data["rewardItemChanges"] ? RewardItemUpsertDtoCrudListDto.fromJS(_data["rewardItemChanges"]) : <any>undefined;
            this.rewardBranchChanges = _data["rewardBranchChanges"] ? RewardBranchUpSertDtoCrudListDto.fromJS(_data["rewardBranchChanges"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RewardPackageUpsertDto {
        data = typeof data === 'object' ? data : {};
        let result = new RewardPackageUpsertDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        data["type"] = this.type;
        data["fromDate"] = this.fromDate ? this.fromDate.toISOString() : <any>undefined;
        data["toDate"] = this.toDate ? this.toDate.toISOString() : <any>undefined;
        data["rewardItemChanges"] = this.rewardItemChanges ? this.rewardItemChanges.toJSON() : <any>undefined;
        data["rewardBranchChanges"] = this.rewardBranchChanges ? this.rewardBranchChanges.toJSON() : <any>undefined;
        return data;
    }

    clone(): RewardPackageUpsertDto {
        const json = this.toJSON();
        let result = new RewardPackageUpsertDto();
        result.init(json);
        return result;
    }
}

export interface IRewardPackageUpsertDto {
    id?: number;
    code?: string | undefined;
    name?: string | undefined;
    isActive?: boolean;
    type?: number;
    fromDate?: Date;
    toDate?: Date;
    rewardItemChanges?: RewardItemUpsertDtoCrudListDto;
    rewardBranchChanges?: RewardBranchUpSertDtoCrudListDto;
}

export class RoleDto implements IRoleDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    roleName?: string | undefined;
    displayName?: string | undefined;
    description?: string | undefined;
    isActive?: boolean;
    permissions?: RolePermissionDto[] | undefined;

    constructor(data?: IRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.roleName = _data["roleName"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(RolePermissionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["roleName"] = this.roleName;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        return data;
    }

    clone(): RoleDto {
        const json = this.toJSON();
        let result = new RoleDto();
        result.init(json);
        return result;
    }
}

export interface IRoleDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    roleName?: string | undefined;
    displayName?: string | undefined;
    description?: string | undefined;
    isActive?: boolean;
    permissions?: RolePermissionDto[] | undefined;
}

export class RoleDtoApiResultObject implements IRoleDtoApiResultObject {
    result?: RoleDto;
    success?: boolean;

    constructor(data?: IRoleDtoApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? RoleDto.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): RoleDtoApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDtoApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data;
    }

    clone(): RoleDtoApiResultObject {
        const json = this.toJSON();
        let result = new RoleDtoApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IRoleDtoApiResultObject {
    result?: RoleDto;
    success?: boolean;
}

export class RoleListItemDto implements IRoleListItemDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    roleName?: string | undefined;
    displayName?: string | undefined;
    description?: string | undefined;
    isActive?: boolean;

    constructor(data?: IRoleListItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.roleName = _data["roleName"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): RoleListItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleListItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["roleName"] = this.roleName;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): RoleListItemDto {
        const json = this.toJSON();
        let result = new RoleListItemDto();
        result.init(json);
        return result;
    }
}

export interface IRoleListItemDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    roleName?: string | undefined;
    displayName?: string | undefined;
    description?: string | undefined;
    isActive?: boolean;
}

export class RoleListItemDtoPagingResult implements IRoleListItemDtoPagingResult {
    items?: RoleListItemDto[] | undefined;
    totalCount?: number;

    constructor(data?: IRoleListItemDtoPagingResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(RoleListItemDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): RoleListItemDtoPagingResult {
        data = typeof data === 'object' ? data : {};
        let result = new RoleListItemDtoPagingResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): RoleListItemDtoPagingResult {
        const json = this.toJSON();
        let result = new RoleListItemDtoPagingResult();
        result.init(json);
        return result;
    }
}

export interface IRoleListItemDtoPagingResult {
    items?: RoleListItemDto[] | undefined;
    totalCount?: number;
}

export class RoleListItemDtoPagingResultApiResultObject implements IRoleListItemDtoPagingResultApiResultObject {
    result?: RoleListItemDtoPagingResult;
    success?: boolean;

    constructor(data?: IRoleListItemDtoPagingResultApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? RoleListItemDtoPagingResult.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): RoleListItemDtoPagingResultApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new RoleListItemDtoPagingResultApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data;
    }

    clone(): RoleListItemDtoPagingResultApiResultObject {
        const json = this.toJSON();
        let result = new RoleListItemDtoPagingResultApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IRoleListItemDtoPagingResultApiResultObject {
    result?: RoleListItemDtoPagingResult;
    success?: boolean;
}

export class RolePermissionDto implements IRolePermissionDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    permissionId?: number;
    permissionCode?: string | undefined;
    permissionName?: string | undefined;
    description?: string | undefined;

    constructor(data?: IRolePermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.permissionId = _data["permissionId"];
            this.permissionCode = _data["permissionCode"];
            this.permissionName = _data["permissionName"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): RolePermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new RolePermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["permissionId"] = this.permissionId;
        data["permissionCode"] = this.permissionCode;
        data["permissionName"] = this.permissionName;
        data["description"] = this.description;
        return data;
    }

    clone(): RolePermissionDto {
        const json = this.toJSON();
        let result = new RolePermissionDto();
        result.init(json);
        return result;
    }
}

export interface IRolePermissionDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    permissionId?: number;
    permissionCode?: string | undefined;
    permissionName?: string | undefined;
    description?: string | undefined;
}

export class RolePermissionDtoCrudListDto implements IRolePermissionDtoCrudListDto {
    upsertedItems?: RolePermissionDto[] | undefined;
    deletedItems?: RolePermissionDto[] | undefined;

    constructor(data?: IRolePermissionDtoCrudListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["upsertedItems"])) {
                this.upsertedItems = [] as any;
                for (let item of _data["upsertedItems"])
                    this.upsertedItems!.push(RolePermissionDto.fromJS(item));
            }
            if (Array.isArray(_data["deletedItems"])) {
                this.deletedItems = [] as any;
                for (let item of _data["deletedItems"])
                    this.deletedItems!.push(RolePermissionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RolePermissionDtoCrudListDto {
        data = typeof data === 'object' ? data : {};
        let result = new RolePermissionDtoCrudListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.upsertedItems)) {
            data["upsertedItems"] = [];
            for (let item of this.upsertedItems)
                data["upsertedItems"].push(item.toJSON());
        }
        if (Array.isArray(this.deletedItems)) {
            data["deletedItems"] = [];
            for (let item of this.deletedItems)
                data["deletedItems"].push(item.toJSON());
        }
        return data;
    }

    clone(): RolePermissionDtoCrudListDto {
        const json = this.toJSON();
        let result = new RolePermissionDtoCrudListDto();
        result.init(json);
        return result;
    }
}

export interface IRolePermissionDtoCrudListDto {
    upsertedItems?: RolePermissionDto[] | undefined;
    deletedItems?: RolePermissionDto[] | undefined;
}

export class SalesAppSettingDto implements ISalesAppSettingDto {
    code?: string | undefined;
    value?: string | undefined;

    constructor(data?: ISalesAppSettingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): SalesAppSettingDto {
        data = typeof data === 'object' ? data : {};
        let result = new SalesAppSettingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["value"] = this.value;
        return data;
    }

    clone(): SalesAppSettingDto {
        const json = this.toJSON();
        let result = new SalesAppSettingDto();
        result.init(json);
        return result;
    }
}

export interface ISalesAppSettingDto {
    code?: string | undefined;
    value?: string | undefined;
}

export class SalesAppSettingDtoListApiResultObject implements ISalesAppSettingDtoListApiResultObject {
    result?: SalesAppSettingDto[] | undefined;
    success?: boolean;

    constructor(data?: ISalesAppSettingDtoListApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(SalesAppSettingDto.fromJS(item));
            }
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): SalesAppSettingDtoListApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new SalesAppSettingDtoListApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["success"] = this.success;
        return data;
    }

    clone(): SalesAppSettingDtoListApiResultObject {
        const json = this.toJSON();
        let result = new SalesAppSettingDtoListApiResultObject();
        result.init(json);
        return result;
    }
}

export interface ISalesAppSettingDtoListApiResultObject {
    result?: SalesAppSettingDto[] | undefined;
    success?: boolean;
}

export class SendEmailResetPasswordCommand implements ISendEmailResetPasswordCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    username?: string | undefined;
    email?: string | undefined;
    returnUrl?: string | undefined;

    constructor(data?: ISendEmailResetPasswordCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.username = _data["username"];
            this.email = _data["email"];
            this.returnUrl = _data["returnUrl"];
        }
    }

    static fromJS(data: any): SendEmailResetPasswordCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SendEmailResetPasswordCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["username"] = this.username;
        data["email"] = this.email;
        data["returnUrl"] = this.returnUrl;
        return data;
    }

    clone(): SendEmailResetPasswordCommand {
        const json = this.toJSON();
        let result = new SendEmailResetPasswordCommand();
        result.init(json);
        return result;
    }
}

export interface ISendEmailResetPasswordCommand {
    commandId?: string;
    occuredDate?: Date;
    username?: string | undefined;
    email?: string | undefined;
    returnUrl?: string | undefined;
}

export class ShopAppSettingDto implements IShopAppSettingDto {
    code?: string | undefined;
    value?: string | undefined;

    constructor(data?: IShopAppSettingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): ShopAppSettingDto {
        data = typeof data === 'object' ? data : {};
        let result = new ShopAppSettingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["value"] = this.value;
        return data;
    }

    clone(): ShopAppSettingDto {
        const json = this.toJSON();
        let result = new ShopAppSettingDto();
        result.init(json);
        return result;
    }
}

export interface IShopAppSettingDto {
    code?: string | undefined;
    value?: string | undefined;
}

export class ShopAppSettingDtoListApiResultObject implements IShopAppSettingDtoListApiResultObject {
    result?: ShopAppSettingDto[] | undefined;
    success?: boolean;

    constructor(data?: IShopAppSettingDtoListApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(ShopAppSettingDto.fromJS(item));
            }
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): ShopAppSettingDtoListApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new ShopAppSettingDtoListApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["success"] = this.success;
        return data;
    }

    clone(): ShopAppSettingDtoListApiResultObject {
        const json = this.toJSON();
        let result = new ShopAppSettingDtoListApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IShopAppSettingDtoListApiResultObject {
    result?: ShopAppSettingDto[] | undefined;
    success?: boolean;
}

export class StaffDto implements IStaffDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    salesOrgId?: number;
    staffTypeCode?: string | undefined;
    staffTypeName?: string | undefined;
    updateDate?: Date;
    mobilePhone?: string | undefined;
    birthday?: Date;
    email?: string | undefined;
    userId?: number;
    areaId?: number | undefined;
    zoneId?: number | undefined;

    constructor(data?: IStaffDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.salesOrgId = _data["salesOrgId"];
            this.staffTypeCode = _data["staffTypeCode"];
            this.staffTypeName = _data["staffTypeName"];
            this.updateDate = _data["updateDate"] ? new Date(_data["updateDate"].toString()) : <any>undefined;
            this.mobilePhone = _data["mobilePhone"];
            this.birthday = _data["birthday"] ? new Date(_data["birthday"].toString()) : <any>undefined;
            this.email = _data["email"];
            this.userId = _data["userId"];
            this.areaId = _data["areaId"];
            this.zoneId = _data["zoneId"];
        }
    }

    static fromJS(data: any): StaffDto {
        data = typeof data === 'object' ? data : {};
        let result = new StaffDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["salesOrgId"] = this.salesOrgId;
        data["staffTypeCode"] = this.staffTypeCode;
        data["staffTypeName"] = this.staffTypeName;
        data["updateDate"] = this.updateDate ? this.updateDate.toISOString() : <any>undefined;
        data["mobilePhone"] = this.mobilePhone;
        data["birthday"] = this.birthday ? this.birthday.toISOString() : <any>undefined;
        data["email"] = this.email;
        data["userId"] = this.userId;
        data["areaId"] = this.areaId;
        data["zoneId"] = this.zoneId;
        return data;
    }

    clone(): StaffDto {
        const json = this.toJSON();
        let result = new StaffDto();
        result.init(json);
        return result;
    }
}

export interface IStaffDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    salesOrgId?: number;
    staffTypeCode?: string | undefined;
    staffTypeName?: string | undefined;
    updateDate?: Date;
    mobilePhone?: string | undefined;
    birthday?: Date;
    email?: string | undefined;
    userId?: number;
    areaId?: number | undefined;
    zoneId?: number | undefined;
}

export class StaffDtoApiResultObject implements IStaffDtoApiResultObject {
    result?: StaffDto;
    success?: boolean;

    constructor(data?: IStaffDtoApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? StaffDto.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): StaffDtoApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new StaffDtoApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data;
    }

    clone(): StaffDtoApiResultObject {
        const json = this.toJSON();
        let result = new StaffDtoApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IStaffDtoApiResultObject {
    result?: StaffDto;
    success?: boolean;
}

export class StaffListDto implements IStaffListDto {
    id?: number;
    code?: string | undefined;
    name?: string | undefined;
    staffTypeCode?: string | undefined;
    staffTypeName?: string | undefined;
    updateDate?: Date;
    mobilePhone?: string | undefined;
    birthday?: Date | undefined;
    email?: string | undefined;
    isActive?: boolean;

    constructor(data?: IStaffListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.staffTypeCode = _data["staffTypeCode"];
            this.staffTypeName = _data["staffTypeName"];
            this.updateDate = _data["updateDate"] ? new Date(_data["updateDate"].toString()) : <any>undefined;
            this.mobilePhone = _data["mobilePhone"];
            this.birthday = _data["birthday"] ? new Date(_data["birthday"].toString()) : <any>undefined;
            this.email = _data["email"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): StaffListDto {
        data = typeof data === 'object' ? data : {};
        let result = new StaffListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["name"] = this.name;
        data["staffTypeCode"] = this.staffTypeCode;
        data["staffTypeName"] = this.staffTypeName;
        data["updateDate"] = this.updateDate ? this.updateDate.toISOString() : <any>undefined;
        data["mobilePhone"] = this.mobilePhone;
        data["birthday"] = this.birthday ? this.birthday.toISOString() : <any>undefined;
        data["email"] = this.email;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): StaffListDto {
        const json = this.toJSON();
        let result = new StaffListDto();
        result.init(json);
        return result;
    }
}

export interface IStaffListDto {
    id?: number;
    code?: string | undefined;
    name?: string | undefined;
    staffTypeCode?: string | undefined;
    staffTypeName?: string | undefined;
    updateDate?: Date;
    mobilePhone?: string | undefined;
    birthday?: Date | undefined;
    email?: string | undefined;
    isActive?: boolean;
}

export class StaffListDtoApiResultObject implements IStaffListDtoApiResultObject {
    result?: StaffListDto;
    success?: boolean;

    constructor(data?: IStaffListDtoApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? StaffListDto.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): StaffListDtoApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new StaffListDtoApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data;
    }

    clone(): StaffListDtoApiResultObject {
        const json = this.toJSON();
        let result = new StaffListDtoApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IStaffListDtoApiResultObject {
    result?: StaffListDto;
    success?: boolean;
}

export class StaffListDtoPagingResult implements IStaffListDtoPagingResult {
    items?: StaffListDto[] | undefined;
    totalCount?: number;

    constructor(data?: IStaffListDtoPagingResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(StaffListDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): StaffListDtoPagingResult {
        data = typeof data === 'object' ? data : {};
        let result = new StaffListDtoPagingResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): StaffListDtoPagingResult {
        const json = this.toJSON();
        let result = new StaffListDtoPagingResult();
        result.init(json);
        return result;
    }
}

export interface IStaffListDtoPagingResult {
    items?: StaffListDto[] | undefined;
    totalCount?: number;
}

export class StaffListDtoPagingResultApiResultObject implements IStaffListDtoPagingResultApiResultObject {
    result?: StaffListDtoPagingResult;
    success?: boolean;

    constructor(data?: IStaffListDtoPagingResultApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? StaffListDtoPagingResult.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): StaffListDtoPagingResultApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new StaffListDtoPagingResultApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data;
    }

    clone(): StaffListDtoPagingResultApiResultObject {
        const json = this.toJSON();
        let result = new StaffListDtoPagingResultApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IStaffListDtoPagingResultApiResultObject {
    result?: StaffListDtoPagingResult;
    success?: boolean;
}

export class StaffRegisterCommand implements IStaffRegisterCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: StaffRegisterDto;

    constructor(data?: IStaffRegisterCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? StaffRegisterDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): StaffRegisterCommand {
        data = typeof data === 'object' ? data : {};
        let result = new StaffRegisterCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }

    clone(): StaffRegisterCommand {
        const json = this.toJSON();
        let result = new StaffRegisterCommand();
        result.init(json);
        return result;
    }
}

export interface IStaffRegisterCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: StaffRegisterDto;
}

export class StaffRegisterDto implements IStaffRegisterDto {
    userName?: string | undefined;
    fullName?: string | undefined;
    phone?: string | undefined;
    password?: string | undefined;
    email?: string | undefined;

    constructor(data?: IStaffRegisterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.fullName = _data["fullName"];
            this.phone = _data["phone"];
            this.password = _data["password"];
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): StaffRegisterDto {
        data = typeof data === 'object' ? data : {};
        let result = new StaffRegisterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["fullName"] = this.fullName;
        data["phone"] = this.phone;
        data["password"] = this.password;
        data["email"] = this.email;
        return data;
    }

    clone(): StaffRegisterDto {
        const json = this.toJSON();
        let result = new StaffRegisterDto();
        result.init(json);
        return result;
    }
}

export interface IStaffRegisterDto {
    userName?: string | undefined;
    fullName?: string | undefined;
    phone?: string | undefined;
    password?: string | undefined;
    email?: string | undefined;
}

export class StaffUpdateCreditPointCommand implements IStaffUpdateCreditPointCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: StaffUpdateCreditPointDto;

    constructor(data?: IStaffUpdateCreditPointCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? StaffUpdateCreditPointDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): StaffUpdateCreditPointCommand {
        data = typeof data === 'object' ? data : {};
        let result = new StaffUpdateCreditPointCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }

    clone(): StaffUpdateCreditPointCommand {
        const json = this.toJSON();
        let result = new StaffUpdateCreditPointCommand();
        result.init(json);
        return result;
    }
}

export interface IStaffUpdateCreditPointCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: StaffUpdateCreditPointDto;
}

export class StaffUpdateCreditPointDto implements IStaffUpdateCreditPointDto {
    staffId?: number;
    creditPoint?: number;

    constructor(data?: IStaffUpdateCreditPointDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.staffId = _data["staffId"];
            this.creditPoint = _data["creditPoint"];
        }
    }

    static fromJS(data: any): StaffUpdateCreditPointDto {
        data = typeof data === 'object' ? data : {};
        let result = new StaffUpdateCreditPointDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["staffId"] = this.staffId;
        data["creditPoint"] = this.creditPoint;
        return data;
    }

    clone(): StaffUpdateCreditPointDto {
        const json = this.toJSON();
        let result = new StaffUpdateCreditPointDto();
        result.init(json);
        return result;
    }
}

export interface IStaffUpdateCreditPointDto {
    staffId?: number;
    creditPoint?: number;
}

export class Stream implements IStream {
    readonly canRead?: boolean;
    readonly canSeek?: boolean;
    readonly canTimeout?: boolean;
    readonly canWrite?: boolean;
    readonly length?: number;
    position?: number;
    readTimeout?: number;
    writeTimeout?: number;

    constructor(data?: IStream) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).canRead = _data["canRead"];
            (<any>this).canSeek = _data["canSeek"];
            (<any>this).canTimeout = _data["canTimeout"];
            (<any>this).canWrite = _data["canWrite"];
            (<any>this).length = _data["length"];
            this.position = _data["position"];
            this.readTimeout = _data["readTimeout"];
            this.writeTimeout = _data["writeTimeout"];
        }
    }

    static fromJS(data: any): Stream {
        data = typeof data === 'object' ? data : {};
        let result = new Stream();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canRead"] = this.canRead;
        data["canSeek"] = this.canSeek;
        data["canTimeout"] = this.canTimeout;
        data["canWrite"] = this.canWrite;
        data["length"] = this.length;
        data["position"] = this.position;
        data["readTimeout"] = this.readTimeout;
        data["writeTimeout"] = this.writeTimeout;
        return data;
    }

    clone(): Stream {
        const json = this.toJSON();
        let result = new Stream();
        result.init(json);
        return result;
    }
}

export interface IStream {
    canRead?: boolean;
    canSeek?: boolean;
    canTimeout?: boolean;
    canWrite?: boolean;
    length?: number;
    position?: number;
    readTimeout?: number;
    writeTimeout?: number;
}

export class StringApiResultObject implements IStringApiResultObject {
    result?: string | undefined;
    success?: boolean;

    constructor(data?: IStringApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"];
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): StringApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new StringApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result;
        data["success"] = this.success;
        return data;
    }

    clone(): StringApiResultObject {
        const json = this.toJSON();
        let result = new StringApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IStringApiResultObject {
    result?: string | undefined;
    success?: boolean;
}

export class SubProductClassDto implements ISubProductClassDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    isActive?: boolean;

    constructor(data?: ISubProductClassDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): SubProductClassDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubProductClassDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): SubProductClassDto {
        const json = this.toJSON();
        let result = new SubProductClassDto();
        result.init(json);
        return result;
    }
}

export interface ISubProductClassDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    isActive?: boolean;
}

export class SubProductClassDtoApiResultObject implements ISubProductClassDtoApiResultObject {
    result?: SubProductClassDto;
    success?: boolean;

    constructor(data?: ISubProductClassDtoApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? SubProductClassDto.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): SubProductClassDtoApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new SubProductClassDtoApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data;
    }

    clone(): SubProductClassDtoApiResultObject {
        const json = this.toJSON();
        let result = new SubProductClassDtoApiResultObject();
        result.init(json);
        return result;
    }
}

export interface ISubProductClassDtoApiResultObject {
    result?: SubProductClassDto;
    success?: boolean;
}

export class SubProductClassDtoPagingResult implements ISubProductClassDtoPagingResult {
    items?: SubProductClassDto[] | undefined;
    totalCount?: number;

    constructor(data?: ISubProductClassDtoPagingResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SubProductClassDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): SubProductClassDtoPagingResult {
        data = typeof data === 'object' ? data : {};
        let result = new SubProductClassDtoPagingResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): SubProductClassDtoPagingResult {
        const json = this.toJSON();
        let result = new SubProductClassDtoPagingResult();
        result.init(json);
        return result;
    }
}

export interface ISubProductClassDtoPagingResult {
    items?: SubProductClassDto[] | undefined;
    totalCount?: number;
}

export class SubProductClassDtoPagingResultApiResultObject implements ISubProductClassDtoPagingResultApiResultObject {
    result?: SubProductClassDtoPagingResult;
    success?: boolean;

    constructor(data?: ISubProductClassDtoPagingResultApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? SubProductClassDtoPagingResult.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): SubProductClassDtoPagingResultApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new SubProductClassDtoPagingResultApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data;
    }

    clone(): SubProductClassDtoPagingResultApiResultObject {
        const json = this.toJSON();
        let result = new SubProductClassDtoPagingResultApiResultObject();
        result.init(json);
        return result;
    }
}

export interface ISubProductClassDtoPagingResultApiResultObject {
    result?: SubProductClassDtoPagingResult;
    success?: boolean;
}

export class SubProductClassUpsertCommand implements ISubProductClassUpsertCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: SubProductClassUpsertDto;
    readonly handleType?: string | undefined;

    constructor(data?: ISubProductClassUpsertCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? SubProductClassUpsertDto.fromJS(_data["data"]) : <any>undefined;
            (<any>this).handleType = _data["handleType"];
        }
    }

    static fromJS(data: any): SubProductClassUpsertCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SubProductClassUpsertCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["handleType"] = this.handleType;
        return data;
    }

    clone(): SubProductClassUpsertCommand {
        const json = this.toJSON();
        let result = new SubProductClassUpsertCommand();
        result.init(json);
        return result;
    }
}

export interface ISubProductClassUpsertCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: SubProductClassUpsertDto;
    handleType?: string | undefined;
}

export class SubProductClassUpsertDto implements ISubProductClassUpsertDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    isActive?: boolean;

    constructor(data?: ISubProductClassUpsertDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): SubProductClassUpsertDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubProductClassUpsertDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): SubProductClassUpsertDto {
        const json = this.toJSON();
        let result = new SubProductClassUpsertDto();
        result.init(json);
        return result;
    }
}

export interface ISubProductClassUpsertDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    isActive?: boolean;
}

export class TicketAcceptanceDto implements ITicketAcceptanceDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    acceptanceDate?: Date;
    photo1?: string | undefined;
    photo2?: string | undefined;
    photo3?: string | undefined;
    photo4?: string | undefined;
    photo5?: string | undefined;
    note?: string | undefined;
    updateUserId?: number | undefined;
    updateUserName?: string | undefined;

    constructor(data?: ITicketAcceptanceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.acceptanceDate = _data["acceptanceDate"] ? new Date(_data["acceptanceDate"].toString()) : <any>undefined;
            this.photo1 = _data["photo1"];
            this.photo2 = _data["photo2"];
            this.photo3 = _data["photo3"];
            this.photo4 = _data["photo4"];
            this.photo5 = _data["photo5"];
            this.note = _data["note"];
            this.updateUserId = _data["updateUserId"];
            this.updateUserName = _data["updateUserName"];
        }
    }

    static fromJS(data: any): TicketAcceptanceDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketAcceptanceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["acceptanceDate"] = this.acceptanceDate ? this.acceptanceDate.toISOString() : <any>undefined;
        data["photo1"] = this.photo1;
        data["photo2"] = this.photo2;
        data["photo3"] = this.photo3;
        data["photo4"] = this.photo4;
        data["photo5"] = this.photo5;
        data["note"] = this.note;
        data["updateUserId"] = this.updateUserId;
        data["updateUserName"] = this.updateUserName;
        return data;
    }

    clone(): TicketAcceptanceDto {
        const json = this.toJSON();
        let result = new TicketAcceptanceDto();
        result.init(json);
        return result;
    }
}

export interface ITicketAcceptanceDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    acceptanceDate?: Date;
    photo1?: string | undefined;
    photo2?: string | undefined;
    photo3?: string | undefined;
    photo4?: string | undefined;
    photo5?: string | undefined;
    note?: string | undefined;
    updateUserId?: number | undefined;
    updateUserName?: string | undefined;
}

export class TicketConsumerRewardDetailDto implements ITicketConsumerRewardDetailDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    ticketId?: number;
    ticketCode?: string | undefined;
    consumerName?: string | undefined;
    consumerPhone?: string | undefined;
    note?: string | undefined;

    constructor(data?: ITicketConsumerRewardDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.ticketId = _data["ticketId"];
            this.ticketCode = _data["ticketCode"];
            this.consumerName = _data["consumerName"];
            this.consumerPhone = _data["consumerPhone"];
            this.note = _data["note"];
        }
    }

    static fromJS(data: any): TicketConsumerRewardDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketConsumerRewardDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["ticketId"] = this.ticketId;
        data["ticketCode"] = this.ticketCode;
        data["consumerName"] = this.consumerName;
        data["consumerPhone"] = this.consumerPhone;
        data["note"] = this.note;
        return data;
    }

    clone(): TicketConsumerRewardDetailDto {
        const json = this.toJSON();
        let result = new TicketConsumerRewardDetailDto();
        result.init(json);
        return result;
    }
}

export interface ITicketConsumerRewardDetailDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    ticketId?: number;
    ticketCode?: string | undefined;
    consumerName?: string | undefined;
    consumerPhone?: string | undefined;
    note?: string | undefined;
}

export class TicketConsumerRewardDto implements ITicketConsumerRewardDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    photo1?: string | undefined;
    photo2?: string | undefined;
    photo3?: string | undefined;
    photo4?: string | undefined;
    photo5?: string | undefined;
    rewardItemId?: number;
    rewardItemCode?: string | undefined;
    rewardItemName?: string | undefined;
    quantity?: number;
    rewardQuantity?: number;
    details?: TicketConsumerRewardDetailDto[] | undefined;

    constructor(data?: ITicketConsumerRewardDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.photo1 = _data["photo1"];
            this.photo2 = _data["photo2"];
            this.photo3 = _data["photo3"];
            this.photo4 = _data["photo4"];
            this.photo5 = _data["photo5"];
            this.rewardItemId = _data["rewardItemId"];
            this.rewardItemCode = _data["rewardItemCode"];
            this.rewardItemName = _data["rewardItemName"];
            this.quantity = _data["quantity"];
            this.rewardQuantity = _data["rewardQuantity"];
            if (Array.isArray(_data["details"])) {
                this.details = [] as any;
                for (let item of _data["details"])
                    this.details!.push(TicketConsumerRewardDetailDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TicketConsumerRewardDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketConsumerRewardDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["photo1"] = this.photo1;
        data["photo2"] = this.photo2;
        data["photo3"] = this.photo3;
        data["photo4"] = this.photo4;
        data["photo5"] = this.photo5;
        data["rewardItemId"] = this.rewardItemId;
        data["rewardItemCode"] = this.rewardItemCode;
        data["rewardItemName"] = this.rewardItemName;
        data["quantity"] = this.quantity;
        data["rewardQuantity"] = this.rewardQuantity;
        if (Array.isArray(this.details)) {
            data["details"] = [];
            for (let item of this.details)
                data["details"].push(item.toJSON());
        }
        return data;
    }

    clone(): TicketConsumerRewardDto {
        const json = this.toJSON();
        let result = new TicketConsumerRewardDto();
        result.init(json);
        return result;
    }
}

export interface ITicketConsumerRewardDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    photo1?: string | undefined;
    photo2?: string | undefined;
    photo3?: string | undefined;
    photo4?: string | undefined;
    photo5?: string | undefined;
    rewardItemId?: number;
    rewardItemCode?: string | undefined;
    rewardItemName?: string | undefined;
    quantity?: number;
    rewardQuantity?: number;
    details?: TicketConsumerRewardDetailDto[] | undefined;
}

export class TicketConsumerRewardDtoApiResultObject implements ITicketConsumerRewardDtoApiResultObject {
    result?: TicketConsumerRewardDto;
    success?: boolean;

    constructor(data?: ITicketConsumerRewardDtoApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? TicketConsumerRewardDto.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): TicketConsumerRewardDtoApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new TicketConsumerRewardDtoApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data;
    }

    clone(): TicketConsumerRewardDtoApiResultObject {
        const json = this.toJSON();
        let result = new TicketConsumerRewardDtoApiResultObject();
        result.init(json);
        return result;
    }
}

export interface ITicketConsumerRewardDtoApiResultObject {
    result?: TicketConsumerRewardDto;
    success?: boolean;
}

export class TicketDto implements ITicketDto {
    id?: number;
    code?: string | undefined;
    consumerPhone?: string | undefined;
    consumerName?: string | undefined;
    issueDate?: Date | undefined;
    printDate?: Date | undefined;
    printCount?: number;
    lastPrintUserId?: number | undefined;
    ticketInvestmentId?: number;
    lastPrintUserName?: string | undefined;

    constructor(data?: ITicketDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.consumerPhone = _data["consumerPhone"];
            this.consumerName = _data["consumerName"];
            this.issueDate = _data["issueDate"] ? new Date(_data["issueDate"].toString()) : <any>undefined;
            this.printDate = _data["printDate"] ? new Date(_data["printDate"].toString()) : <any>undefined;
            this.printCount = _data["printCount"];
            this.lastPrintUserId = _data["lastPrintUserId"];
            this.ticketInvestmentId = _data["ticketInvestmentId"];
            this.lastPrintUserName = _data["lastPrintUserName"];
        }
    }

    static fromJS(data: any): TicketDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["consumerPhone"] = this.consumerPhone;
        data["consumerName"] = this.consumerName;
        data["issueDate"] = this.issueDate ? this.issueDate.toISOString() : <any>undefined;
        data["printDate"] = this.printDate ? this.printDate.toISOString() : <any>undefined;
        data["printCount"] = this.printCount;
        data["lastPrintUserId"] = this.lastPrintUserId;
        data["ticketInvestmentId"] = this.ticketInvestmentId;
        data["lastPrintUserName"] = this.lastPrintUserName;
        return data;
    }

    clone(): TicketDto {
        const json = this.toJSON();
        let result = new TicketDto();
        result.init(json);
        return result;
    }
}

export interface ITicketDto {
    id?: number;
    code?: string | undefined;
    consumerPhone?: string | undefined;
    consumerName?: string | undefined;
    issueDate?: Date | undefined;
    printDate?: Date | undefined;
    printCount?: number;
    lastPrintUserId?: number | undefined;
    ticketInvestmentId?: number;
    lastPrintUserName?: string | undefined;
}

export class TicketDtoApiResultObject implements ITicketDtoApiResultObject {
    result?: TicketDto;
    success?: boolean;

    constructor(data?: ITicketDtoApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? TicketDto.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): TicketDtoApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new TicketDtoApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data;
    }

    clone(): TicketDtoApiResultObject {
        const json = this.toJSON();
        let result = new TicketDtoApiResultObject();
        result.init(json);
        return result;
    }
}

export interface ITicketDtoApiResultObject {
    result?: TicketDto;
    success?: boolean;
}

export class TicketDtoPagingResult implements ITicketDtoPagingResult {
    items?: TicketDto[] | undefined;
    totalCount?: number;

    constructor(data?: ITicketDtoPagingResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TicketDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): TicketDtoPagingResult {
        data = typeof data === 'object' ? data : {};
        let result = new TicketDtoPagingResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): TicketDtoPagingResult {
        const json = this.toJSON();
        let result = new TicketDtoPagingResult();
        result.init(json);
        return result;
    }
}

export interface ITicketDtoPagingResult {
    items?: TicketDto[] | undefined;
    totalCount?: number;
}

export class TicketDtoPagingResultApiResultObject implements ITicketDtoPagingResultApiResultObject {
    result?: TicketDtoPagingResult;
    success?: boolean;

    constructor(data?: ITicketDtoPagingResultApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? TicketDtoPagingResult.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): TicketDtoPagingResultApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new TicketDtoPagingResultApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data;
    }

    clone(): TicketDtoPagingResultApiResultObject {
        const json = this.toJSON();
        let result = new TicketDtoPagingResultApiResultObject();
        result.init(json);
        return result;
    }
}

export interface ITicketDtoPagingResultApiResultObject {
    result?: TicketDtoPagingResult;
    success?: boolean;
}

export class TicketFinalSettlementDto implements ITicketFinalSettlementDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    date?: Date;
    note?: string | undefined;
    decideUserId?: number | undefined;
    decideUserName?: string | undefined;
    updateUserId?: number | undefined;
    updateUserName?: string | undefined;

    constructor(data?: ITicketFinalSettlementDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.note = _data["note"];
            this.decideUserId = _data["decideUserId"];
            this.decideUserName = _data["decideUserName"];
            this.updateUserId = _data["updateUserId"];
            this.updateUserName = _data["updateUserName"];
        }
    }

    static fromJS(data: any): TicketFinalSettlementDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketFinalSettlementDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["note"] = this.note;
        data["decideUserId"] = this.decideUserId;
        data["decideUserName"] = this.decideUserName;
        data["updateUserId"] = this.updateUserId;
        data["updateUserName"] = this.updateUserName;
        return data;
    }

    clone(): TicketFinalSettlementDto {
        const json = this.toJSON();
        let result = new TicketFinalSettlementDto();
        result.init(json);
        return result;
    }
}

export interface ITicketFinalSettlementDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    date?: Date;
    note?: string | undefined;
    decideUserId?: number | undefined;
    decideUserName?: string | undefined;
    updateUserId?: number | undefined;
    updateUserName?: string | undefined;
}

export class TicketGetByConsumerDto implements ITicketGetByConsumerDto {
    ticketCode?: string | undefined;
    operationDate?: Date | undefined;
    endDate?: Date | undefined;
    shopCode?: string | undefined;
    shopName?: string | undefined;
    shopAddress?: string | undefined;

    constructor(data?: ITicketGetByConsumerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ticketCode = _data["ticketCode"];
            this.operationDate = _data["operationDate"] ? new Date(_data["operationDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.shopCode = _data["shopCode"];
            this.shopName = _data["shopName"];
            this.shopAddress = _data["shopAddress"];
        }
    }

    static fromJS(data: any): TicketGetByConsumerDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketGetByConsumerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ticketCode"] = this.ticketCode;
        data["operationDate"] = this.operationDate ? this.operationDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["shopCode"] = this.shopCode;
        data["shopName"] = this.shopName;
        data["shopAddress"] = this.shopAddress;
        return data;
    }

    clone(): TicketGetByConsumerDto {
        const json = this.toJSON();
        let result = new TicketGetByConsumerDto();
        result.init(json);
        return result;
    }
}

export interface ITicketGetByConsumerDto {
    ticketCode?: string | undefined;
    operationDate?: Date | undefined;
    endDate?: Date | undefined;
    shopCode?: string | undefined;
    shopName?: string | undefined;
    shopAddress?: string | undefined;
}

export class TicketGetByConsumerDtoListApiResultObject implements ITicketGetByConsumerDtoListApiResultObject {
    result?: TicketGetByConsumerDto[] | undefined;
    success?: boolean;

    constructor(data?: ITicketGetByConsumerDtoListApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(TicketGetByConsumerDto.fromJS(item));
            }
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): TicketGetByConsumerDtoListApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new TicketGetByConsumerDtoListApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["success"] = this.success;
        return data;
    }

    clone(): TicketGetByConsumerDtoListApiResultObject {
        const json = this.toJSON();
        let result = new TicketGetByConsumerDtoListApiResultObject();
        result.init(json);
        return result;
    }
}

export interface ITicketGetByConsumerDtoListApiResultObject {
    result?: TicketGetByConsumerDto[] | undefined;
    success?: boolean;
}

export class TicketInvestmentCompanyRemarkCommand implements ITicketInvestmentCompanyRemarkCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: TicketInvestmentRemarkDto;
    handleType?: string | undefined;

    constructor(data?: ITicketInvestmentCompanyRemarkCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? TicketInvestmentRemarkDto.fromJS(_data["data"]) : <any>undefined;
            this.handleType = _data["handleType"];
        }
    }

    static fromJS(data: any): TicketInvestmentCompanyRemarkCommand {
        data = typeof data === 'object' ? data : {};
        let result = new TicketInvestmentCompanyRemarkCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["handleType"] = this.handleType;
        return data;
    }

    clone(): TicketInvestmentCompanyRemarkCommand {
        const json = this.toJSON();
        let result = new TicketInvestmentCompanyRemarkCommand();
        result.init(json);
        return result;
    }
}

export interface ITicketInvestmentCompanyRemarkCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: TicketInvestmentRemarkDto;
    handleType?: string | undefined;
}

export class TicketInvestmentCustomerDevelopmentRemarkCommand implements ITicketInvestmentCustomerDevelopmentRemarkCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: TicketInvestmentRemarkDto;
    handleType?: string | undefined;

    constructor(data?: ITicketInvestmentCustomerDevelopmentRemarkCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? TicketInvestmentRemarkDto.fromJS(_data["data"]) : <any>undefined;
            this.handleType = _data["handleType"];
        }
    }

    static fromJS(data: any): TicketInvestmentCustomerDevelopmentRemarkCommand {
        data = typeof data === 'object' ? data : {};
        let result = new TicketInvestmentCustomerDevelopmentRemarkCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["handleType"] = this.handleType;
        return data;
    }

    clone(): TicketInvestmentCustomerDevelopmentRemarkCommand {
        const json = this.toJSON();
        let result = new TicketInvestmentCustomerDevelopmentRemarkCommand();
        result.init(json);
        return result;
    }
}

export interface ITicketInvestmentCustomerDevelopmentRemarkCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: TicketInvestmentRemarkDto;
    handleType?: string | undefined;
}

export class TicketInvestmentDto implements ITicketInvestmentDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    customerId?: number;
    customerName?: string | undefined;
    efficient?: number | undefined;
    mobilePhone?: string | undefined;
    address?: string | undefined;
    registerStaffId?: number;
    stockQuantity?: number;
    rewardPackageId?: number;
    budgetId?: number;
    cycleId?: number;
    ticketQuantity?: number;
    pointsForTicket?: number;
    salesPlanAmount?: number;
    commitmentAmount?: number;
    rewardAmount?: number;
    materialAmount?: number;
    investmentAmount?: number;
    buyBeginDate?: Date;
    buyEndDate?: Date;
    issueTicketBeginDate?: Date;
    issueTicketEndDate?: Date;
    status?: number;
    operationDate?: Date;
    registerNote?: string | undefined;
    surveyPhoto1?: string | undefined;
    surveyPhoto2?: string | undefined;
    surveyPhoto3?: string | undefined;
    surveyPhoto4?: string | undefined;
    surveyPhoto5?: string | undefined;
    printTicketQuantity?: number;
    smsTicketQuantity?: number;
    actualSalesAmount?: number;
    materials?: TicketMaterialDto[] | undefined;
    rewardItems?: TicketRewardItemDto[] | undefined;
    salesCommitments?: TicketSalesCommitmentDto[] | undefined;
    consumerRewards?: TicketConsumerRewardDto[] | undefined;
    progresses?: TicketProgressDto[] | undefined;
    acceptance?: TicketAcceptanceDto;
    operation?: TicketOperationDto;
    finalSettlement?: TicketFinalSettlementDto;

    constructor(data?: ITicketInvestmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.customerId = _data["customerId"];
            this.customerName = _data["customerName"];
            this.efficient = _data["efficient"];
            this.mobilePhone = _data["mobilePhone"];
            this.address = _data["address"];
            this.registerStaffId = _data["registerStaffId"];
            this.stockQuantity = _data["stockQuantity"];
            this.rewardPackageId = _data["rewardPackageId"];
            this.budgetId = _data["budgetId"];
            this.cycleId = _data["cycleId"];
            this.ticketQuantity = _data["ticketQuantity"];
            this.pointsForTicket = _data["pointsForTicket"];
            this.salesPlanAmount = _data["salesPlanAmount"];
            this.commitmentAmount = _data["commitmentAmount"];
            this.rewardAmount = _data["rewardAmount"];
            this.materialAmount = _data["materialAmount"];
            this.investmentAmount = _data["investmentAmount"];
            this.buyBeginDate = _data["buyBeginDate"] ? new Date(_data["buyBeginDate"].toString()) : <any>undefined;
            this.buyEndDate = _data["buyEndDate"] ? new Date(_data["buyEndDate"].toString()) : <any>undefined;
            this.issueTicketBeginDate = _data["issueTicketBeginDate"] ? new Date(_data["issueTicketBeginDate"].toString()) : <any>undefined;
            this.issueTicketEndDate = _data["issueTicketEndDate"] ? new Date(_data["issueTicketEndDate"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.operationDate = _data["operationDate"] ? new Date(_data["operationDate"].toString()) : <any>undefined;
            this.registerNote = _data["registerNote"];
            this.surveyPhoto1 = _data["surveyPhoto1"];
            this.surveyPhoto2 = _data["surveyPhoto2"];
            this.surveyPhoto3 = _data["surveyPhoto3"];
            this.surveyPhoto4 = _data["surveyPhoto4"];
            this.surveyPhoto5 = _data["surveyPhoto5"];
            this.printTicketQuantity = _data["printTicketQuantity"];
            this.smsTicketQuantity = _data["smsTicketQuantity"];
            this.actualSalesAmount = _data["actualSalesAmount"];
            if (Array.isArray(_data["materials"])) {
                this.materials = [] as any;
                for (let item of _data["materials"])
                    this.materials!.push(TicketMaterialDto.fromJS(item));
            }
            if (Array.isArray(_data["rewardItems"])) {
                this.rewardItems = [] as any;
                for (let item of _data["rewardItems"])
                    this.rewardItems!.push(TicketRewardItemDto.fromJS(item));
            }
            if (Array.isArray(_data["salesCommitments"])) {
                this.salesCommitments = [] as any;
                for (let item of _data["salesCommitments"])
                    this.salesCommitments!.push(TicketSalesCommitmentDto.fromJS(item));
            }
            if (Array.isArray(_data["consumerRewards"])) {
                this.consumerRewards = [] as any;
                for (let item of _data["consumerRewards"])
                    this.consumerRewards!.push(TicketConsumerRewardDto.fromJS(item));
            }
            if (Array.isArray(_data["progresses"])) {
                this.progresses = [] as any;
                for (let item of _data["progresses"])
                    this.progresses!.push(TicketProgressDto.fromJS(item));
            }
            this.acceptance = _data["acceptance"] ? TicketAcceptanceDto.fromJS(_data["acceptance"]) : <any>undefined;
            this.operation = _data["operation"] ? TicketOperationDto.fromJS(_data["operation"]) : <any>undefined;
            this.finalSettlement = _data["finalSettlement"] ? TicketFinalSettlementDto.fromJS(_data["finalSettlement"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TicketInvestmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketInvestmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["customerId"] = this.customerId;
        data["customerName"] = this.customerName;
        data["efficient"] = this.efficient;
        data["mobilePhone"] = this.mobilePhone;
        data["address"] = this.address;
        data["registerStaffId"] = this.registerStaffId;
        data["stockQuantity"] = this.stockQuantity;
        data["rewardPackageId"] = this.rewardPackageId;
        data["budgetId"] = this.budgetId;
        data["cycleId"] = this.cycleId;
        data["ticketQuantity"] = this.ticketQuantity;
        data["pointsForTicket"] = this.pointsForTicket;
        data["salesPlanAmount"] = this.salesPlanAmount;
        data["commitmentAmount"] = this.commitmentAmount;
        data["rewardAmount"] = this.rewardAmount;
        data["materialAmount"] = this.materialAmount;
        data["investmentAmount"] = this.investmentAmount;
        data["buyBeginDate"] = this.buyBeginDate ? this.buyBeginDate.toISOString() : <any>undefined;
        data["buyEndDate"] = this.buyEndDate ? this.buyEndDate.toISOString() : <any>undefined;
        data["issueTicketBeginDate"] = this.issueTicketBeginDate ? this.issueTicketBeginDate.toISOString() : <any>undefined;
        data["issueTicketEndDate"] = this.issueTicketEndDate ? this.issueTicketEndDate.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["operationDate"] = this.operationDate ? this.operationDate.toISOString() : <any>undefined;
        data["registerNote"] = this.registerNote;
        data["surveyPhoto1"] = this.surveyPhoto1;
        data["surveyPhoto2"] = this.surveyPhoto2;
        data["surveyPhoto3"] = this.surveyPhoto3;
        data["surveyPhoto4"] = this.surveyPhoto4;
        data["surveyPhoto5"] = this.surveyPhoto5;
        data["printTicketQuantity"] = this.printTicketQuantity;
        data["smsTicketQuantity"] = this.smsTicketQuantity;
        data["actualSalesAmount"] = this.actualSalesAmount;
        if (Array.isArray(this.materials)) {
            data["materials"] = [];
            for (let item of this.materials)
                data["materials"].push(item.toJSON());
        }
        if (Array.isArray(this.rewardItems)) {
            data["rewardItems"] = [];
            for (let item of this.rewardItems)
                data["rewardItems"].push(item.toJSON());
        }
        if (Array.isArray(this.salesCommitments)) {
            data["salesCommitments"] = [];
            for (let item of this.salesCommitments)
                data["salesCommitments"].push(item.toJSON());
        }
        if (Array.isArray(this.consumerRewards)) {
            data["consumerRewards"] = [];
            for (let item of this.consumerRewards)
                data["consumerRewards"].push(item.toJSON());
        }
        if (Array.isArray(this.progresses)) {
            data["progresses"] = [];
            for (let item of this.progresses)
                data["progresses"].push(item.toJSON());
        }
        data["acceptance"] = this.acceptance ? this.acceptance.toJSON() : <any>undefined;
        data["operation"] = this.operation ? this.operation.toJSON() : <any>undefined;
        data["finalSettlement"] = this.finalSettlement ? this.finalSettlement.toJSON() : <any>undefined;
        return data;
    }

    clone(): TicketInvestmentDto {
        const json = this.toJSON();
        let result = new TicketInvestmentDto();
        result.init(json);
        return result;
    }
}

export interface ITicketInvestmentDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    customerId?: number;
    customerName?: string | undefined;
    efficient?: number | undefined;
    mobilePhone?: string | undefined;
    address?: string | undefined;
    registerStaffId?: number;
    stockQuantity?: number;
    rewardPackageId?: number;
    budgetId?: number;
    cycleId?: number;
    ticketQuantity?: number;
    pointsForTicket?: number;
    salesPlanAmount?: number;
    commitmentAmount?: number;
    rewardAmount?: number;
    materialAmount?: number;
    investmentAmount?: number;
    buyBeginDate?: Date;
    buyEndDate?: Date;
    issueTicketBeginDate?: Date;
    issueTicketEndDate?: Date;
    status?: number;
    operationDate?: Date;
    registerNote?: string | undefined;
    surveyPhoto1?: string | undefined;
    surveyPhoto2?: string | undefined;
    surveyPhoto3?: string | undefined;
    surveyPhoto4?: string | undefined;
    surveyPhoto5?: string | undefined;
    printTicketQuantity?: number;
    smsTicketQuantity?: number;
    actualSalesAmount?: number;
    materials?: TicketMaterialDto[] | undefined;
    rewardItems?: TicketRewardItemDto[] | undefined;
    salesCommitments?: TicketSalesCommitmentDto[] | undefined;
    consumerRewards?: TicketConsumerRewardDto[] | undefined;
    progresses?: TicketProgressDto[] | undefined;
    acceptance?: TicketAcceptanceDto;
    operation?: TicketOperationDto;
    finalSettlement?: TicketFinalSettlementDto;
}

export class TicketInvestmentDtoApiResultObject implements ITicketInvestmentDtoApiResultObject {
    result?: TicketInvestmentDto;
    success?: boolean;

    constructor(data?: ITicketInvestmentDtoApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? TicketInvestmentDto.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): TicketInvestmentDtoApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new TicketInvestmentDtoApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data;
    }

    clone(): TicketInvestmentDtoApiResultObject {
        const json = this.toJSON();
        let result = new TicketInvestmentDtoApiResultObject();
        result.init(json);
        return result;
    }
}

export interface ITicketInvestmentDtoApiResultObject {
    result?: TicketInvestmentDto;
    success?: boolean;
}

export class TicketInvestmentHistoryDto implements ITicketInvestmentHistoryDto {
    id?: number;
    userId?: number;
    userCode?: string | undefined;
    userName?: string | undefined;
    status?: number;
    data?: string | undefined;
    creationTime?: Date;

    constructor(data?: ITicketInvestmentHistoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.userCode = _data["userCode"];
            this.userName = _data["userName"];
            this.status = _data["status"];
            this.data = _data["data"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): TicketInvestmentHistoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketInvestmentHistoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["userCode"] = this.userCode;
        data["userName"] = this.userName;
        data["status"] = this.status;
        data["data"] = this.data;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data;
    }

    clone(): TicketInvestmentHistoryDto {
        const json = this.toJSON();
        let result = new TicketInvestmentHistoryDto();
        result.init(json);
        return result;
    }
}

export interface ITicketInvestmentHistoryDto {
    id?: number;
    userId?: number;
    userCode?: string | undefined;
    userName?: string | undefined;
    status?: number;
    data?: string | undefined;
    creationTime?: Date;
}

export class TicketInvestmentHistoryDtoListApiResultObject implements ITicketInvestmentHistoryDtoListApiResultObject {
    result?: TicketInvestmentHistoryDto[] | undefined;
    success?: boolean;

    constructor(data?: ITicketInvestmentHistoryDtoListApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(TicketInvestmentHistoryDto.fromJS(item));
            }
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): TicketInvestmentHistoryDtoListApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new TicketInvestmentHistoryDtoListApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["success"] = this.success;
        return data;
    }

    clone(): TicketInvestmentHistoryDtoListApiResultObject {
        const json = this.toJSON();
        let result = new TicketInvestmentHistoryDtoListApiResultObject();
        result.init(json);
        return result;
    }
}

export interface ITicketInvestmentHistoryDtoListApiResultObject {
    result?: TicketInvestmentHistoryDto[] | undefined;
    success?: boolean;
}

export class TicketInvestmentListItemDto implements ITicketInvestmentListItemDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    cycleId?: number;
    customerId?: number;
    customerCode?: string | undefined;
    customerName?: string | undefined;
    email?: string | undefined;
    mobilePhone?: string | undefined;
    address?: string | undefined;
    registerStaffId?: number;
    registerStaffName?: string | undefined;
    stockQuantity?: number;
    rewardPackageId?: number;
    rewardPackageName?: string | undefined;
    ticketQuantity?: number;
    pointsForTicket?: number;
    salesPlanAmount?: number;
    commitmentAmount?: number;
    rewardAmount?: number;
    materialAmount?: number;
    investmentAmount?: number;
    buyBeginDate?: Date;
    buyEndDate?: Date;
    issueTicketBeginDate?: Date;
    issueTicketEndDate?: Date;
    status?: number;
    operationDate?: Date;
    remarkOfCompany?: number | undefined;
    zoneName?: string | undefined;
    areaName?: string | undefined;

    constructor(data?: ITicketInvestmentListItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.cycleId = _data["cycleId"];
            this.customerId = _data["customerId"];
            this.customerCode = _data["customerCode"];
            this.customerName = _data["customerName"];
            this.email = _data["email"];
            this.mobilePhone = _data["mobilePhone"];
            this.address = _data["address"];
            this.registerStaffId = _data["registerStaffId"];
            this.registerStaffName = _data["registerStaffName"];
            this.stockQuantity = _data["stockQuantity"];
            this.rewardPackageId = _data["rewardPackageId"];
            this.rewardPackageName = _data["rewardPackageName"];
            this.ticketQuantity = _data["ticketQuantity"];
            this.pointsForTicket = _data["pointsForTicket"];
            this.salesPlanAmount = _data["salesPlanAmount"];
            this.commitmentAmount = _data["commitmentAmount"];
            this.rewardAmount = _data["rewardAmount"];
            this.materialAmount = _data["materialAmount"];
            this.investmentAmount = _data["investmentAmount"];
            this.buyBeginDate = _data["buyBeginDate"] ? new Date(_data["buyBeginDate"].toString()) : <any>undefined;
            this.buyEndDate = _data["buyEndDate"] ? new Date(_data["buyEndDate"].toString()) : <any>undefined;
            this.issueTicketBeginDate = _data["issueTicketBeginDate"] ? new Date(_data["issueTicketBeginDate"].toString()) : <any>undefined;
            this.issueTicketEndDate = _data["issueTicketEndDate"] ? new Date(_data["issueTicketEndDate"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.operationDate = _data["operationDate"] ? new Date(_data["operationDate"].toString()) : <any>undefined;
            this.remarkOfCompany = _data["remarkOfCompany"];
            this.zoneName = _data["zoneName"];
            this.areaName = _data["areaName"];
        }
    }

    static fromJS(data: any): TicketInvestmentListItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketInvestmentListItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["cycleId"] = this.cycleId;
        data["customerId"] = this.customerId;
        data["customerCode"] = this.customerCode;
        data["customerName"] = this.customerName;
        data["email"] = this.email;
        data["mobilePhone"] = this.mobilePhone;
        data["address"] = this.address;
        data["registerStaffId"] = this.registerStaffId;
        data["registerStaffName"] = this.registerStaffName;
        data["stockQuantity"] = this.stockQuantity;
        data["rewardPackageId"] = this.rewardPackageId;
        data["rewardPackageName"] = this.rewardPackageName;
        data["ticketQuantity"] = this.ticketQuantity;
        data["pointsForTicket"] = this.pointsForTicket;
        data["salesPlanAmount"] = this.salesPlanAmount;
        data["commitmentAmount"] = this.commitmentAmount;
        data["rewardAmount"] = this.rewardAmount;
        data["materialAmount"] = this.materialAmount;
        data["investmentAmount"] = this.investmentAmount;
        data["buyBeginDate"] = this.buyBeginDate ? this.buyBeginDate.toISOString() : <any>undefined;
        data["buyEndDate"] = this.buyEndDate ? this.buyEndDate.toISOString() : <any>undefined;
        data["issueTicketBeginDate"] = this.issueTicketBeginDate ? this.issueTicketBeginDate.toISOString() : <any>undefined;
        data["issueTicketEndDate"] = this.issueTicketEndDate ? this.issueTicketEndDate.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["operationDate"] = this.operationDate ? this.operationDate.toISOString() : <any>undefined;
        data["remarkOfCompany"] = this.remarkOfCompany;
        data["zoneName"] = this.zoneName;
        data["areaName"] = this.areaName;
        return data;
    }

    clone(): TicketInvestmentListItemDto {
        const json = this.toJSON();
        let result = new TicketInvestmentListItemDto();
        result.init(json);
        return result;
    }
}

export interface ITicketInvestmentListItemDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    cycleId?: number;
    customerId?: number;
    customerCode?: string | undefined;
    customerName?: string | undefined;
    email?: string | undefined;
    mobilePhone?: string | undefined;
    address?: string | undefined;
    registerStaffId?: number;
    registerStaffName?: string | undefined;
    stockQuantity?: number;
    rewardPackageId?: number;
    rewardPackageName?: string | undefined;
    ticketQuantity?: number;
    pointsForTicket?: number;
    salesPlanAmount?: number;
    commitmentAmount?: number;
    rewardAmount?: number;
    materialAmount?: number;
    investmentAmount?: number;
    buyBeginDate?: Date;
    buyEndDate?: Date;
    issueTicketBeginDate?: Date;
    issueTicketEndDate?: Date;
    status?: number;
    operationDate?: Date;
    remarkOfCompany?: number | undefined;
    zoneName?: string | undefined;
    areaName?: string | undefined;
}

export class TicketInvestmentListItemDtoPagingResult implements ITicketInvestmentListItemDtoPagingResult {
    items?: TicketInvestmentListItemDto[] | undefined;
    totalCount?: number;

    constructor(data?: ITicketInvestmentListItemDtoPagingResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TicketInvestmentListItemDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): TicketInvestmentListItemDtoPagingResult {
        data = typeof data === 'object' ? data : {};
        let result = new TicketInvestmentListItemDtoPagingResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): TicketInvestmentListItemDtoPagingResult {
        const json = this.toJSON();
        let result = new TicketInvestmentListItemDtoPagingResult();
        result.init(json);
        return result;
    }
}

export interface ITicketInvestmentListItemDtoPagingResult {
    items?: TicketInvestmentListItemDto[] | undefined;
    totalCount?: number;
}

export class TicketInvestmentListItemDtoPagingResultApiResultObject implements ITicketInvestmentListItemDtoPagingResultApiResultObject {
    result?: TicketInvestmentListItemDtoPagingResult;
    success?: boolean;

    constructor(data?: ITicketInvestmentListItemDtoPagingResultApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? TicketInvestmentListItemDtoPagingResult.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): TicketInvestmentListItemDtoPagingResultApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new TicketInvestmentListItemDtoPagingResultApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data;
    }

    clone(): TicketInvestmentListItemDtoPagingResultApiResultObject {
        const json = this.toJSON();
        let result = new TicketInvestmentListItemDtoPagingResultApiResultObject();
        result.init(json);
        return result;
    }
}

export interface ITicketInvestmentListItemDtoPagingResultApiResultObject {
    result?: TicketInvestmentListItemDtoPagingResult;
    success?: boolean;
}

export class TicketInvestmentOperateCommand implements ITicketInvestmentOperateCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: TicketInvestmentOperateDto;
    handleType?: string | undefined;

    constructor(data?: ITicketInvestmentOperateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? TicketInvestmentOperateDto.fromJS(_data["data"]) : <any>undefined;
            this.handleType = _data["handleType"];
        }
    }

    static fromJS(data: any): TicketInvestmentOperateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new TicketInvestmentOperateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["handleType"] = this.handleType;
        return data;
    }

    clone(): TicketInvestmentOperateCommand {
        const json = this.toJSON();
        let result = new TicketInvestmentOperateCommand();
        result.init(json);
        return result;
    }
}

export interface ITicketInvestmentOperateCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: TicketInvestmentOperateDto;
    handleType?: string | undefined;
}

export class TicketInvestmentOperateDto implements ITicketInvestmentOperateDto {
    id?: number;
    operationDate?: Date;
    note?: string | undefined;
    stockQuantity?: number;
    photo1?: string | undefined;
    photo2?: string | undefined;
    photo3?: string | undefined;
    photo4?: string | undefined;
    photo5?: string | undefined;

    constructor(data?: ITicketInvestmentOperateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.operationDate = _data["operationDate"] ? new Date(_data["operationDate"].toString()) : <any>undefined;
            this.note = _data["note"];
            this.stockQuantity = _data["stockQuantity"];
            this.photo1 = _data["photo1"];
            this.photo2 = _data["photo2"];
            this.photo3 = _data["photo3"];
            this.photo4 = _data["photo4"];
            this.photo5 = _data["photo5"];
        }
    }

    static fromJS(data: any): TicketInvestmentOperateDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketInvestmentOperateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["operationDate"] = this.operationDate ? this.operationDate.toISOString() : <any>undefined;
        data["note"] = this.note;
        data["stockQuantity"] = this.stockQuantity;
        data["photo1"] = this.photo1;
        data["photo2"] = this.photo2;
        data["photo3"] = this.photo3;
        data["photo4"] = this.photo4;
        data["photo5"] = this.photo5;
        return data;
    }

    clone(): TicketInvestmentOperateDto {
        const json = this.toJSON();
        let result = new TicketInvestmentOperateDto();
        result.init(json);
        return result;
    }
}

export interface ITicketInvestmentOperateDto {
    id?: number;
    operationDate?: Date;
    note?: string | undefined;
    stockQuantity?: number;
    photo1?: string | undefined;
    photo2?: string | undefined;
    photo3?: string | undefined;
    photo4?: string | undefined;
    photo5?: string | undefined;
}

export class TicketInvestmentRegisterCommand implements ITicketInvestmentRegisterCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: TicketInvestmentRegisterDto;

    constructor(data?: ITicketInvestmentRegisterCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? TicketInvestmentRegisterDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TicketInvestmentRegisterCommand {
        data = typeof data === 'object' ? data : {};
        let result = new TicketInvestmentRegisterCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }

    clone(): TicketInvestmentRegisterCommand {
        const json = this.toJSON();
        let result = new TicketInvestmentRegisterCommand();
        result.init(json);
        return result;
    }
}

export interface ITicketInvestmentRegisterCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: TicketInvestmentRegisterDto;
}

export class TicketInvestmentRegisterDto implements ITicketInvestmentRegisterDto {
    customerId?: number;
    stockQuantity?: number;
    rewardPackageId?: number;
    pointsForTicket?: number;
    buyBeginDate?: Date;
    buyEndDate?: Date;
    issueTicketBeginDate?: Date;
    operationDate?: Date;
    registerNote?: string | undefined;
    surveyPhoto1?: string | undefined;
    surveyPhoto2?: string | undefined;
    surveyPhoto3?: string | undefined;
    surveyPhoto4?: string | undefined;
    surveyPhoto5?: string | undefined;
    salesCommitments?: TicketInvestmentRegisterSalesCommitmentDto[] | undefined;
    materials?: TicketInvestmentRegisterMaterialDto[] | undefined;

    constructor(data?: ITicketInvestmentRegisterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.customerId = _data["customerId"];
            this.stockQuantity = _data["stockQuantity"];
            this.rewardPackageId = _data["rewardPackageId"];
            this.pointsForTicket = _data["pointsForTicket"];
            this.buyBeginDate = _data["buyBeginDate"] ? new Date(_data["buyBeginDate"].toString()) : <any>undefined;
            this.buyEndDate = _data["buyEndDate"] ? new Date(_data["buyEndDate"].toString()) : <any>undefined;
            this.issueTicketBeginDate = _data["issueTicketBeginDate"] ? new Date(_data["issueTicketBeginDate"].toString()) : <any>undefined;
            this.operationDate = _data["operationDate"] ? new Date(_data["operationDate"].toString()) : <any>undefined;
            this.registerNote = _data["registerNote"];
            this.surveyPhoto1 = _data["surveyPhoto1"];
            this.surveyPhoto2 = _data["surveyPhoto2"];
            this.surveyPhoto3 = _data["surveyPhoto3"];
            this.surveyPhoto4 = _data["surveyPhoto4"];
            this.surveyPhoto5 = _data["surveyPhoto5"];
            if (Array.isArray(_data["salesCommitments"])) {
                this.salesCommitments = [] as any;
                for (let item of _data["salesCommitments"])
                    this.salesCommitments!.push(TicketInvestmentRegisterSalesCommitmentDto.fromJS(item));
            }
            if (Array.isArray(_data["materials"])) {
                this.materials = [] as any;
                for (let item of _data["materials"])
                    this.materials!.push(TicketInvestmentRegisterMaterialDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TicketInvestmentRegisterDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketInvestmentRegisterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerId"] = this.customerId;
        data["stockQuantity"] = this.stockQuantity;
        data["rewardPackageId"] = this.rewardPackageId;
        data["pointsForTicket"] = this.pointsForTicket;
        data["buyBeginDate"] = this.buyBeginDate ? this.buyBeginDate.toISOString() : <any>undefined;
        data["buyEndDate"] = this.buyEndDate ? this.buyEndDate.toISOString() : <any>undefined;
        data["issueTicketBeginDate"] = this.issueTicketBeginDate ? this.issueTicketBeginDate.toISOString() : <any>undefined;
        data["operationDate"] = this.operationDate ? this.operationDate.toISOString() : <any>undefined;
        data["registerNote"] = this.registerNote;
        data["surveyPhoto1"] = this.surveyPhoto1;
        data["surveyPhoto2"] = this.surveyPhoto2;
        data["surveyPhoto3"] = this.surveyPhoto3;
        data["surveyPhoto4"] = this.surveyPhoto4;
        data["surveyPhoto5"] = this.surveyPhoto5;
        if (Array.isArray(this.salesCommitments)) {
            data["salesCommitments"] = [];
            for (let item of this.salesCommitments)
                data["salesCommitments"].push(item.toJSON());
        }
        if (Array.isArray(this.materials)) {
            data["materials"] = [];
            for (let item of this.materials)
                data["materials"].push(item.toJSON());
        }
        return data;
    }

    clone(): TicketInvestmentRegisterDto {
        const json = this.toJSON();
        let result = new TicketInvestmentRegisterDto();
        result.init(json);
        return result;
    }
}

export interface ITicketInvestmentRegisterDto {
    customerId?: number;
    stockQuantity?: number;
    rewardPackageId?: number;
    pointsForTicket?: number;
    buyBeginDate?: Date;
    buyEndDate?: Date;
    issueTicketBeginDate?: Date;
    operationDate?: Date;
    registerNote?: string | undefined;
    surveyPhoto1?: string | undefined;
    surveyPhoto2?: string | undefined;
    surveyPhoto3?: string | undefined;
    surveyPhoto4?: string | undefined;
    surveyPhoto5?: string | undefined;
    salesCommitments?: TicketInvestmentRegisterSalesCommitmentDto[] | undefined;
    materials?: TicketInvestmentRegisterMaterialDto[] | undefined;
}

export class TicketInvestmentRegisterMaterialDto implements ITicketInvestmentRegisterMaterialDto {
    materialId?: number;
    registerQuantity?: number;
    note?: string | undefined;

    constructor(data?: ITicketInvestmentRegisterMaterialDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.materialId = _data["materialId"];
            this.registerQuantity = _data["registerQuantity"];
            this.note = _data["note"];
        }
    }

    static fromJS(data: any): TicketInvestmentRegisterMaterialDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketInvestmentRegisterMaterialDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["materialId"] = this.materialId;
        data["registerQuantity"] = this.registerQuantity;
        data["note"] = this.note;
        return data;
    }

    clone(): TicketInvestmentRegisterMaterialDto {
        const json = this.toJSON();
        let result = new TicketInvestmentRegisterMaterialDto();
        result.init(json);
        return result;
    }
}

export interface ITicketInvestmentRegisterMaterialDto {
    materialId?: number;
    registerQuantity?: number;
    note?: string | undefined;
}

export class TicketInvestmentRegisterSalesCommitmentDto implements ITicketInvestmentRegisterSalesCommitmentDto {
    year?: number;
    month?: number;
    amount?: number;

    constructor(data?: ITicketInvestmentRegisterSalesCommitmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.year = _data["year"];
            this.month = _data["month"];
            this.amount = _data["amount"];
        }
    }

    static fromJS(data: any): TicketInvestmentRegisterSalesCommitmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketInvestmentRegisterSalesCommitmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["year"] = this.year;
        data["month"] = this.month;
        data["amount"] = this.amount;
        return data;
    }

    clone(): TicketInvestmentRegisterSalesCommitmentDto {
        const json = this.toJSON();
        let result = new TicketInvestmentRegisterSalesCommitmentDto();
        result.init(json);
        return result;
    }
}

export interface ITicketInvestmentRegisterSalesCommitmentDto {
    year?: number;
    month?: number;
    amount?: number;
}

export class TicketInvestmentRemarkDto implements ITicketInvestmentRemarkDto {
    id?: number;
    remark?: number;

    constructor(data?: ITicketInvestmentRemarkDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.remark = _data["remark"];
        }
    }

    static fromJS(data: any): TicketInvestmentRemarkDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketInvestmentRemarkDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["remark"] = this.remark;
        return data;
    }

    clone(): TicketInvestmentRemarkDto {
        const json = this.toJSON();
        let result = new TicketInvestmentRemarkDto();
        result.init(json);
        return result;
    }
}

export interface ITicketInvestmentRemarkDto {
    id?: number;
    remark?: number;
}

export class TicketInvestmentSalesRemarkCommand implements ITicketInvestmentSalesRemarkCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: TicketInvestmentRemarkDto;

    constructor(data?: ITicketInvestmentSalesRemarkCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? TicketInvestmentRemarkDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TicketInvestmentSalesRemarkCommand {
        data = typeof data === 'object' ? data : {};
        let result = new TicketInvestmentSalesRemarkCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }

    clone(): TicketInvestmentSalesRemarkCommand {
        const json = this.toJSON();
        let result = new TicketInvestmentSalesRemarkCommand();
        result.init(json);
        return result;
    }
}

export interface ITicketInvestmentSalesRemarkCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: TicketInvestmentRemarkDto;
}

export class TicketInvestmentSummaryDto implements ITicketInvestmentSummaryDto {
    id?: number;
    ticketQuantity?: number;
    printTicketQuantity?: number;
    smsTicketQuantity?: number;
    actualSalesAmount?: number;
    commitmentSalesAmount?: number;
    remarkOfSales?: number | undefined;
    remarkOfCompany?: number | undefined;
    remarkOfCustomerDevelopement?: number | undefined;

    constructor(data?: ITicketInvestmentSummaryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.ticketQuantity = _data["ticketQuantity"];
            this.printTicketQuantity = _data["printTicketQuantity"];
            this.smsTicketQuantity = _data["smsTicketQuantity"];
            this.actualSalesAmount = _data["actualSalesAmount"];
            this.commitmentSalesAmount = _data["commitmentSalesAmount"];
            this.remarkOfSales = _data["remarkOfSales"];
            this.remarkOfCompany = _data["remarkOfCompany"];
            this.remarkOfCustomerDevelopement = _data["remarkOfCustomerDevelopement"];
        }
    }

    static fromJS(data: any): TicketInvestmentSummaryDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketInvestmentSummaryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["ticketQuantity"] = this.ticketQuantity;
        data["printTicketQuantity"] = this.printTicketQuantity;
        data["smsTicketQuantity"] = this.smsTicketQuantity;
        data["actualSalesAmount"] = this.actualSalesAmount;
        data["commitmentSalesAmount"] = this.commitmentSalesAmount;
        data["remarkOfSales"] = this.remarkOfSales;
        data["remarkOfCompany"] = this.remarkOfCompany;
        data["remarkOfCustomerDevelopement"] = this.remarkOfCustomerDevelopement;
        return data;
    }

    clone(): TicketInvestmentSummaryDto {
        const json = this.toJSON();
        let result = new TicketInvestmentSummaryDto();
        result.init(json);
        return result;
    }
}

export interface ITicketInvestmentSummaryDto {
    id?: number;
    ticketQuantity?: number;
    printTicketQuantity?: number;
    smsTicketQuantity?: number;
    actualSalesAmount?: number;
    commitmentSalesAmount?: number;
    remarkOfSales?: number | undefined;
    remarkOfCompany?: number | undefined;
    remarkOfCustomerDevelopement?: number | undefined;
}

export class TicketInvestmentSummaryDtoApiResultObject implements ITicketInvestmentSummaryDtoApiResultObject {
    result?: TicketInvestmentSummaryDto;
    success?: boolean;

    constructor(data?: ITicketInvestmentSummaryDtoApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? TicketInvestmentSummaryDto.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): TicketInvestmentSummaryDtoApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new TicketInvestmentSummaryDtoApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data;
    }

    clone(): TicketInvestmentSummaryDtoApiResultObject {
        const json = this.toJSON();
        let result = new TicketInvestmentSummaryDtoApiResultObject();
        result.init(json);
        return result;
    }
}

export interface ITicketInvestmentSummaryDtoApiResultObject {
    result?: TicketInvestmentSummaryDto;
    success?: boolean;
}

export class TicketInvestmentTrackingDto implements ITicketInvestmentTrackingDto {
    id?: number;
    code?: string | undefined;
    buyBeginDate?: Date;
    buyEndDate?: Date;
    issueTicketBeginDate?: Date;
    issueTicketEndDate?: Date;
    operationDate?: Date;
    sentTicketQuantity?: number;
    qrCodeQuantity?: number;
    consumerQuantity?: number;
    tickets?: TicketDto[] | undefined;

    constructor(data?: ITicketInvestmentTrackingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.buyBeginDate = _data["buyBeginDate"] ? new Date(_data["buyBeginDate"].toString()) : <any>undefined;
            this.buyEndDate = _data["buyEndDate"] ? new Date(_data["buyEndDate"].toString()) : <any>undefined;
            this.issueTicketBeginDate = _data["issueTicketBeginDate"] ? new Date(_data["issueTicketBeginDate"].toString()) : <any>undefined;
            this.issueTicketEndDate = _data["issueTicketEndDate"] ? new Date(_data["issueTicketEndDate"].toString()) : <any>undefined;
            this.operationDate = _data["operationDate"] ? new Date(_data["operationDate"].toString()) : <any>undefined;
            this.sentTicketQuantity = _data["sentTicketQuantity"];
            this.qrCodeQuantity = _data["qrCodeQuantity"];
            this.consumerQuantity = _data["consumerQuantity"];
            if (Array.isArray(_data["tickets"])) {
                this.tickets = [] as any;
                for (let item of _data["tickets"])
                    this.tickets!.push(TicketDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TicketInvestmentTrackingDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketInvestmentTrackingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["buyBeginDate"] = this.buyBeginDate ? this.buyBeginDate.toISOString() : <any>undefined;
        data["buyEndDate"] = this.buyEndDate ? this.buyEndDate.toISOString() : <any>undefined;
        data["issueTicketBeginDate"] = this.issueTicketBeginDate ? this.issueTicketBeginDate.toISOString() : <any>undefined;
        data["issueTicketEndDate"] = this.issueTicketEndDate ? this.issueTicketEndDate.toISOString() : <any>undefined;
        data["operationDate"] = this.operationDate ? this.operationDate.toISOString() : <any>undefined;
        data["sentTicketQuantity"] = this.sentTicketQuantity;
        data["qrCodeQuantity"] = this.qrCodeQuantity;
        data["consumerQuantity"] = this.consumerQuantity;
        if (Array.isArray(this.tickets)) {
            data["tickets"] = [];
            for (let item of this.tickets)
                data["tickets"].push(item.toJSON());
        }
        return data;
    }

    clone(): TicketInvestmentTrackingDto {
        const json = this.toJSON();
        let result = new TicketInvestmentTrackingDto();
        result.init(json);
        return result;
    }
}

export interface ITicketInvestmentTrackingDto {
    id?: number;
    code?: string | undefined;
    buyBeginDate?: Date;
    buyEndDate?: Date;
    issueTicketBeginDate?: Date;
    issueTicketEndDate?: Date;
    operationDate?: Date;
    sentTicketQuantity?: number;
    qrCodeQuantity?: number;
    consumerQuantity?: number;
    tickets?: TicketDto[] | undefined;
}

export class TicketInvestmentTrackingDtoApiResultObject implements ITicketInvestmentTrackingDtoApiResultObject {
    result?: TicketInvestmentTrackingDto;
    success?: boolean;

    constructor(data?: ITicketInvestmentTrackingDtoApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? TicketInvestmentTrackingDto.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): TicketInvestmentTrackingDtoApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new TicketInvestmentTrackingDtoApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data;
    }

    clone(): TicketInvestmentTrackingDtoApiResultObject {
        const json = this.toJSON();
        let result = new TicketInvestmentTrackingDtoApiResultObject();
        result.init(json);
        return result;
    }
}

export interface ITicketInvestmentTrackingDtoApiResultObject {
    result?: TicketInvestmentTrackingDto;
    success?: boolean;
}

export class TicketInvestmentUpdateCommand implements ITicketInvestmentUpdateCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: TicketInvestmentUpdateDto;

    constructor(data?: ITicketInvestmentUpdateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? TicketInvestmentUpdateDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TicketInvestmentUpdateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new TicketInvestmentUpdateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }

    clone(): TicketInvestmentUpdateCommand {
        const json = this.toJSON();
        let result = new TicketInvestmentUpdateCommand();
        result.init(json);
        return result;
    }
}

export interface ITicketInvestmentUpdateCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: TicketInvestmentUpdateDto;
}

export class TicketInvestmentUpdateDto implements ITicketInvestmentUpdateDto {
    id?: number;
    operationDate?: Date;

    constructor(data?: ITicketInvestmentUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.operationDate = _data["operationDate"] ? new Date(_data["operationDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): TicketInvestmentUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketInvestmentUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["operationDate"] = this.operationDate ? this.operationDate.toISOString() : <any>undefined;
        return data;
    }

    clone(): TicketInvestmentUpdateDto {
        const json = this.toJSON();
        let result = new TicketInvestmentUpdateDto();
        result.init(json);
        return result;
    }
}

export interface ITicketInvestmentUpdateDto {
    id?: number;
    operationDate?: Date;
}

export class TicketInvestmentUpdatePrintTicketQuantityCommand implements ITicketInvestmentUpdatePrintTicketQuantityCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    id?: number;
    data?: number[] | undefined;

    constructor(data?: ITicketInvestmentUpdatePrintTicketQuantityCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.id = _data["id"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(item);
            }
        }
    }

    static fromJS(data: any): TicketInvestmentUpdatePrintTicketQuantityCommand {
        data = typeof data === 'object' ? data : {};
        let result = new TicketInvestmentUpdatePrintTicketQuantityCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["id"] = this.id;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item);
        }
        return data;
    }

    clone(): TicketInvestmentUpdatePrintTicketQuantityCommand {
        const json = this.toJSON();
        let result = new TicketInvestmentUpdatePrintTicketQuantityCommand();
        result.init(json);
        return result;
    }
}

export interface ITicketInvestmentUpdatePrintTicketQuantityCommand {
    commandId?: string;
    occuredDate?: Date;
    id?: number;
    data?: number[] | undefined;
}

export class TicketInvestmentUpsertAcceptanceCommand implements ITicketInvestmentUpsertAcceptanceCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: TicketInvestmentUpsertAcceptanceDto;
    handleType?: string | undefined;

    constructor(data?: ITicketInvestmentUpsertAcceptanceCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? TicketInvestmentUpsertAcceptanceDto.fromJS(_data["data"]) : <any>undefined;
            this.handleType = _data["handleType"];
        }
    }

    static fromJS(data: any): TicketInvestmentUpsertAcceptanceCommand {
        data = typeof data === 'object' ? data : {};
        let result = new TicketInvestmentUpsertAcceptanceCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["handleType"] = this.handleType;
        return data;
    }

    clone(): TicketInvestmentUpsertAcceptanceCommand {
        const json = this.toJSON();
        let result = new TicketInvestmentUpsertAcceptanceCommand();
        result.init(json);
        return result;
    }
}

export interface ITicketInvestmentUpsertAcceptanceCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: TicketInvestmentUpsertAcceptanceDto;
    handleType?: string | undefined;
}

export class TicketInvestmentUpsertAcceptanceDto implements ITicketInvestmentUpsertAcceptanceDto {
    id?: number;
    acceptanceDate?: Date;
    note?: string | undefined;
    actualSalesAmount?: number;
    photo1?: string | undefined;
    photo2?: string | undefined;
    photo3?: string | undefined;
    photo4?: string | undefined;
    photo5?: string | undefined;

    constructor(data?: ITicketInvestmentUpsertAcceptanceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.acceptanceDate = _data["acceptanceDate"] ? new Date(_data["acceptanceDate"].toString()) : <any>undefined;
            this.note = _data["note"];
            this.actualSalesAmount = _data["actualSalesAmount"];
            this.photo1 = _data["photo1"];
            this.photo2 = _data["photo2"];
            this.photo3 = _data["photo3"];
            this.photo4 = _data["photo4"];
            this.photo5 = _data["photo5"];
        }
    }

    static fromJS(data: any): TicketInvestmentUpsertAcceptanceDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketInvestmentUpsertAcceptanceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["acceptanceDate"] = this.acceptanceDate ? this.acceptanceDate.toISOString() : <any>undefined;
        data["note"] = this.note;
        data["actualSalesAmount"] = this.actualSalesAmount;
        data["photo1"] = this.photo1;
        data["photo2"] = this.photo2;
        data["photo3"] = this.photo3;
        data["photo4"] = this.photo4;
        data["photo5"] = this.photo5;
        return data;
    }

    clone(): TicketInvestmentUpsertAcceptanceDto {
        const json = this.toJSON();
        let result = new TicketInvestmentUpsertAcceptanceDto();
        result.init(json);
        return result;
    }
}

export interface ITicketInvestmentUpsertAcceptanceDto {
    id?: number;
    acceptanceDate?: Date;
    note?: string | undefined;
    actualSalesAmount?: number;
    photo1?: string | undefined;
    photo2?: string | undefined;
    photo3?: string | undefined;
    photo4?: string | undefined;
    photo5?: string | undefined;
}

export class TicketInvestmentUpsertConsumerRewardCommand implements ITicketInvestmentUpsertConsumerRewardCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: TicketInvestmentUpsertConsumerRewardDto;
    readonly handleType?: string | undefined;

    constructor(data?: ITicketInvestmentUpsertConsumerRewardCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? TicketInvestmentUpsertConsumerRewardDto.fromJS(_data["data"]) : <any>undefined;
            (<any>this).handleType = _data["handleType"];
        }
    }

    static fromJS(data: any): TicketInvestmentUpsertConsumerRewardCommand {
        data = typeof data === 'object' ? data : {};
        let result = new TicketInvestmentUpsertConsumerRewardCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["handleType"] = this.handleType;
        return data;
    }

    clone(): TicketInvestmentUpsertConsumerRewardCommand {
        const json = this.toJSON();
        let result = new TicketInvestmentUpsertConsumerRewardCommand();
        result.init(json);
        return result;
    }
}

export interface ITicketInvestmentUpsertConsumerRewardCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: TicketInvestmentUpsertConsumerRewardDto;
    handleType?: string | undefined;
}

export class TicketInvestmentUpsertConsumerRewardDto implements ITicketInvestmentUpsertConsumerRewardDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    rewardItemId?: number;
    quantity?: number;
    photo1?: string | undefined;
    photo2?: string | undefined;
    photo3?: string | undefined;
    photo4?: string | undefined;
    photo5?: string | undefined;
    detailChanges?: ConsumerRewardDetailCrudListDto;

    constructor(data?: ITicketInvestmentUpsertConsumerRewardDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.rewardItemId = _data["rewardItemId"];
            this.quantity = _data["quantity"];
            this.photo1 = _data["photo1"];
            this.photo2 = _data["photo2"];
            this.photo3 = _data["photo3"];
            this.photo4 = _data["photo4"];
            this.photo5 = _data["photo5"];
            this.detailChanges = _data["detailChanges"] ? ConsumerRewardDetailCrudListDto.fromJS(_data["detailChanges"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TicketInvestmentUpsertConsumerRewardDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketInvestmentUpsertConsumerRewardDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["rewardItemId"] = this.rewardItemId;
        data["quantity"] = this.quantity;
        data["photo1"] = this.photo1;
        data["photo2"] = this.photo2;
        data["photo3"] = this.photo3;
        data["photo4"] = this.photo4;
        data["photo5"] = this.photo5;
        data["detailChanges"] = this.detailChanges ? this.detailChanges.toJSON() : <any>undefined;
        return data;
    }

    clone(): TicketInvestmentUpsertConsumerRewardDto {
        const json = this.toJSON();
        let result = new TicketInvestmentUpsertConsumerRewardDto();
        result.init(json);
        return result;
    }
}

export interface ITicketInvestmentUpsertConsumerRewardDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    rewardItemId?: number;
    quantity?: number;
    photo1?: string | undefined;
    photo2?: string | undefined;
    photo3?: string | undefined;
    photo4?: string | undefined;
    photo5?: string | undefined;
    detailChanges?: ConsumerRewardDetailCrudListDto;
}

export class TicketInvestmentUpsertFinalSettlementCommand implements ITicketInvestmentUpsertFinalSettlementCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: TicketInvestmentUpsertFinalSettlementDto;
    handleType?: string | undefined;

    constructor(data?: ITicketInvestmentUpsertFinalSettlementCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? TicketInvestmentUpsertFinalSettlementDto.fromJS(_data["data"]) : <any>undefined;
            this.handleType = _data["handleType"];
        }
    }

    static fromJS(data: any): TicketInvestmentUpsertFinalSettlementCommand {
        data = typeof data === 'object' ? data : {};
        let result = new TicketInvestmentUpsertFinalSettlementCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["handleType"] = this.handleType;
        return data;
    }

    clone(): TicketInvestmentUpsertFinalSettlementCommand {
        const json = this.toJSON();
        let result = new TicketInvestmentUpsertFinalSettlementCommand();
        result.init(json);
        return result;
    }
}

export interface ITicketInvestmentUpsertFinalSettlementCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: TicketInvestmentUpsertFinalSettlementDto;
    handleType?: string | undefined;
}

export class TicketInvestmentUpsertFinalSettlementDto implements ITicketInvestmentUpsertFinalSettlementDto {
    id?: number;
    date?: Date;
    note?: string | undefined;
    decideUserId?: number;

    constructor(data?: ITicketInvestmentUpsertFinalSettlementDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.note = _data["note"];
            this.decideUserId = _data["decideUserId"];
        }
    }

    static fromJS(data: any): TicketInvestmentUpsertFinalSettlementDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketInvestmentUpsertFinalSettlementDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["note"] = this.note;
        data["decideUserId"] = this.decideUserId;
        return data;
    }

    clone(): TicketInvestmentUpsertFinalSettlementDto {
        const json = this.toJSON();
        let result = new TicketInvestmentUpsertFinalSettlementDto();
        result.init(json);
        return result;
    }
}

export interface ITicketInvestmentUpsertFinalSettlementDto {
    id?: number;
    date?: Date;
    note?: string | undefined;
    decideUserId?: number;
}

export class TicketInvestmentUpsertProgressCommand implements ITicketInvestmentUpsertProgressCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: TicketInvestmentUpsertProgressDto;
    readonly handleType?: string | undefined;

    constructor(data?: ITicketInvestmentUpsertProgressCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? TicketInvestmentUpsertProgressDto.fromJS(_data["data"]) : <any>undefined;
            (<any>this).handleType = _data["handleType"];
        }
    }

    static fromJS(data: any): TicketInvestmentUpsertProgressCommand {
        data = typeof data === 'object' ? data : {};
        let result = new TicketInvestmentUpsertProgressCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["handleType"] = this.handleType;
        return data;
    }

    clone(): TicketInvestmentUpsertProgressCommand {
        const json = this.toJSON();
        let result = new TicketInvestmentUpsertProgressCommand();
        result.init(json);
        return result;
    }
}

export interface ITicketInvestmentUpsertProgressCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: TicketInvestmentUpsertProgressDto;
    handleType?: string | undefined;
}

export class TicketInvestmentUpsertProgressDto implements ITicketInvestmentUpsertProgressDto {
    id?: number;
    progressId?: number;
    documentPhoto1?: string | undefined;
    documentPhoto2?: string | undefined;
    documentPhoto3?: string | undefined;
    documentPhoto4?: string | undefined;
    documentPhoto5?: string | undefined;
    note?: string | undefined;
    upsertRewardItems?: TicketInvestmentUpsertProgressRewardItemDto[] | undefined;
    upsertMaterials?: TicketInvestmentUpsertProgressMaterialDto[] | undefined;

    constructor(data?: ITicketInvestmentUpsertProgressDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.progressId = _data["progressId"];
            this.documentPhoto1 = _data["documentPhoto1"];
            this.documentPhoto2 = _data["documentPhoto2"];
            this.documentPhoto3 = _data["documentPhoto3"];
            this.documentPhoto4 = _data["documentPhoto4"];
            this.documentPhoto5 = _data["documentPhoto5"];
            this.note = _data["note"];
            if (Array.isArray(_data["upsertRewardItems"])) {
                this.upsertRewardItems = [] as any;
                for (let item of _data["upsertRewardItems"])
                    this.upsertRewardItems!.push(TicketInvestmentUpsertProgressRewardItemDto.fromJS(item));
            }
            if (Array.isArray(_data["upsertMaterials"])) {
                this.upsertMaterials = [] as any;
                for (let item of _data["upsertMaterials"])
                    this.upsertMaterials!.push(TicketInvestmentUpsertProgressMaterialDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TicketInvestmentUpsertProgressDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketInvestmentUpsertProgressDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["progressId"] = this.progressId;
        data["documentPhoto1"] = this.documentPhoto1;
        data["documentPhoto2"] = this.documentPhoto2;
        data["documentPhoto3"] = this.documentPhoto3;
        data["documentPhoto4"] = this.documentPhoto4;
        data["documentPhoto5"] = this.documentPhoto5;
        data["note"] = this.note;
        if (Array.isArray(this.upsertRewardItems)) {
            data["upsertRewardItems"] = [];
            for (let item of this.upsertRewardItems)
                data["upsertRewardItems"].push(item.toJSON());
        }
        if (Array.isArray(this.upsertMaterials)) {
            data["upsertMaterials"] = [];
            for (let item of this.upsertMaterials)
                data["upsertMaterials"].push(item.toJSON());
        }
        return data;
    }

    clone(): TicketInvestmentUpsertProgressDto {
        const json = this.toJSON();
        let result = new TicketInvestmentUpsertProgressDto();
        result.init(json);
        return result;
    }
}

export interface ITicketInvestmentUpsertProgressDto {
    id?: number;
    progressId?: number;
    documentPhoto1?: string | undefined;
    documentPhoto2?: string | undefined;
    documentPhoto3?: string | undefined;
    documentPhoto4?: string | undefined;
    documentPhoto5?: string | undefined;
    note?: string | undefined;
    upsertRewardItems?: TicketInvestmentUpsertProgressRewardItemDto[] | undefined;
    upsertMaterials?: TicketInvestmentUpsertProgressMaterialDto[] | undefined;
}

export class TicketInvestmentUpsertProgressMaterialDto implements ITicketInvestmentUpsertProgressMaterialDto {
    id?: number;
    materialId?: number;
    isReceived?: boolean;
    isSentDesign?: boolean;
    photo1?: string | undefined;
    photo2?: string | undefined;
    photo3?: string | undefined;
    photo4?: string | undefined;
    photo5?: string | undefined;

    constructor(data?: ITicketInvestmentUpsertProgressMaterialDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.materialId = _data["materialId"];
            this.isReceived = _data["isReceived"];
            this.isSentDesign = _data["isSentDesign"];
            this.photo1 = _data["photo1"];
            this.photo2 = _data["photo2"];
            this.photo3 = _data["photo3"];
            this.photo4 = _data["photo4"];
            this.photo5 = _data["photo5"];
        }
    }

    static fromJS(data: any): TicketInvestmentUpsertProgressMaterialDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketInvestmentUpsertProgressMaterialDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["materialId"] = this.materialId;
        data["isReceived"] = this.isReceived;
        data["isSentDesign"] = this.isSentDesign;
        data["photo1"] = this.photo1;
        data["photo2"] = this.photo2;
        data["photo3"] = this.photo3;
        data["photo4"] = this.photo4;
        data["photo5"] = this.photo5;
        return data;
    }

    clone(): TicketInvestmentUpsertProgressMaterialDto {
        const json = this.toJSON();
        let result = new TicketInvestmentUpsertProgressMaterialDto();
        result.init(json);
        return result;
    }
}

export interface ITicketInvestmentUpsertProgressMaterialDto {
    id?: number;
    materialId?: number;
    isReceived?: boolean;
    isSentDesign?: boolean;
    photo1?: string | undefined;
    photo2?: string | undefined;
    photo3?: string | undefined;
    photo4?: string | undefined;
    photo5?: string | undefined;
}

export class TicketInvestmentUpsertProgressRewardItemDto implements ITicketInvestmentUpsertProgressRewardItemDto {
    id?: number;
    rewardItemId?: number;
    isReceived?: boolean;

    constructor(data?: ITicketInvestmentUpsertProgressRewardItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.rewardItemId = _data["rewardItemId"];
            this.isReceived = _data["isReceived"];
        }
    }

    static fromJS(data: any): TicketInvestmentUpsertProgressRewardItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketInvestmentUpsertProgressRewardItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["rewardItemId"] = this.rewardItemId;
        data["isReceived"] = this.isReceived;
        return data;
    }

    clone(): TicketInvestmentUpsertProgressRewardItemDto {
        const json = this.toJSON();
        let result = new TicketInvestmentUpsertProgressRewardItemDto();
        result.init(json);
        return result;
    }
}

export interface ITicketInvestmentUpsertProgressRewardItemDto {
    id?: number;
    rewardItemId?: number;
    isReceived?: boolean;
}

export class TicketListDto implements ITicketListDto {
    id?: number;
    isSelected?: boolean;
    code?: string | undefined;
    consumerPhone?: string | undefined;
    consumerName?: string | undefined;
    issueDate?: Date | undefined;
    printDate?: Date | undefined;
    printCount?: number;
    lastPrintUserId?: number | undefined;
    ticketInvestmentId?: number;
    lastPrintUserName?: string | undefined;

    constructor(data?: ITicketListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.isSelected = _data["isSelected"];
            this.code = _data["code"];
            this.consumerPhone = _data["consumerPhone"];
            this.consumerName = _data["consumerName"];
            this.issueDate = _data["issueDate"] ? new Date(_data["issueDate"].toString()) : <any>undefined;
            this.printDate = _data["printDate"] ? new Date(_data["printDate"].toString()) : <any>undefined;
            this.printCount = _data["printCount"];
            this.lastPrintUserId = _data["lastPrintUserId"];
            this.ticketInvestmentId = _data["ticketInvestmentId"];
            this.lastPrintUserName = _data["lastPrintUserName"];
        }
    }

    static fromJS(data: any): TicketListDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["isSelected"] = this.isSelected;
        data["code"] = this.code;
        data["consumerPhone"] = this.consumerPhone;
        data["consumerName"] = this.consumerName;
        data["issueDate"] = this.issueDate ? this.issueDate.toISOString() : <any>undefined;
        data["printDate"] = this.printDate ? this.printDate.toISOString() : <any>undefined;
        data["printCount"] = this.printCount;
        data["lastPrintUserId"] = this.lastPrintUserId;
        data["ticketInvestmentId"] = this.ticketInvestmentId;
        data["lastPrintUserName"] = this.lastPrintUserName;
        return data;
    }

    clone(): TicketListDto {
        const json = this.toJSON();
        let result = new TicketListDto();
        result.init(json);
        return result;
    }
}

export interface ITicketListDto {
    id?: number;
    isSelected?: boolean;
    code?: string | undefined;
    consumerPhone?: string | undefined;
    consumerName?: string | undefined;
    issueDate?: Date | undefined;
    printDate?: Date | undefined;
    printCount?: number;
    lastPrintUserId?: number | undefined;
    ticketInvestmentId?: number;
    lastPrintUserName?: string | undefined;
}

export class TicketListDtoPagingResult implements ITicketListDtoPagingResult {
    items?: TicketListDto[] | undefined;
    totalCount?: number;

    constructor(data?: ITicketListDtoPagingResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TicketListDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): TicketListDtoPagingResult {
        data = typeof data === 'object' ? data : {};
        let result = new TicketListDtoPagingResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): TicketListDtoPagingResult {
        const json = this.toJSON();
        let result = new TicketListDtoPagingResult();
        result.init(json);
        return result;
    }
}

export interface ITicketListDtoPagingResult {
    items?: TicketListDto[] | undefined;
    totalCount?: number;
}

export class TicketListDtoPagingResultApiResultObject implements ITicketListDtoPagingResultApiResultObject {
    result?: TicketListDtoPagingResult;
    success?: boolean;

    constructor(data?: ITicketListDtoPagingResultApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? TicketListDtoPagingResult.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): TicketListDtoPagingResultApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new TicketListDtoPagingResultApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data;
    }

    clone(): TicketListDtoPagingResultApiResultObject {
        const json = this.toJSON();
        let result = new TicketListDtoPagingResultApiResultObject();
        result.init(json);
        return result;
    }
}

export interface ITicketListDtoPagingResultApiResultObject {
    result?: TicketListDtoPagingResult;
    success?: boolean;
}

export class TicketMaterialDto implements ITicketMaterialDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    materialId?: number;
    materialCode?: string | undefined;
    materialName?: string | undefined;
    registerQuantity?: number;
    price?: number;
    note?: string | undefined;
    amount?: number;
    isDesign?: boolean;

    constructor(data?: ITicketMaterialDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.materialId = _data["materialId"];
            this.materialCode = _data["materialCode"];
            this.materialName = _data["materialName"];
            this.registerQuantity = _data["registerQuantity"];
            this.price = _data["price"];
            this.note = _data["note"];
            this.amount = _data["amount"];
            this.isDesign = _data["isDesign"];
        }
    }

    static fromJS(data: any): TicketMaterialDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketMaterialDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["materialId"] = this.materialId;
        data["materialCode"] = this.materialCode;
        data["materialName"] = this.materialName;
        data["registerQuantity"] = this.registerQuantity;
        data["price"] = this.price;
        data["note"] = this.note;
        data["amount"] = this.amount;
        data["isDesign"] = this.isDesign;
        return data;
    }

    clone(): TicketMaterialDto {
        const json = this.toJSON();
        let result = new TicketMaterialDto();
        result.init(json);
        return result;
    }
}

export interface ITicketMaterialDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    materialId?: number;
    materialCode?: string | undefined;
    materialName?: string | undefined;
    registerQuantity?: number;
    price?: number;
    note?: string | undefined;
    amount?: number;
    isDesign?: boolean;
}

export class TicketOperationDto implements ITicketOperationDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    operationDate?: Date;
    note?: string | undefined;
    stockQuantity?: number;
    photo1?: string | undefined;
    photo2?: string | undefined;
    photo3?: string | undefined;
    photo4?: string | undefined;
    photo5?: string | undefined;
    updateUserId?: number | undefined;
    updateUserName?: string | undefined;

    constructor(data?: ITicketOperationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.operationDate = _data["operationDate"] ? new Date(_data["operationDate"].toString()) : <any>undefined;
            this.note = _data["note"];
            this.stockQuantity = _data["stockQuantity"];
            this.photo1 = _data["photo1"];
            this.photo2 = _data["photo2"];
            this.photo3 = _data["photo3"];
            this.photo4 = _data["photo4"];
            this.photo5 = _data["photo5"];
            this.updateUserId = _data["updateUserId"];
            this.updateUserName = _data["updateUserName"];
        }
    }

    static fromJS(data: any): TicketOperationDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketOperationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["operationDate"] = this.operationDate ? this.operationDate.toISOString() : <any>undefined;
        data["note"] = this.note;
        data["stockQuantity"] = this.stockQuantity;
        data["photo1"] = this.photo1;
        data["photo2"] = this.photo2;
        data["photo3"] = this.photo3;
        data["photo4"] = this.photo4;
        data["photo5"] = this.photo5;
        data["updateUserId"] = this.updateUserId;
        data["updateUserName"] = this.updateUserName;
        return data;
    }

    clone(): TicketOperationDto {
        const json = this.toJSON();
        let result = new TicketOperationDto();
        result.init(json);
        return result;
    }
}

export interface ITicketOperationDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    operationDate?: Date;
    note?: string | undefined;
    stockQuantity?: number;
    photo1?: string | undefined;
    photo2?: string | undefined;
    photo3?: string | undefined;
    photo4?: string | undefined;
    photo5?: string | undefined;
    updateUserId?: number | undefined;
    updateUserName?: string | undefined;
}

export class TicketProgressDto implements ITicketProgressDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    updateTime?: Date;
    documentPhoto1?: string | undefined;
    documentPhoto2?: string | undefined;
    documentPhoto3?: string | undefined;
    documentPhoto4?: string | undefined;
    documentPhoto5?: string | undefined;
    note?: string | undefined;
    materials?: TicketProgressMaterialDto[] | undefined;
    rewardItems?: TicketProgressRewardItemDto[] | undefined;
    updateUserId?: number;
    updateUserName?: string | undefined;

    constructor(data?: ITicketProgressDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.updateTime = _data["updateTime"] ? new Date(_data["updateTime"].toString()) : <any>undefined;
            this.documentPhoto1 = _data["documentPhoto1"];
            this.documentPhoto2 = _data["documentPhoto2"];
            this.documentPhoto3 = _data["documentPhoto3"];
            this.documentPhoto4 = _data["documentPhoto4"];
            this.documentPhoto5 = _data["documentPhoto5"];
            this.note = _data["note"];
            if (Array.isArray(_data["materials"])) {
                this.materials = [] as any;
                for (let item of _data["materials"])
                    this.materials!.push(TicketProgressMaterialDto.fromJS(item));
            }
            if (Array.isArray(_data["rewardItems"])) {
                this.rewardItems = [] as any;
                for (let item of _data["rewardItems"])
                    this.rewardItems!.push(TicketProgressRewardItemDto.fromJS(item));
            }
            this.updateUserId = _data["updateUserId"];
            this.updateUserName = _data["updateUserName"];
        }
    }

    static fromJS(data: any): TicketProgressDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketProgressDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["updateTime"] = this.updateTime ? this.updateTime.toISOString() : <any>undefined;
        data["documentPhoto1"] = this.documentPhoto1;
        data["documentPhoto2"] = this.documentPhoto2;
        data["documentPhoto3"] = this.documentPhoto3;
        data["documentPhoto4"] = this.documentPhoto4;
        data["documentPhoto5"] = this.documentPhoto5;
        data["note"] = this.note;
        if (Array.isArray(this.materials)) {
            data["materials"] = [];
            for (let item of this.materials)
                data["materials"].push(item.toJSON());
        }
        if (Array.isArray(this.rewardItems)) {
            data["rewardItems"] = [];
            for (let item of this.rewardItems)
                data["rewardItems"].push(item.toJSON());
        }
        data["updateUserId"] = this.updateUserId;
        data["updateUserName"] = this.updateUserName;
        return data;
    }

    clone(): TicketProgressDto {
        const json = this.toJSON();
        let result = new TicketProgressDto();
        result.init(json);
        return result;
    }
}

export interface ITicketProgressDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    updateTime?: Date;
    documentPhoto1?: string | undefined;
    documentPhoto2?: string | undefined;
    documentPhoto3?: string | undefined;
    documentPhoto4?: string | undefined;
    documentPhoto5?: string | undefined;
    note?: string | undefined;
    materials?: TicketProgressMaterialDto[] | undefined;
    rewardItems?: TicketProgressRewardItemDto[] | undefined;
    updateUserId?: number;
    updateUserName?: string | undefined;
}

export class TicketProgressMaterialDto implements ITicketProgressMaterialDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    materialId?: number;
    materialName?: string | undefined;
    materialCode?: string | undefined;
    isReceived?: boolean;
    isSentDesign?: boolean;
    photo1?: string | undefined;
    photo2?: string | undefined;
    photo3?: string | undefined;
    photo4?: string | undefined;
    photo5?: string | undefined;
    price?: number;
    isDesign?: boolean;
    registerQuantity?: number;
    amount?: number;

    constructor(data?: ITicketProgressMaterialDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.materialId = _data["materialId"];
            this.materialName = _data["materialName"];
            this.materialCode = _data["materialCode"];
            this.isReceived = _data["isReceived"];
            this.isSentDesign = _data["isSentDesign"];
            this.photo1 = _data["photo1"];
            this.photo2 = _data["photo2"];
            this.photo3 = _data["photo3"];
            this.photo4 = _data["photo4"];
            this.photo5 = _data["photo5"];
            this.price = _data["price"];
            this.isDesign = _data["isDesign"];
            this.registerQuantity = _data["registerQuantity"];
            this.amount = _data["amount"];
        }
    }

    static fromJS(data: any): TicketProgressMaterialDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketProgressMaterialDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["materialId"] = this.materialId;
        data["materialName"] = this.materialName;
        data["materialCode"] = this.materialCode;
        data["isReceived"] = this.isReceived;
        data["isSentDesign"] = this.isSentDesign;
        data["photo1"] = this.photo1;
        data["photo2"] = this.photo2;
        data["photo3"] = this.photo3;
        data["photo4"] = this.photo4;
        data["photo5"] = this.photo5;
        data["price"] = this.price;
        data["isDesign"] = this.isDesign;
        data["registerQuantity"] = this.registerQuantity;
        data["amount"] = this.amount;
        return data;
    }

    clone(): TicketProgressMaterialDto {
        const json = this.toJSON();
        let result = new TicketProgressMaterialDto();
        result.init(json);
        return result;
    }
}

export interface ITicketProgressMaterialDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    materialId?: number;
    materialName?: string | undefined;
    materialCode?: string | undefined;
    isReceived?: boolean;
    isSentDesign?: boolean;
    photo1?: string | undefined;
    photo2?: string | undefined;
    photo3?: string | undefined;
    photo4?: string | undefined;
    photo5?: string | undefined;
    price?: number;
    isDesign?: boolean;
    registerQuantity?: number;
    amount?: number;
}

export class TicketProgressRewardItemDto implements ITicketProgressRewardItemDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    rewardItemId?: number;
    rewardItemCode?: string | undefined;
    rewardItemName?: string | undefined;
    isReceived?: boolean;
    documentLink?: string | undefined;
    price?: number;
    quantity?: number;

    constructor(data?: ITicketProgressRewardItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.rewardItemId = _data["rewardItemId"];
            this.rewardItemCode = _data["rewardItemCode"];
            this.rewardItemName = _data["rewardItemName"];
            this.isReceived = _data["isReceived"];
            this.documentLink = _data["documentLink"];
            this.price = _data["price"];
            this.quantity = _data["quantity"];
        }
    }

    static fromJS(data: any): TicketProgressRewardItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketProgressRewardItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["rewardItemId"] = this.rewardItemId;
        data["rewardItemCode"] = this.rewardItemCode;
        data["rewardItemName"] = this.rewardItemName;
        data["isReceived"] = this.isReceived;
        data["documentLink"] = this.documentLink;
        data["price"] = this.price;
        data["quantity"] = this.quantity;
        return data;
    }

    clone(): TicketProgressRewardItemDto {
        const json = this.toJSON();
        let result = new TicketProgressRewardItemDto();
        result.init(json);
        return result;
    }
}

export interface ITicketProgressRewardItemDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    rewardItemId?: number;
    rewardItemCode?: string | undefined;
    rewardItemName?: string | undefined;
    isReceived?: boolean;
    documentLink?: string | undefined;
    price?: number;
    quantity?: number;
}

export class TicketRewardItemDto implements ITicketRewardItemDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    rewardItemId?: number;
    rewardItemName?: string | undefined;
    quantity?: number;
    price?: number;
    amount?: number;
    documentLink?: string | undefined;
    rewardItemCode?: string | undefined;

    constructor(data?: ITicketRewardItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.rewardItemId = _data["rewardItemId"];
            this.rewardItemName = _data["rewardItemName"];
            this.quantity = _data["quantity"];
            this.price = _data["price"];
            this.amount = _data["amount"];
            this.documentLink = _data["documentLink"];
            this.rewardItemCode = _data["rewardItemCode"];
        }
    }

    static fromJS(data: any): TicketRewardItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketRewardItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["rewardItemId"] = this.rewardItemId;
        data["rewardItemName"] = this.rewardItemName;
        data["quantity"] = this.quantity;
        data["price"] = this.price;
        data["amount"] = this.amount;
        data["documentLink"] = this.documentLink;
        data["rewardItemCode"] = this.rewardItemCode;
        return data;
    }

    clone(): TicketRewardItemDto {
        const json = this.toJSON();
        let result = new TicketRewardItemDto();
        result.init(json);
        return result;
    }
}

export interface ITicketRewardItemDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    rewardItemId?: number;
    rewardItemName?: string | undefined;
    quantity?: number;
    price?: number;
    amount?: number;
    documentLink?: string | undefined;
    rewardItemCode?: string | undefined;
}

export class TicketSalesCommitmentDto implements ITicketSalesCommitmentDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    year?: number;
    month?: number;
    amount?: number;

    constructor(data?: ITicketSalesCommitmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.year = _data["year"];
            this.month = _data["month"];
            this.amount = _data["amount"];
        }
    }

    static fromJS(data: any): TicketSalesCommitmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketSalesCommitmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["year"] = this.year;
        data["month"] = this.month;
        data["amount"] = this.amount;
        return data;
    }

    clone(): TicketSalesCommitmentDto {
        const json = this.toJSON();
        let result = new TicketSalesCommitmentDto();
        result.init(json);
        return result;
    }
}

export interface ITicketSalesCommitmentDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    year?: number;
    month?: number;
    amount?: number;
}

export class UpdateProfileCommand implements IUpdateProfileCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: UpdateProfileDto;

    constructor(data?: IUpdateProfileCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? UpdateProfileDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateProfileCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProfileCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }

    clone(): UpdateProfileCommand {
        const json = this.toJSON();
        let result = new UpdateProfileCommand();
        result.init(json);
        return result;
    }
}

export interface IUpdateProfileCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: UpdateProfileDto;
}

export class UpdateProfileDto implements IUpdateProfileDto {
    password?: string | undefined;
    name?: string | undefined;
    emailAddress?: string | undefined;
    phoneNumber?: string | undefined;
    birthday?: Date | undefined;

    constructor(data?: IUpdateProfileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.password = _data["password"];
            this.name = _data["name"];
            this.emailAddress = _data["emailAddress"];
            this.phoneNumber = _data["phoneNumber"];
            this.birthday = _data["birthday"] ? new Date(_data["birthday"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateProfileDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProfileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["password"] = this.password;
        data["name"] = this.name;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["birthday"] = this.birthday ? this.birthday.toISOString() : <any>undefined;
        return data;
    }

    clone(): UpdateProfileDto {
        const json = this.toJSON();
        let result = new UpdateProfileDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateProfileDto {
    password?: string | undefined;
    name?: string | undefined;
    emailAddress?: string | undefined;
    phoneNumber?: string | undefined;
    birthday?: Date | undefined;
}

export class UpsertAppSettingCommand implements IUpsertAppSettingCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: UpsertAppSettingDto;
    readonly handleType?: string | undefined;

    constructor(data?: IUpsertAppSettingCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? UpsertAppSettingDto.fromJS(_data["data"]) : <any>undefined;
            (<any>this).handleType = _data["handleType"];
        }
    }

    static fromJS(data: any): UpsertAppSettingCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpsertAppSettingCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["handleType"] = this.handleType;
        return data;
    }

    clone(): UpsertAppSettingCommand {
        const json = this.toJSON();
        let result = new UpsertAppSettingCommand();
        result.init(json);
        return result;
    }
}

export interface IUpsertAppSettingCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: UpsertAppSettingDto;
    handleType?: string | undefined;
}

export class UpsertAppSettingDto implements IUpsertAppSettingDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    value?: string | undefined;
    description?: string | undefined;

    constructor(data?: IUpsertAppSettingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.value = _data["value"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): UpsertAppSettingDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpsertAppSettingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["value"] = this.value;
        data["description"] = this.description;
        return data;
    }

    clone(): UpsertAppSettingDto {
        const json = this.toJSON();
        let result = new UpsertAppSettingDto();
        result.init(json);
        return result;
    }
}

export interface IUpsertAppSettingDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    value?: string | undefined;
    description?: string | undefined;
}

export class UpsertBrandCommand implements IUpsertBrandCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: UpsertBrandDto;
    readonly handleType?: string | undefined;

    constructor(data?: IUpsertBrandCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? UpsertBrandDto.fromJS(_data["data"]) : <any>undefined;
            (<any>this).handleType = _data["handleType"];
        }
    }

    static fromJS(data: any): UpsertBrandCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpsertBrandCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["handleType"] = this.handleType;
        return data;
    }

    clone(): UpsertBrandCommand {
        const json = this.toJSON();
        let result = new UpsertBrandCommand();
        result.init(json);
        return result;
    }
}

export interface IUpsertBrandCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: UpsertBrandDto;
    handleType?: string | undefined;
}

export class UpsertBrandDto implements IUpsertBrandDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    isActive?: boolean;

    constructor(data?: IUpsertBrandDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): UpsertBrandDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpsertBrandDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): UpsertBrandDto {
        const json = this.toJSON();
        let result = new UpsertBrandDto();
        result.init(json);
        return result;
    }
}

export interface IUpsertBrandDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    isActive?: boolean;
}

export class UpsertCycleCommand implements IUpsertCycleCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: UpsertCycleDto;
    readonly handleType?: string | undefined;

    constructor(data?: IUpsertCycleCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? UpsertCycleDto.fromJS(_data["data"]) : <any>undefined;
            (<any>this).handleType = _data["handleType"];
        }
    }

    static fromJS(data: any): UpsertCycleCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpsertCycleCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["handleType"] = this.handleType;
        return data;
    }

    clone(): UpsertCycleCommand {
        const json = this.toJSON();
        let result = new UpsertCycleCommand();
        result.init(json);
        return result;
    }
}

export interface IUpsertCycleCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: UpsertCycleDto;
    handleType?: string | undefined;
}

export class UpsertCycleDto implements IUpsertCycleDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    number?: string | undefined;
    year?: number;
    isActive?: boolean;
    fromDate?: Date;
    toDate?: Date;

    constructor(data?: IUpsertCycleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.number = _data["number"];
            this.year = _data["year"];
            this.isActive = _data["isActive"];
            this.fromDate = _data["fromDate"] ? new Date(_data["fromDate"].toString()) : <any>undefined;
            this.toDate = _data["toDate"] ? new Date(_data["toDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UpsertCycleDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpsertCycleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["number"] = this.number;
        data["year"] = this.year;
        data["isActive"] = this.isActive;
        data["fromDate"] = this.fromDate ? this.fromDate.toISOString() : <any>undefined;
        data["toDate"] = this.toDate ? this.toDate.toISOString() : <any>undefined;
        return data;
    }

    clone(): UpsertCycleDto {
        const json = this.toJSON();
        let result = new UpsertCycleDto();
        result.init(json);
        return result;
    }
}

export interface IUpsertCycleDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    number?: string | undefined;
    year?: number;
    isActive?: boolean;
    fromDate?: Date;
    toDate?: Date;
}

export class UpsertInvestmentBranchSettingDto implements IUpsertInvestmentBranchSettingDto {
    id?: number;
    isEditablePoint?: boolean;
    branchId?: number;

    constructor(data?: IUpsertInvestmentBranchSettingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.isEditablePoint = _data["isEditablePoint"];
            this.branchId = _data["branchId"];
        }
    }

    static fromJS(data: any): UpsertInvestmentBranchSettingDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpsertInvestmentBranchSettingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["isEditablePoint"] = this.isEditablePoint;
        data["branchId"] = this.branchId;
        return data;
    }

    clone(): UpsertInvestmentBranchSettingDto {
        const json = this.toJSON();
        let result = new UpsertInvestmentBranchSettingDto();
        result.init(json);
        return result;
    }
}

export interface IUpsertInvestmentBranchSettingDto {
    id?: number;
    isEditablePoint?: boolean;
    branchId?: number;
}

export class UpsertInvestmentBranchSettingDtoCrudListDto implements IUpsertInvestmentBranchSettingDtoCrudListDto {
    upsertedItems?: UpsertInvestmentBranchSettingDto[] | undefined;
    deletedItems?: UpsertInvestmentBranchSettingDto[] | undefined;

    constructor(data?: IUpsertInvestmentBranchSettingDtoCrudListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["upsertedItems"])) {
                this.upsertedItems = [] as any;
                for (let item of _data["upsertedItems"])
                    this.upsertedItems!.push(UpsertInvestmentBranchSettingDto.fromJS(item));
            }
            if (Array.isArray(_data["deletedItems"])) {
                this.deletedItems = [] as any;
                for (let item of _data["deletedItems"])
                    this.deletedItems!.push(UpsertInvestmentBranchSettingDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpsertInvestmentBranchSettingDtoCrudListDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpsertInvestmentBranchSettingDtoCrudListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.upsertedItems)) {
            data["upsertedItems"] = [];
            for (let item of this.upsertedItems)
                data["upsertedItems"].push(item.toJSON());
        }
        if (Array.isArray(this.deletedItems)) {
            data["deletedItems"] = [];
            for (let item of this.deletedItems)
                data["deletedItems"].push(item.toJSON());
        }
        return data;
    }

    clone(): UpsertInvestmentBranchSettingDtoCrudListDto {
        const json = this.toJSON();
        let result = new UpsertInvestmentBranchSettingDtoCrudListDto();
        result.init(json);
        return result;
    }
}

export interface IUpsertInvestmentBranchSettingDtoCrudListDto {
    upsertedItems?: UpsertInvestmentBranchSettingDto[] | undefined;
    deletedItems?: UpsertInvestmentBranchSettingDto[] | undefined;
}

export class UpsertInvestmentSettingCommand implements IUpsertInvestmentSettingCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: UpsertInvestmentSettingDto;
    readonly handleType?: string | undefined;

    constructor(data?: IUpsertInvestmentSettingCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? UpsertInvestmentSettingDto.fromJS(_data["data"]) : <any>undefined;
            (<any>this).handleType = _data["handleType"];
        }
    }

    static fromJS(data: any): UpsertInvestmentSettingCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpsertInvestmentSettingCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["handleType"] = this.handleType;
        return data;
    }

    clone(): UpsertInvestmentSettingCommand {
        const json = this.toJSON();
        let result = new UpsertInvestmentSettingCommand();
        result.init(json);
        return result;
    }
}

export interface IUpsertInvestmentSettingCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: UpsertInvestmentSettingDto;
    handleType?: string | undefined;
}

export class UpsertInvestmentSettingDto implements IUpsertInvestmentSettingDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    maxInvestAmount?: number;
    amountPerPoint?: number;
    maxInvestmentQueryMonths?: number;
    defaultPointsForTicket?: number;
    checkQrCodeBranch?: boolean;
    beginIssueDaysAfterCurrent?: number;
    endIssueDaysBeforeOperation?: number;
    investmentBranchSettingChanges?: UpsertInvestmentBranchSettingDtoCrudListDto;

    constructor(data?: IUpsertInvestmentSettingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.maxInvestAmount = _data["maxInvestAmount"];
            this.amountPerPoint = _data["amountPerPoint"];
            this.maxInvestmentQueryMonths = _data["maxInvestmentQueryMonths"];
            this.defaultPointsForTicket = _data["defaultPointsForTicket"];
            this.checkQrCodeBranch = _data["checkQrCodeBranch"];
            this.beginIssueDaysAfterCurrent = _data["beginIssueDaysAfterCurrent"];
            this.endIssueDaysBeforeOperation = _data["endIssueDaysBeforeOperation"];
            this.investmentBranchSettingChanges = _data["investmentBranchSettingChanges"] ? UpsertInvestmentBranchSettingDtoCrudListDto.fromJS(_data["investmentBranchSettingChanges"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpsertInvestmentSettingDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpsertInvestmentSettingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["maxInvestAmount"] = this.maxInvestAmount;
        data["amountPerPoint"] = this.amountPerPoint;
        data["maxInvestmentQueryMonths"] = this.maxInvestmentQueryMonths;
        data["defaultPointsForTicket"] = this.defaultPointsForTicket;
        data["checkQrCodeBranch"] = this.checkQrCodeBranch;
        data["beginIssueDaysAfterCurrent"] = this.beginIssueDaysAfterCurrent;
        data["endIssueDaysBeforeOperation"] = this.endIssueDaysBeforeOperation;
        data["investmentBranchSettingChanges"] = this.investmentBranchSettingChanges ? this.investmentBranchSettingChanges.toJSON() : <any>undefined;
        return data;
    }

    clone(): UpsertInvestmentSettingDto {
        const json = this.toJSON();
        let result = new UpsertInvestmentSettingDto();
        result.init(json);
        return result;
    }
}

export interface IUpsertInvestmentSettingDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    maxInvestAmount?: number;
    amountPerPoint?: number;
    maxInvestmentQueryMonths?: number;
    defaultPointsForTicket?: number;
    checkQrCodeBranch?: boolean;
    beginIssueDaysAfterCurrent?: number;
    endIssueDaysBeforeOperation?: number;
    investmentBranchSettingChanges?: UpsertInvestmentBranchSettingDtoCrudListDto;
}

export class UpsertMaterialDto implements IUpsertMaterialDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    materialTypeId?: number;
    description?: string | undefined;
    value?: number;
    isActive?: boolean;
    isDesign?: boolean;

    constructor(data?: IUpsertMaterialDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.materialTypeId = _data["materialTypeId"];
            this.description = _data["description"];
            this.value = _data["value"];
            this.isActive = _data["isActive"];
            this.isDesign = _data["isDesign"];
        }
    }

    static fromJS(data: any): UpsertMaterialDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpsertMaterialDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["materialTypeId"] = this.materialTypeId;
        data["description"] = this.description;
        data["value"] = this.value;
        data["isActive"] = this.isActive;
        data["isDesign"] = this.isDesign;
        return data;
    }

    clone(): UpsertMaterialDto {
        const json = this.toJSON();
        let result = new UpsertMaterialDto();
        result.init(json);
        return result;
    }
}

export interface IUpsertMaterialDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    materialTypeId?: number;
    description?: string | undefined;
    value?: number;
    isActive?: boolean;
    isDesign?: boolean;
}

export class UpsertProductClassCommand implements IUpsertProductClassCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: UpsertProductClassDto;
    readonly handleType?: string | undefined;

    constructor(data?: IUpsertProductClassCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? UpsertProductClassDto.fromJS(_data["data"]) : <any>undefined;
            (<any>this).handleType = _data["handleType"];
        }
    }

    static fromJS(data: any): UpsertProductClassCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpsertProductClassCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["handleType"] = this.handleType;
        return data;
    }

    clone(): UpsertProductClassCommand {
        const json = this.toJSON();
        let result = new UpsertProductClassCommand();
        result.init(json);
        return result;
    }
}

export interface IUpsertProductClassCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: UpsertProductClassDto;
    handleType?: string | undefined;
}

export class UpsertProductClassDto implements IUpsertProductClassDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    rewardCode?: string | undefined;
    isActive?: boolean;

    constructor(data?: IUpsertProductClassDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.rewardCode = _data["rewardCode"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): UpsertProductClassDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpsertProductClassDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["rewardCode"] = this.rewardCode;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): UpsertProductClassDto {
        const json = this.toJSON();
        let result = new UpsertProductClassDto();
        result.init(json);
        return result;
    }
}

export interface IUpsertProductClassDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    rewardCode?: string | undefined;
    isActive?: boolean;
}

export class UpsertProductCommand implements IUpsertProductCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: UpsertProductDto;
    readonly handleType?: string | undefined;

    constructor(data?: IUpsertProductCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? UpsertProductDto.fromJS(_data["data"]) : <any>undefined;
            (<any>this).handleType = _data["handleType"];
        }
    }

    static fromJS(data: any): UpsertProductCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpsertProductCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["handleType"] = this.handleType;
        return data;
    }

    clone(): UpsertProductCommand {
        const json = this.toJSON();
        let result = new UpsertProductCommand();
        result.init(json);
        return result;
    }
}

export interface IUpsertProductCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: UpsertProductDto;
    handleType?: string | undefined;
}

export class UpsertProductDto implements IUpsertProductDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    isActive?: boolean;
    unit?: string | undefined;
    caseUnit?: string | undefined;
    packSize?: number;
    productClassId?: number | undefined;
    subProductClassId?: number | undefined;
    brandId?: number | undefined;
    updateDate?: Date;
    point?: number;

    constructor(data?: IUpsertProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.isActive = _data["isActive"];
            this.unit = _data["unit"];
            this.caseUnit = _data["caseUnit"];
            this.packSize = _data["packSize"];
            this.productClassId = _data["productClassId"];
            this.subProductClassId = _data["subProductClassId"];
            this.brandId = _data["brandId"];
            this.updateDate = _data["updateDate"] ? new Date(_data["updateDate"].toString()) : <any>undefined;
            this.point = _data["point"];
        }
    }

    static fromJS(data: any): UpsertProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpsertProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["description"] = this.description;
        data["isActive"] = this.isActive;
        data["unit"] = this.unit;
        data["caseUnit"] = this.caseUnit;
        data["packSize"] = this.packSize;
        data["productClassId"] = this.productClassId;
        data["subProductClassId"] = this.subProductClassId;
        data["brandId"] = this.brandId;
        data["updateDate"] = this.updateDate ? this.updateDate.toISOString() : <any>undefined;
        data["point"] = this.point;
        return data;
    }

    clone(): UpsertProductDto {
        const json = this.toJSON();
        let result = new UpsertProductDto();
        result.init(json);
        return result;
    }
}

export interface IUpsertProductDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    isActive?: boolean;
    unit?: string | undefined;
    caseUnit?: string | undefined;
    packSize?: number;
    productClassId?: number | undefined;
    subProductClassId?: number | undefined;
    brandId?: number | undefined;
    updateDate?: Date;
    point?: number;
}

export class UpsertProductItemCommand implements IUpsertProductItemCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: UpsertProductDto;
    readonly handleType?: string | undefined;

    constructor(data?: IUpsertProductItemCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? UpsertProductDto.fromJS(_data["data"]) : <any>undefined;
            (<any>this).handleType = _data["handleType"];
        }
    }

    static fromJS(data: any): UpsertProductItemCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpsertProductItemCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["handleType"] = this.handleType;
        return data;
    }

    clone(): UpsertProductItemCommand {
        const json = this.toJSON();
        let result = new UpsertProductItemCommand();
        result.init(json);
        return result;
    }
}

export interface IUpsertProductItemCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: UpsertProductDto;
    handleType?: string | undefined;
}

export class UpsertProductUnitCommand implements IUpsertProductUnitCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: UpsertProductUnitDto;
    readonly handleType?: string | undefined;

    constructor(data?: IUpsertProductUnitCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? UpsertProductUnitDto.fromJS(_data["data"]) : <any>undefined;
            (<any>this).handleType = _data["handleType"];
        }
    }

    static fromJS(data: any): UpsertProductUnitCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpsertProductUnitCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["handleType"] = this.handleType;
        return data;
    }

    clone(): UpsertProductUnitCommand {
        const json = this.toJSON();
        let result = new UpsertProductUnitCommand();
        result.init(json);
        return result;
    }
}

export interface IUpsertProductUnitCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: UpsertProductUnitDto;
    handleType?: string | undefined;
}

export class UpsertProductUnitDto implements IUpsertProductUnitDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    isActive?: boolean;

    constructor(data?: IUpsertProductUnitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): UpsertProductUnitDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpsertProductUnitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): UpsertProductUnitDto {
        const json = this.toJSON();
        let result = new UpsertProductUnitDto();
        result.init(json);
        return result;
    }
}

export interface IUpsertProductUnitDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    isActive?: boolean;
}

export class UpsertRoleCommand implements IUpsertRoleCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: UpsertRoleDto;
    readonly handleType?: string | undefined;

    constructor(data?: IUpsertRoleCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? UpsertRoleDto.fromJS(_data["data"]) : <any>undefined;
            (<any>this).handleType = _data["handleType"];
        }
    }

    static fromJS(data: any): UpsertRoleCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpsertRoleCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["handleType"] = this.handleType;
        return data;
    }

    clone(): UpsertRoleCommand {
        const json = this.toJSON();
        let result = new UpsertRoleCommand();
        result.init(json);
        return result;
    }
}

export interface IUpsertRoleCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: UpsertRoleDto;
    handleType?: string | undefined;
}

export class UpsertRoleDto implements IUpsertRoleDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    roleName?: string | undefined;
    displayName?: string | undefined;
    description?: string | undefined;
    isActive?: boolean;
    permissions?: RolePermissionDto[] | undefined;
    permissionChanges?: RolePermissionDtoCrudListDto;

    constructor(data?: IUpsertRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.roleName = _data["roleName"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(RolePermissionDto.fromJS(item));
            }
            this.permissionChanges = _data["permissionChanges"] ? RolePermissionDtoCrudListDto.fromJS(_data["permissionChanges"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpsertRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpsertRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["roleName"] = this.roleName;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        data["permissionChanges"] = this.permissionChanges ? this.permissionChanges.toJSON() : <any>undefined;
        return data;
    }

    clone(): UpsertRoleDto {
        const json = this.toJSON();
        let result = new UpsertRoleDto();
        result.init(json);
        return result;
    }
}

export interface IUpsertRoleDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    roleName?: string | undefined;
    displayName?: string | undefined;
    description?: string | undefined;
    isActive?: boolean;
    permissions?: RolePermissionDto[] | undefined;
    permissionChanges?: RolePermissionDtoCrudListDto;
}

export class UpsertUserAssignmentDto implements IUpsertUserAssignmentDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    salesOrgId?: number;

    constructor(data?: IUpsertUserAssignmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.salesOrgId = _data["salesOrgId"];
        }
    }

    static fromJS(data: any): UpsertUserAssignmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpsertUserAssignmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["salesOrgId"] = this.salesOrgId;
        return data;
    }

    clone(): UpsertUserAssignmentDto {
        const json = this.toJSON();
        let result = new UpsertUserAssignmentDto();
        result.init(json);
        return result;
    }
}

export interface IUpsertUserAssignmentDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    salesOrgId?: number;
}

export class UpsertUserAssignmentDtoCrudListDto implements IUpsertUserAssignmentDtoCrudListDto {
    upsertedItems?: UpsertUserAssignmentDto[] | undefined;
    deletedItems?: UpsertUserAssignmentDto[] | undefined;

    constructor(data?: IUpsertUserAssignmentDtoCrudListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["upsertedItems"])) {
                this.upsertedItems = [] as any;
                for (let item of _data["upsertedItems"])
                    this.upsertedItems!.push(UpsertUserAssignmentDto.fromJS(item));
            }
            if (Array.isArray(_data["deletedItems"])) {
                this.deletedItems = [] as any;
                for (let item of _data["deletedItems"])
                    this.deletedItems!.push(UpsertUserAssignmentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpsertUserAssignmentDtoCrudListDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpsertUserAssignmentDtoCrudListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.upsertedItems)) {
            data["upsertedItems"] = [];
            for (let item of this.upsertedItems)
                data["upsertedItems"].push(item.toJSON());
        }
        if (Array.isArray(this.deletedItems)) {
            data["deletedItems"] = [];
            for (let item of this.deletedItems)
                data["deletedItems"].push(item.toJSON());
        }
        return data;
    }

    clone(): UpsertUserAssignmentDtoCrudListDto {
        const json = this.toJSON();
        let result = new UpsertUserAssignmentDtoCrudListDto();
        result.init(json);
        return result;
    }
}

export interface IUpsertUserAssignmentDtoCrudListDto {
    upsertedItems?: UpsertUserAssignmentDto[] | undefined;
    deletedItems?: UpsertUserAssignmentDto[] | undefined;
}

export class UpsertUserDto implements IUpsertUserDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    userName?: string | undefined;
    name?: string | undefined;
    emailAddress?: string | undefined;
    phoneNumber?: string | undefined;
    isActive?: boolean;
    expireDate?: Date | undefined;
    birthday?: Date | undefined;
    registerDate?: Date;
    roleName?: string | undefined;
    roles?: UserRoleDto[] | undefined;
    assignments?: UserAssignmentDto[] | undefined;
    password?: string | undefined;
    roleChanges?: UserRoleDtoCrudListDto;
    assignmentChanges?: UpsertUserAssignmentDtoCrudListDto;

    constructor(data?: IUpsertUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.emailAddress = _data["emailAddress"];
            this.phoneNumber = _data["phoneNumber"];
            this.isActive = _data["isActive"];
            this.expireDate = _data["expireDate"] ? new Date(_data["expireDate"].toString()) : <any>undefined;
            this.birthday = _data["birthday"] ? new Date(_data["birthday"].toString()) : <any>undefined;
            this.registerDate = _data["registerDate"] ? new Date(_data["registerDate"].toString()) : <any>undefined;
            this.roleName = _data["roleName"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(UserRoleDto.fromJS(item));
            }
            if (Array.isArray(_data["assignments"])) {
                this.assignments = [] as any;
                for (let item of _data["assignments"])
                    this.assignments!.push(UserAssignmentDto.fromJS(item));
            }
            this.password = _data["password"];
            this.roleChanges = _data["roleChanges"] ? UserRoleDtoCrudListDto.fromJS(_data["roleChanges"]) : <any>undefined;
            this.assignmentChanges = _data["assignmentChanges"] ? UpsertUserAssignmentDtoCrudListDto.fromJS(_data["assignmentChanges"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpsertUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpsertUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["isActive"] = this.isActive;
        data["expireDate"] = this.expireDate ? this.expireDate.toISOString() : <any>undefined;
        data["birthday"] = this.birthday ? this.birthday.toISOString() : <any>undefined;
        data["registerDate"] = this.registerDate ? this.registerDate.toISOString() : <any>undefined;
        data["roleName"] = this.roleName;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        if (Array.isArray(this.assignments)) {
            data["assignments"] = [];
            for (let item of this.assignments)
                data["assignments"].push(item.toJSON());
        }
        data["password"] = this.password;
        data["roleChanges"] = this.roleChanges ? this.roleChanges.toJSON() : <any>undefined;
        data["assignmentChanges"] = this.assignmentChanges ? this.assignmentChanges.toJSON() : <any>undefined;
        return data;
    }

    clone(): UpsertUserDto {
        const json = this.toJSON();
        let result = new UpsertUserDto();
        result.init(json);
        return result;
    }
}

export interface IUpsertUserDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    userName?: string | undefined;
    name?: string | undefined;
    emailAddress?: string | undefined;
    phoneNumber?: string | undefined;
    isActive?: boolean;
    expireDate?: Date | undefined;
    birthday?: Date | undefined;
    registerDate?: Date;
    roleName?: string | undefined;
    roles?: UserRoleDto[] | undefined;
    assignments?: UserAssignmentDto[] | undefined;
    password?: string | undefined;
    roleChanges?: UserRoleDtoCrudListDto;
    assignmentChanges?: UpsertUserAssignmentDtoCrudListDto;
}

export class UpsertUserExtCommand implements IUpsertUserExtCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: UpsertUserDto;
    readonly handleType?: string | undefined;

    constructor(data?: IUpsertUserExtCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? UpsertUserDto.fromJS(_data["data"]) : <any>undefined;
            (<any>this).handleType = _data["handleType"];
        }
    }

    static fromJS(data: any): UpsertUserExtCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpsertUserExtCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["handleType"] = this.handleType;
        return data;
    }

    clone(): UpsertUserExtCommand {
        const json = this.toJSON();
        let result = new UpsertUserExtCommand();
        result.init(json);
        return result;
    }
}

export interface IUpsertUserExtCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: UpsertUserDto;
    handleType?: string | undefined;
}

export class UserAssignmentDto implements IUserAssignmentDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    userId?: number;
    salesOrgId?: number;
    salesOrgName?: string | undefined;

    constructor(data?: IUserAssignmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.userId = _data["userId"];
            this.salesOrgId = _data["salesOrgId"];
            this.salesOrgName = _data["salesOrgName"];
        }
    }

    static fromJS(data: any): UserAssignmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserAssignmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["userId"] = this.userId;
        data["salesOrgId"] = this.salesOrgId;
        data["salesOrgName"] = this.salesOrgName;
        return data;
    }

    clone(): UserAssignmentDto {
        const json = this.toJSON();
        let result = new UserAssignmentDto();
        result.init(json);
        return result;
    }
}

export interface IUserAssignmentDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    userId?: number;
    salesOrgId?: number;
    salesOrgName?: string | undefined;
}

export class UserDto implements IUserDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    userName?: string | undefined;
    name?: string | undefined;
    emailAddress?: string | undefined;
    phoneNumber?: string | undefined;
    isActive?: boolean;
    expireDate?: Date | undefined;
    birthday?: Date | undefined;
    registerDate?: Date;
    roleName?: string | undefined;
    roles?: UserRoleDto[] | undefined;
    assignments?: UserAssignmentDto[] | undefined;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.emailAddress = _data["emailAddress"];
            this.phoneNumber = _data["phoneNumber"];
            this.isActive = _data["isActive"];
            this.expireDate = _data["expireDate"] ? new Date(_data["expireDate"].toString()) : <any>undefined;
            this.birthday = _data["birthday"] ? new Date(_data["birthday"].toString()) : <any>undefined;
            this.registerDate = _data["registerDate"] ? new Date(_data["registerDate"].toString()) : <any>undefined;
            this.roleName = _data["roleName"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(UserRoleDto.fromJS(item));
            }
            if (Array.isArray(_data["assignments"])) {
                this.assignments = [] as any;
                for (let item of _data["assignments"])
                    this.assignments!.push(UserAssignmentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["isActive"] = this.isActive;
        data["expireDate"] = this.expireDate ? this.expireDate.toISOString() : <any>undefined;
        data["birthday"] = this.birthday ? this.birthday.toISOString() : <any>undefined;
        data["registerDate"] = this.registerDate ? this.registerDate.toISOString() : <any>undefined;
        data["roleName"] = this.roleName;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        if (Array.isArray(this.assignments)) {
            data["assignments"] = [];
            for (let item of this.assignments)
                data["assignments"].push(item.toJSON());
        }
        return data;
    }

    clone(): UserDto {
        const json = this.toJSON();
        let result = new UserDto();
        result.init(json);
        return result;
    }
}

export interface IUserDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    userName?: string | undefined;
    name?: string | undefined;
    emailAddress?: string | undefined;
    phoneNumber?: string | undefined;
    isActive?: boolean;
    expireDate?: Date | undefined;
    birthday?: Date | undefined;
    registerDate?: Date;
    roleName?: string | undefined;
    roles?: UserRoleDto[] | undefined;
    assignments?: UserAssignmentDto[] | undefined;
}

export class UserDtoApiResultObject implements IUserDtoApiResultObject {
    result?: UserDto;
    success?: boolean;

    constructor(data?: IUserDtoApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? UserDto.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): UserDtoApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new UserDtoApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data;
    }

    clone(): UserDtoApiResultObject {
        const json = this.toJSON();
        let result = new UserDtoApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IUserDtoApiResultObject {
    result?: UserDto;
    success?: boolean;
}

export class UserListItemDto implements IUserListItemDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    userName?: string | undefined;
    name?: string | undefined;
    emailAddress?: string | undefined;
    phoneNumber?: string | undefined;
    isActive?: boolean;
    expireDate?: Date | undefined;
    birthday?: Date | undefined;
    registerDate?: Date;
    roleName?: string | undefined;

    constructor(data?: IUserListItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.emailAddress = _data["emailAddress"];
            this.phoneNumber = _data["phoneNumber"];
            this.isActive = _data["isActive"];
            this.expireDate = _data["expireDate"] ? new Date(_data["expireDate"].toString()) : <any>undefined;
            this.birthday = _data["birthday"] ? new Date(_data["birthday"].toString()) : <any>undefined;
            this.registerDate = _data["registerDate"] ? new Date(_data["registerDate"].toString()) : <any>undefined;
            this.roleName = _data["roleName"];
        }
    }

    static fromJS(data: any): UserListItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserListItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["isActive"] = this.isActive;
        data["expireDate"] = this.expireDate ? this.expireDate.toISOString() : <any>undefined;
        data["birthday"] = this.birthday ? this.birthday.toISOString() : <any>undefined;
        data["registerDate"] = this.registerDate ? this.registerDate.toISOString() : <any>undefined;
        data["roleName"] = this.roleName;
        return data;
    }

    clone(): UserListItemDto {
        const json = this.toJSON();
        let result = new UserListItemDto();
        result.init(json);
        return result;
    }
}

export interface IUserListItemDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    userName?: string | undefined;
    name?: string | undefined;
    emailAddress?: string | undefined;
    phoneNumber?: string | undefined;
    isActive?: boolean;
    expireDate?: Date | undefined;
    birthday?: Date | undefined;
    registerDate?: Date;
    roleName?: string | undefined;
}

export class UserListItemDtoPagingResult implements IUserListItemDtoPagingResult {
    items?: UserListItemDto[] | undefined;
    totalCount?: number;

    constructor(data?: IUserListItemDtoPagingResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserListItemDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): UserListItemDtoPagingResult {
        data = typeof data === 'object' ? data : {};
        let result = new UserListItemDtoPagingResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): UserListItemDtoPagingResult {
        const json = this.toJSON();
        let result = new UserListItemDtoPagingResult();
        result.init(json);
        return result;
    }
}

export interface IUserListItemDtoPagingResult {
    items?: UserListItemDto[] | undefined;
    totalCount?: number;
}

export class UserListItemDtoPagingResultApiResultObject implements IUserListItemDtoPagingResultApiResultObject {
    result?: UserListItemDtoPagingResult;
    success?: boolean;

    constructor(data?: IUserListItemDtoPagingResultApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? UserListItemDtoPagingResult.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): UserListItemDtoPagingResultApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new UserListItemDtoPagingResultApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data;
    }

    clone(): UserListItemDtoPagingResultApiResultObject {
        const json = this.toJSON();
        let result = new UserListItemDtoPagingResultApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IUserListItemDtoPagingResultApiResultObject {
    result?: UserListItemDtoPagingResult;
    success?: boolean;
}

export class UserRoleDto implements IUserRoleDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    roleId?: number;
    roleName?: string | undefined;
    displayName?: string | undefined;
    description?: string | undefined;

    constructor(data?: IUserRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.roleId = _data["roleId"];
            this.roleName = _data["roleName"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): UserRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["roleId"] = this.roleId;
        data["roleName"] = this.roleName;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        return data;
    }

    clone(): UserRoleDto {
        const json = this.toJSON();
        let result = new UserRoleDto();
        result.init(json);
        return result;
    }
}

export interface IUserRoleDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    roleId?: number;
    roleName?: string | undefined;
    displayName?: string | undefined;
    description?: string | undefined;
}

export class UserRoleDtoCrudListDto implements IUserRoleDtoCrudListDto {
    upsertedItems?: UserRoleDto[] | undefined;
    deletedItems?: UserRoleDto[] | undefined;

    constructor(data?: IUserRoleDtoCrudListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["upsertedItems"])) {
                this.upsertedItems = [] as any;
                for (let item of _data["upsertedItems"])
                    this.upsertedItems!.push(UserRoleDto.fromJS(item));
            }
            if (Array.isArray(_data["deletedItems"])) {
                this.deletedItems = [] as any;
                for (let item of _data["deletedItems"])
                    this.deletedItems!.push(UserRoleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserRoleDtoCrudListDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserRoleDtoCrudListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.upsertedItems)) {
            data["upsertedItems"] = [];
            for (let item of this.upsertedItems)
                data["upsertedItems"].push(item.toJSON());
        }
        if (Array.isArray(this.deletedItems)) {
            data["deletedItems"] = [];
            for (let item of this.deletedItems)
                data["deletedItems"].push(item.toJSON());
        }
        return data;
    }

    clone(): UserRoleDtoCrudListDto {
        const json = this.toJSON();
        let result = new UserRoleDtoCrudListDto();
        result.init(json);
        return result;
    }
}

export interface IUserRoleDtoCrudListDto {
    upsertedItems?: UserRoleDto[] | undefined;
    deletedItems?: UserRoleDto[] | undefined;
}

export class VendorDto implements IVendorDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    address?: string | undefined;
    phone?: string | undefined;
    isActive?: boolean;
    zoneId?: number | undefined;
    taxReg?: string | undefined;
    representative?: string | undefined;

    constructor(data?: IVendorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.address = _data["address"];
            this.phone = _data["phone"];
            this.isActive = _data["isActive"];
            this.zoneId = _data["zoneId"];
            this.taxReg = _data["taxReg"];
            this.representative = _data["representative"];
        }
    }

    static fromJS(data: any): VendorDto {
        data = typeof data === 'object' ? data : {};
        let result = new VendorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["address"] = this.address;
        data["phone"] = this.phone;
        data["isActive"] = this.isActive;
        data["zoneId"] = this.zoneId;
        data["taxReg"] = this.taxReg;
        data["representative"] = this.representative;
        return data;
    }

    clone(): VendorDto {
        const json = this.toJSON();
        let result = new VendorDto();
        result.init(json);
        return result;
    }
}

export interface IVendorDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    address?: string | undefined;
    phone?: string | undefined;
    isActive?: boolean;
    zoneId?: number | undefined;
    taxReg?: string | undefined;
    representative?: string | undefined;
}

export class VendorDtoApiResultObject implements IVendorDtoApiResultObject {
    result?: VendorDto;
    success?: boolean;

    constructor(data?: IVendorDtoApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? VendorDto.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): VendorDtoApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new VendorDtoApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data;
    }

    clone(): VendorDtoApiResultObject {
        const json = this.toJSON();
        let result = new VendorDtoApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IVendorDtoApiResultObject {
    result?: VendorDto;
    success?: boolean;
}

export class VendorListDto implements IVendorListDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    address?: string | undefined;
    phone?: string | undefined;
    isActive?: boolean;
    zoneId?: number | undefined;
    taxReg?: string | undefined;
    representative?: string | undefined;
    zone?: string | undefined;

    constructor(data?: IVendorListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.address = _data["address"];
            this.phone = _data["phone"];
            this.isActive = _data["isActive"];
            this.zoneId = _data["zoneId"];
            this.taxReg = _data["taxReg"];
            this.representative = _data["representative"];
            this.zone = _data["zone"];
        }
    }

    static fromJS(data: any): VendorListDto {
        data = typeof data === 'object' ? data : {};
        let result = new VendorListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["address"] = this.address;
        data["phone"] = this.phone;
        data["isActive"] = this.isActive;
        data["zoneId"] = this.zoneId;
        data["taxReg"] = this.taxReg;
        data["representative"] = this.representative;
        data["zone"] = this.zone;
        return data;
    }

    clone(): VendorListDto {
        const json = this.toJSON();
        let result = new VendorListDto();
        result.init(json);
        return result;
    }
}

export interface IVendorListDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    address?: string | undefined;
    phone?: string | undefined;
    isActive?: boolean;
    zoneId?: number | undefined;
    taxReg?: string | undefined;
    representative?: string | undefined;
    zone?: string | undefined;
}

export class VendorListDtoPagingResult implements IVendorListDtoPagingResult {
    items?: VendorListDto[] | undefined;
    totalCount?: number;

    constructor(data?: IVendorListDtoPagingResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(VendorListDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): VendorListDtoPagingResult {
        data = typeof data === 'object' ? data : {};
        let result = new VendorListDtoPagingResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): VendorListDtoPagingResult {
        const json = this.toJSON();
        let result = new VendorListDtoPagingResult();
        result.init(json);
        return result;
    }
}

export interface IVendorListDtoPagingResult {
    items?: VendorListDto[] | undefined;
    totalCount?: number;
}

export class VendorListDtoPagingResultApiResultObject implements IVendorListDtoPagingResultApiResultObject {
    result?: VendorListDtoPagingResult;
    success?: boolean;

    constructor(data?: IVendorListDtoPagingResultApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? VendorListDtoPagingResult.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): VendorListDtoPagingResultApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new VendorListDtoPagingResultApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data;
    }

    clone(): VendorListDtoPagingResultApiResultObject {
        const json = this.toJSON();
        let result = new VendorListDtoPagingResultApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IVendorListDtoPagingResultApiResultObject {
    result?: VendorListDtoPagingResult;
    success?: boolean;
}

export class VendorUpsertCommand implements IVendorUpsertCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: VendorUpsertDto;
    readonly handleType?: string | undefined;

    constructor(data?: IVendorUpsertCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? VendorUpsertDto.fromJS(_data["data"]) : <any>undefined;
            (<any>this).handleType = _data["handleType"];
        }
    }

    static fromJS(data: any): VendorUpsertCommand {
        data = typeof data === 'object' ? data : {};
        let result = new VendorUpsertCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["handleType"] = this.handleType;
        return data;
    }

    clone(): VendorUpsertCommand {
        const json = this.toJSON();
        let result = new VendorUpsertCommand();
        result.init(json);
        return result;
    }
}

export interface IVendorUpsertCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: VendorUpsertDto;
    handleType?: string | undefined;
}

export class VendorUpsertDto implements IVendorUpsertDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    address?: string | undefined;
    phone?: string | undefined;
    isActive?: boolean;
    zoneId?: number | undefined;
    taxReg?: string | undefined;
    representative?: string | undefined;

    constructor(data?: IVendorUpsertDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.address = _data["address"];
            this.phone = _data["phone"];
            this.isActive = _data["isActive"];
            this.zoneId = _data["zoneId"];
            this.taxReg = _data["taxReg"];
            this.representative = _data["representative"];
        }
    }

    static fromJS(data: any): VendorUpsertDto {
        data = typeof data === 'object' ? data : {};
        let result = new VendorUpsertDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["address"] = this.address;
        data["phone"] = this.phone;
        data["isActive"] = this.isActive;
        data["zoneId"] = this.zoneId;
        data["taxReg"] = this.taxReg;
        data["representative"] = this.representative;
        return data;
    }

    clone(): VendorUpsertDto {
        const json = this.toJSON();
        let result = new VendorUpsertDto();
        result.init(json);
        return result;
    }
}

export interface IVendorUpsertDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    address?: string | undefined;
    phone?: string | undefined;
    isActive?: boolean;
    zoneId?: number | undefined;
    taxReg?: string | undefined;
    representative?: string | undefined;
}

export class WardDto implements IWardDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;

    constructor(data?: IWardDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): WardDto {
        data = typeof data === 'object' ? data : {};
        let result = new WardDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["name"] = this.name;
        return data;
    }

    clone(): WardDto {
        const json = this.toJSON();
        let result = new WardDto();
        result.init(json);
        return result;
    }
}

export interface IWardDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
}

export class WardDtoApiResultObject implements IWardDtoApiResultObject {
    result?: WardDto;
    success?: boolean;

    constructor(data?: IWardDtoApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? WardDto.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): WardDtoApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new WardDtoApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data;
    }

    clone(): WardDtoApiResultObject {
        const json = this.toJSON();
        let result = new WardDtoApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IWardDtoApiResultObject {
    result?: WardDto;
    success?: boolean;
}

export class WardDtoPagingResult implements IWardDtoPagingResult {
    items?: WardDto[] | undefined;
    totalCount?: number;

    constructor(data?: IWardDtoPagingResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(WardDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): WardDtoPagingResult {
        data = typeof data === 'object' ? data : {};
        let result = new WardDtoPagingResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): WardDtoPagingResult {
        const json = this.toJSON();
        let result = new WardDtoPagingResult();
        result.init(json);
        return result;
    }
}

export interface IWardDtoPagingResult {
    items?: WardDto[] | undefined;
    totalCount?: number;
}

export class WardDtoPagingResultApiResultObject implements IWardDtoPagingResultApiResultObject {
    result?: WardDtoPagingResult;
    success?: boolean;

    constructor(data?: IWardDtoPagingResultApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? WardDtoPagingResult.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): WardDtoPagingResultApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new WardDtoPagingResultApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data;
    }

    clone(): WardDtoPagingResultApiResultObject {
        const json = this.toJSON();
        let result = new WardDtoPagingResultApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IWardDtoPagingResultApiResultObject {
    result?: WardDtoPagingResult;
    success?: boolean;
}

export class WardNameListDto implements IWardNameListDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    district?: string | undefined;
    province?: string | undefined;

    constructor(data?: IWardNameListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.district = _data["district"];
            this.province = _data["province"];
        }
    }

    static fromJS(data: any): WardNameListDto {
        data = typeof data === 'object' ? data : {};
        let result = new WardNameListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["district"] = this.district;
        data["province"] = this.province;
        return data;
    }

    clone(): WardNameListDto {
        const json = this.toJSON();
        let result = new WardNameListDto();
        result.init(json);
        return result;
    }
}

export interface IWardNameListDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    district?: string | undefined;
    province?: string | undefined;
}

export class WardNameListDtoPagingResult implements IWardNameListDtoPagingResult {
    items?: WardNameListDto[] | undefined;
    totalCount?: number;

    constructor(data?: IWardNameListDtoPagingResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(WardNameListDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): WardNameListDtoPagingResult {
        data = typeof data === 'object' ? data : {};
        let result = new WardNameListDtoPagingResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): WardNameListDtoPagingResult {
        const json = this.toJSON();
        let result = new WardNameListDtoPagingResult();
        result.init(json);
        return result;
    }
}

export interface IWardNameListDtoPagingResult {
    items?: WardNameListDto[] | undefined;
    totalCount?: number;
}

export class WardNameListDtoPagingResultApiResultObject implements IWardNameListDtoPagingResultApiResultObject {
    result?: WardNameListDtoPagingResult;
    success?: boolean;

    constructor(data?: IWardNameListDtoPagingResultApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? WardNameListDtoPagingResult.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): WardNameListDtoPagingResultApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new WardNameListDtoPagingResultApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data;
    }

    clone(): WardNameListDtoPagingResultApiResultObject {
        const json = this.toJSON();
        let result = new WardNameListDtoPagingResultApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IWardNameListDtoPagingResultApiResultObject {
    result?: WardNameListDtoPagingResult;
    success?: boolean;
}

export class YearData implements IYearData {
    measure?: string | undefined;
    amount?: number;

    constructor(data?: IYearData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.measure = _data["measure"];
            this.amount = _data["amount"];
        }
    }

    static fromJS(data: any): YearData {
        data = typeof data === 'object' ? data : {};
        let result = new YearData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["measure"] = this.measure;
        data["amount"] = this.amount;
        return data;
    }

    clone(): YearData {
        const json = this.toJSON();
        let result = new YearData();
        result.init(json);
        return result;
    }
}

export interface IYearData {
    measure?: string | undefined;
    amount?: number;
}

export class ZoneDto implements IZoneDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    salesOrgId?: number;

    constructor(data?: IZoneDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.salesOrgId = _data["salesOrgId"];
        }
    }

    static fromJS(data: any): ZoneDto {
        data = typeof data === 'object' ? data : {};
        let result = new ZoneDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["salesOrgId"] = this.salesOrgId;
        return data;
    }

    clone(): ZoneDto {
        const json = this.toJSON();
        let result = new ZoneDto();
        result.init(json);
        return result;
    }
}

export interface IZoneDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    salesOrgId?: number;
}

export class ZoneDtoApiResultObject implements IZoneDtoApiResultObject {
    result?: ZoneDto;
    success?: boolean;

    constructor(data?: IZoneDtoApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? ZoneDto.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): ZoneDtoApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new ZoneDtoApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data;
    }

    clone(): ZoneDtoApiResultObject {
        const json = this.toJSON();
        let result = new ZoneDtoApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IZoneDtoApiResultObject {
    result?: ZoneDto;
    success?: boolean;
}

export class ZoneDtoPagingResult implements IZoneDtoPagingResult {
    items?: ZoneDto[] | undefined;
    totalCount?: number;

    constructor(data?: IZoneDtoPagingResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ZoneDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ZoneDtoPagingResult {
        data = typeof data === 'object' ? data : {};
        let result = new ZoneDtoPagingResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ZoneDtoPagingResult {
        const json = this.toJSON();
        let result = new ZoneDtoPagingResult();
        result.init(json);
        return result;
    }
}

export interface IZoneDtoPagingResult {
    items?: ZoneDto[] | undefined;
    totalCount?: number;
}

export class ZoneDtoPagingResultApiResultObject implements IZoneDtoPagingResultApiResultObject {
    result?: ZoneDtoPagingResult;
    success?: boolean;

    constructor(data?: IZoneDtoPagingResultApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? ZoneDtoPagingResult.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): ZoneDtoPagingResultApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new ZoneDtoPagingResultApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data;
    }

    clone(): ZoneDtoPagingResultApiResultObject {
        const json = this.toJSON();
        let result = new ZoneDtoPagingResultApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IZoneDtoPagingResultApiResultObject {
    result?: ZoneDtoPagingResult;
    success?: boolean;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}