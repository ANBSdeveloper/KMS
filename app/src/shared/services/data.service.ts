import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class DataServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAppSetting(id: number): Observable<AppSettingDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/appsettings/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppSetting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppSetting(<any>response_);
                } catch (e) {
                    return <Observable<AppSettingDtoApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<AppSettingDtoApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processGetAppSetting(response: HttpResponseBase): Observable<AppSettingDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppSettingDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppSettingDtoApiResultObject>(<any>null);
    }

    /**
     * @return Success
     */
    deleteAppSetting(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/appsettings/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAppSetting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAppSetting(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteAppSetting(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateAppSetting(id: number, body: UpsertAppSettingCommand | undefined): Observable<AppSettingDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/appsettings/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAppSetting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAppSetting(<any>response_);
                } catch (e) {
                    return <Observable<AppSettingDtoApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<AppSettingDtoApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAppSetting(response: HttpResponseBase): Observable<AppSettingDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppSettingDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppSettingDtoApiResultObject>(<any>null);
    }

    /**
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getAppSettings(maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<AppSettingDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/appsettings?";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppSettings(<any>response_);
                } catch (e) {
                    return <Observable<AppSettingDtoPagingResultApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<AppSettingDtoPagingResultApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processGetAppSettings(response: HttpResponseBase): Observable<AppSettingDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppSettingDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppSettingDtoPagingResultApiResultObject>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createAppSetting(body: UpsertAppSettingCommand | undefined): Observable<AppSettingDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/appsettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateAppSetting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateAppSetting(<any>response_);
                } catch (e) {
                    return <Observable<AppSettingDtoApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<AppSettingDtoApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processCreateAppSetting(response: HttpResponseBase): Observable<AppSettingDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppSettingDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppSettingDtoApiResultObject>(<any>null);
    }

    /**
     * @return Success
     */
    getBranch(id: number): Observable<BranchDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/branches/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBranch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBranch(<any>response_);
                } catch (e) {
                    return <Observable<BranchDtoApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<BranchDtoApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processGetBranch(response: HttpResponseBase): Observable<BranchDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BranchDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BranchDtoApiResultObject>(<any>null);
    }

    /**
     * @param isActive (optional) 
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getBranches(isActive: boolean | undefined, maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<BranchListItemDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/branches?";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBranches(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBranches(<any>response_);
                } catch (e) {
                    return <Observable<BranchListItemDtoPagingResultApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<BranchListItemDtoPagingResultApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processGetBranches(response: HttpResponseBase): Observable<BranchListItemDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BranchListItemDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BranchListItemDtoPagingResultApiResultObject>(<any>null);
    }

    /**
     * @return Success
     */
    getBrand(id: number): Observable<BrandDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/brands/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBrand(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBrand(<any>response_);
                } catch (e) {
                    return <Observable<BrandDtoApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrandDtoApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processGetBrand(response: HttpResponseBase): Observable<BrandDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BrandDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrandDtoApiResultObject>(<any>null);
    }

    /**
     * @return Success
     */
    deleteBrand(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/brands/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteBrand(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteBrand(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteBrand(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateBrand(id: number, body: UpsertBrandCommand | undefined): Observable<BrandDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/brands/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateBrand(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateBrand(<any>response_);
                } catch (e) {
                    return <Observable<BrandDtoApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrandDtoApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateBrand(response: HttpResponseBase): Observable<BrandDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BrandDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrandDtoApiResultObject>(<any>null);
    }

    /**
     * @param isActive (optional) 
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getBrands(isActive: boolean | undefined, maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<BrandDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/brands?";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBrands(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBrands(<any>response_);
                } catch (e) {
                    return <Observable<BrandDtoPagingResultApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrandDtoPagingResultApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processGetBrands(response: HttpResponseBase): Observable<BrandDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BrandDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrandDtoPagingResultApiResultObject>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createBrand(body: UpsertBrandCommand | undefined): Observable<BrandDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/brands";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateBrand(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateBrand(<any>response_);
                } catch (e) {
                    return <Observable<BrandDtoApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrandDtoApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processCreateBrand(response: HttpResponseBase): Observable<BrandDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BrandDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrandDtoApiResultObject>(<any>null);
    }

    /**
     * @return Success
     */
    getBudget(id: number): Observable<BudgetDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/budgets/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBudget(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBudget(<any>response_);
                } catch (e) {
                    return <Observable<BudgetDtoApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<BudgetDtoApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processGetBudget(response: HttpResponseBase): Observable<BudgetDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BudgetDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BudgetDtoApiResultObject>(<any>null);
    }

    /**
     * @return Success
     */
    deleteBudget(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/budgets/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteBudget(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteBudget(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteBudget(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateBudget(id: number, body: BudgetUpsertCommand | undefined): Observable<BudgetDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/budgets/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateBudget(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateBudget(<any>response_);
                } catch (e) {
                    return <Observable<BudgetDtoApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<BudgetDtoApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateBudget(response: HttpResponseBase): Observable<BudgetDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BudgetDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BudgetDtoApiResultObject>(<any>null);
    }

    /**
     * @param investmentType (optional) 
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getBudgets(investmentType: BudgetInvestmentType | undefined, maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<BudgetListItemDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/budgets?";
        if (investmentType === null)
            throw new Error("The parameter 'investmentType' cannot be null.");
        else if (investmentType !== undefined)
            url_ += "InvestmentType=" + encodeURIComponent("" + investmentType) + "&";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBudgets(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBudgets(<any>response_);
                } catch (e) {
                    return <Observable<BudgetListItemDtoPagingResultApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<BudgetListItemDtoPagingResultApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processGetBudgets(response: HttpResponseBase): Observable<BudgetListItemDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BudgetListItemDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BudgetListItemDtoPagingResultApiResultObject>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createBudget(body: BudgetUpsertCommand | undefined): Observable<BudgetDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/budgets";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateBudget(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateBudget(<any>response_);
                } catch (e) {
                    return <Observable<BudgetDtoApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<BudgetDtoApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processCreateBudget(response: HttpResponseBase): Observable<BudgetDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BudgetDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BudgetDtoApiResultObject>(<any>null);
    }

    /**
     * @param investmentType (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getBudgetInitDetail(investmentType: BudgetInvestmentType | undefined, queryId: string | undefined): Observable<BudgetInitDetailDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/budgets/initDetail?";
        if (investmentType === null)
            throw new Error("The parameter 'investmentType' cannot be null.");
        else if (investmentType !== undefined)
            url_ += "InvestmentType=" + encodeURIComponent("" + investmentType) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBudgetInitDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBudgetInitDetail(<any>response_);
                } catch (e) {
                    return <Observable<BudgetInitDetailDtoApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<BudgetInitDetailDtoApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processGetBudgetInitDetail(response: HttpResponseBase): Observable<BudgetInitDetailDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BudgetInitDetailDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BudgetInitDetailDtoApiResultObject>(<any>null);
    }

    /**
     * @param phone (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    findConsumerByPhone(phone: string | undefined, queryId: string | undefined): Observable<ConsumerInfoDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/consumers/find?";
        if (phone === null)
            throw new Error("The parameter 'phone' cannot be null.");
        else if (phone !== undefined)
            url_ += "Phone=" + encodeURIComponent("" + phone) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindConsumerByPhone(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindConsumerByPhone(<any>response_);
                } catch (e) {
                    return <Observable<ConsumerInfoDtoApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<ConsumerInfoDtoApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processFindConsumerByPhone(response: HttpResponseBase): Observable<ConsumerInfoDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConsumerInfoDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ConsumerInfoDtoApiResultObject>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendOtpConsumer(body: ConsumerSendOtpCommand | undefined): Observable<ObjectApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/consumers/send-otp";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendOtpConsumer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendOtpConsumer(<any>response_);
                } catch (e) {
                    return <Observable<ObjectApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<ObjectApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processSendOtpConsumer(response: HttpResponseBase): Observable<ObjectApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectApiResultObject>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    validateOtpConsumer(body: ConsumerValidateOtpCommand | undefined): Observable<ObjectApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/consumers/validate-otp";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidateOtpConsumer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidateOtpConsumer(<any>response_);
                } catch (e) {
                    return <Observable<ObjectApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<ObjectApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processValidateOtpConsumer(response: HttpResponseBase): Observable<ObjectApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectApiResultObject>(<any>null);
    }

    /**
     * @return Success
     */
    getCustomer(id: number): Observable<CustomerDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/customers/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomer(<any>response_);
                } catch (e) {
                    return <Observable<CustomerDtoApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<CustomerDtoApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processGetCustomer(response: HttpResponseBase): Observable<CustomerDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomerDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CustomerDtoApiResultObject>(<any>null);
    }

    /**
     * @return Success
     */
    getCustomerQrData(code: string): Observable<StringApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/customers/{code}/qrdata";
        if (code === undefined || code === null)
            throw new Error("The parameter 'code' must be defined.");
        url_ = url_.replace("{code}", encodeURIComponent("" + code));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomerQrData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomerQrData(<any>response_);
                } catch (e) {
                    return <Observable<StringApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<StringApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processGetCustomerQrData(response: HttpResponseBase): Observable<StringApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringApiResultObject>(<any>null);
    }

    /**
     * @return Success
     */
    getCustomerByCode(code: string): Observable<CustomerDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/customers/codes/{code}";
        if (code === undefined || code === null)
            throw new Error("The parameter 'code' must be defined.");
        url_ = url_.replace("{code}", encodeURIComponent("" + code));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomerByCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomerByCode(<any>response_);
                } catch (e) {
                    return <Observable<CustomerDtoApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<CustomerDtoApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processGetCustomerByCode(response: HttpResponseBase): Observable<CustomerDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomerDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CustomerDtoApiResultObject>(<any>null);
    }

    /**
     * @param isActive (optional) 
     * @param isKeyShop (optional) 
     * @param provinceId (optional) 
     * @param districtId (optional) 
     * @param wardId (optional) 
     * @param staffId (optional) 
     * @param hasTicketInvestment (optional) 
     * @param keyShopStatus (optional) 
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getCustomers(isActive: boolean | undefined, isKeyShop: boolean | undefined, provinceId: number | undefined, districtId: number | undefined, wardId: number | undefined, staffId: number | undefined, hasTicketInvestment: boolean | undefined, keyShopStatus: number[] | undefined, maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<CustomerDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/customers?";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (isKeyShop === null)
            throw new Error("The parameter 'isKeyShop' cannot be null.");
        else if (isKeyShop !== undefined)
            url_ += "IsKeyShop=" + encodeURIComponent("" + isKeyShop) + "&";
        if (provinceId === null)
            throw new Error("The parameter 'provinceId' cannot be null.");
        else if (provinceId !== undefined)
            url_ += "ProvinceId=" + encodeURIComponent("" + provinceId) + "&";
        if (districtId === null)
            throw new Error("The parameter 'districtId' cannot be null.");
        else if (districtId !== undefined)
            url_ += "DistrictId=" + encodeURIComponent("" + districtId) + "&";
        if (wardId === null)
            throw new Error("The parameter 'wardId' cannot be null.");
        else if (wardId !== undefined)
            url_ += "WardId=" + encodeURIComponent("" + wardId) + "&";
        if (staffId === null)
            throw new Error("The parameter 'staffId' cannot be null.");
        else if (staffId !== undefined)
            url_ += "StaffId=" + encodeURIComponent("" + staffId) + "&";
        if (hasTicketInvestment === null)
            throw new Error("The parameter 'hasTicketInvestment' cannot be null.");
        else if (hasTicketInvestment !== undefined)
            url_ += "HasTicketInvestment=" + encodeURIComponent("" + hasTicketInvestment) + "&";
        if (keyShopStatus === null)
            throw new Error("The parameter 'keyShopStatus' cannot be null.");
        else if (keyShopStatus !== undefined)
            keyShopStatus && keyShopStatus.forEach(item => { url_ += "KeyShopStatus=" + encodeURIComponent("" + item) + "&"; });
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomers(<any>response_);
                } catch (e) {
                    return <Observable<CustomerDtoPagingResultApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<CustomerDtoPagingResultApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processGetCustomers(response: HttpResponseBase): Observable<CustomerDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomerDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CustomerDtoPagingResultApiResultObject>(<any>null);
    }

    /**
     * @param isActive (optional) 
     * @param provinceId (optional) 
     * @param districtId (optional) 
     * @param wardId (optional) 
     * @param rsmStaffId (optional) 
     * @param asmStaffId (optional) 
     * @param salesSupervisorStaffId (optional) 
     * @param hasTicketInvestment (optional) 
     * @param keyShopStatus (optional) 
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getCustomersByStaff(isActive: boolean | undefined, provinceId: number | undefined, districtId: number | undefined, wardId: number | undefined, rsmStaffId: number | undefined, asmStaffId: number | undefined, salesSupervisorStaffId: number | undefined, hasTicketInvestment: boolean | undefined, keyShopStatus: number[] | undefined, maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<CustomerByStaffListDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/customers/getCustomersByStaff?";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (provinceId === null)
            throw new Error("The parameter 'provinceId' cannot be null.");
        else if (provinceId !== undefined)
            url_ += "ProvinceId=" + encodeURIComponent("" + provinceId) + "&";
        if (districtId === null)
            throw new Error("The parameter 'districtId' cannot be null.");
        else if (districtId !== undefined)
            url_ += "DistrictId=" + encodeURIComponent("" + districtId) + "&";
        if (wardId === null)
            throw new Error("The parameter 'wardId' cannot be null.");
        else if (wardId !== undefined)
            url_ += "WardId=" + encodeURIComponent("" + wardId) + "&";
        if (rsmStaffId === null)
            throw new Error("The parameter 'rsmStaffId' cannot be null.");
        else if (rsmStaffId !== undefined)
            url_ += "RsmStaffId=" + encodeURIComponent("" + rsmStaffId) + "&";
        if (asmStaffId === null)
            throw new Error("The parameter 'asmStaffId' cannot be null.");
        else if (asmStaffId !== undefined)
            url_ += "AsmStaffId=" + encodeURIComponent("" + asmStaffId) + "&";
        if (salesSupervisorStaffId === null)
            throw new Error("The parameter 'salesSupervisorStaffId' cannot be null.");
        else if (salesSupervisorStaffId !== undefined)
            url_ += "SalesSupervisorStaffId=" + encodeURIComponent("" + salesSupervisorStaffId) + "&";
        if (hasTicketInvestment === null)
            throw new Error("The parameter 'hasTicketInvestment' cannot be null.");
        else if (hasTicketInvestment !== undefined)
            url_ += "HasTicketInvestment=" + encodeURIComponent("" + hasTicketInvestment) + "&";
        if (keyShopStatus === null)
            throw new Error("The parameter 'keyShopStatus' cannot be null.");
        else if (keyShopStatus !== undefined)
            keyShopStatus && keyShopStatus.forEach(item => { url_ += "KeyShopStatus=" + encodeURIComponent("" + item) + "&"; });
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomersByStaff(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomersByStaff(<any>response_);
                } catch (e) {
                    return <Observable<CustomerByStaffListDtoPagingResultApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<CustomerByStaffListDtoPagingResultApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processGetCustomersByStaff(response: HttpResponseBase): Observable<CustomerByStaffListDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomerByStaffListDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CustomerByStaffListDtoPagingResultApiResultObject>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param date (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getRecentSales(id: number | undefined, date: Date | undefined, queryId: string | undefined): Observable<CustomerRecentSalesDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/customers/recentSales?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (date === null)
            throw new Error("The parameter 'date' cannot be null.");
        else if (date !== undefined)
            url_ += "Date=" + encodeURIComponent(date ? "" + date.toJSON() : "") + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecentSales(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecentSales(<any>response_);
                } catch (e) {
                    return <Observable<CustomerRecentSalesDtoApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<CustomerRecentSalesDtoApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processGetRecentSales(response: HttpResponseBase): Observable<CustomerRecentSalesDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomerRecentSalesDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CustomerRecentSalesDtoApiResultObject>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    registerKeyShop(body: CustomerRegisterKeyShopCommand | undefined): Observable<ObjectApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/customers/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterKeyShop(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterKeyShop(<any>response_);
                } catch (e) {
                    return <Observable<ObjectApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<ObjectApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processRegisterKeyShop(response: HttpResponseBase): Observable<ObjectApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectApiResultObject>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    approveKeyShop(body: CustomerApproveKeyShopCommand | undefined): Observable<ObjectApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/customers/approve";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApproveKeyShop(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApproveKeyShop(<any>response_);
                } catch (e) {
                    return <Observable<ObjectApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<ObjectApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processApproveKeyShop(response: HttpResponseBase): Observable<ObjectApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectApiResultObject>(<any>null);
    }

    /**
     * @param zoneId (optional) 
     * @param areaId (optional) 
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getCustomerApproveKeyShopList(zoneId: number | undefined, areaId: number | undefined, maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<CustomerApproveKeyShopListDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/customers/approve?";
        if (zoneId === null)
            throw new Error("The parameter 'zoneId' cannot be null.");
        else if (zoneId !== undefined)
            url_ += "ZoneId=" + encodeURIComponent("" + zoneId) + "&";
        if (areaId === null)
            throw new Error("The parameter 'areaId' cannot be null.");
        else if (areaId !== undefined)
            url_ += "AreaId=" + encodeURIComponent("" + areaId) + "&";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomerApproveKeyShopList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomerApproveKeyShopList(<any>response_);
                } catch (e) {
                    return <Observable<CustomerApproveKeyShopListDtoPagingResultApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<CustomerApproveKeyShopListDtoPagingResultApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processGetCustomerApproveKeyShopList(response: HttpResponseBase): Observable<CustomerApproveKeyShopListDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomerApproveKeyShopListDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CustomerApproveKeyShopListDtoPagingResultApiResultObject>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    refuseKeyShop(body: CustomerRefuseKeyShopCommand | undefined): Observable<ObjectApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/customers/refuse";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRefuseKeyShop(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRefuseKeyShop(<any>response_);
                } catch (e) {
                    return <Observable<ObjectApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<ObjectApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processRefuseKeyShop(response: HttpResponseBase): Observable<ObjectApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectApiResultObject>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    validateActivationKeyShop(body: CustomerValidateActivationKeyShopCommand | undefined): Observable<ObjectApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/customers/validate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidateActivationKeyShop(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidateActivationKeyShop(<any>response_);
                } catch (e) {
                    return <Observable<ObjectApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<ObjectApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processValidateActivationKeyShop(response: HttpResponseBase): Observable<ObjectApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectApiResultObject>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    activateKeyShop(body: CustomerActivateKeyShopCommand | undefined): Observable<ObjectApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/customers/activate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivateKeyShop(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivateKeyShop(<any>response_);
                } catch (e) {
                    return <Observable<ObjectApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<ObjectApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processActivateKeyShop(response: HttpResponseBase): Observable<ObjectApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectApiResultObject>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    validateRecoveryPassword(body: CustomerValidateRecoveryPasswordCommand | undefined): Observable<ObjectApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/customers/recovery-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidateRecoveryPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidateRecoveryPassword(<any>response_);
                } catch (e) {
                    return <Observable<ObjectApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<ObjectApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processValidateRecoveryPassword(response: HttpResponseBase): Observable<ObjectApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectApiResultObject>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resetPasswordCustomer(body: CustomerResetPasswordCommand | undefined): Observable<ObjectApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/customers/reset-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPasswordCustomer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPasswordCustomer(<any>response_);
                } catch (e) {
                    return <Observable<ObjectApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<ObjectApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processResetPasswordCustomer(response: HttpResponseBase): Observable<ObjectApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectApiResultObject>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    checkCustomerOtp(body: CustomerCheckOtpCommand | undefined): Observable<ObjectApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/customers/check-otp";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckCustomerOtp(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckCustomerOtp(<any>response_);
                } catch (e) {
                    return <Observable<ObjectApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<ObjectApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processCheckCustomerOtp(response: HttpResponseBase): Observable<ObjectApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectApiResultObject>(<any>null);
    }

    /**
     * @return Success
     */
    getCycle(id: number): Observable<CycleDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/cycles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCycle(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCycle(<any>response_);
                } catch (e) {
                    return <Observable<CycleDtoApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<CycleDtoApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processGetCycle(response: HttpResponseBase): Observable<CycleDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CycleDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CycleDtoApiResultObject>(<any>null);
    }

    /**
     * @return Success
     */
    deleteCycle(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/cycles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCycle(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCycle(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteCycle(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateCycle(id: number, body: UpsertCycleCommand | undefined): Observable<CycleDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/cycles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCycle(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCycle(<any>response_);
                } catch (e) {
                    return <Observable<CycleDtoApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<CycleDtoApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCycle(response: HttpResponseBase): Observable<CycleDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CycleDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CycleDtoApiResultObject>(<any>null);
    }

    /**
     * @param isActive (optional) 
     * @param useLimitConfig (optional) 
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getCycles(isActive: boolean | undefined, useLimitConfig: boolean | undefined, maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<CycleDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/cycles?";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (useLimitConfig === null)
            throw new Error("The parameter 'useLimitConfig' cannot be null.");
        else if (useLimitConfig !== undefined)
            url_ += "UseLimitConfig=" + encodeURIComponent("" + useLimitConfig) + "&";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCycles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCycles(<any>response_);
                } catch (e) {
                    return <Observable<CycleDtoPagingResultApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<CycleDtoPagingResultApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processGetCycles(response: HttpResponseBase): Observable<CycleDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CycleDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CycleDtoPagingResultApiResultObject>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createCycle(body: UpsertCycleCommand | undefined): Observable<CycleDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/cycles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateCycle(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateCycle(<any>response_);
                } catch (e) {
                    return <Observable<CycleDtoApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<CycleDtoApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processCreateCycle(response: HttpResponseBase): Observable<CycleDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CycleDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CycleDtoApiResultObject>(<any>null);
    }

    /**
     * @return Success
     */
    getProvince(id: number): Observable<ProvinceDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/geography/provinces/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProvince(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProvince(<any>response_);
                } catch (e) {
                    return <Observable<ProvinceDtoApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProvinceDtoApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processGetProvince(response: HttpResponseBase): Observable<ProvinceDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProvinceDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProvinceDtoApiResultObject>(<any>null);
    }

    /**
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getProvinces(maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<ProvinceDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/geography/provinces?";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProvinces(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProvinces(<any>response_);
                } catch (e) {
                    return <Observable<ProvinceDtoPagingResultApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProvinceDtoPagingResultApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processGetProvinces(response: HttpResponseBase): Observable<ProvinceDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProvinceDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProvinceDtoPagingResultApiResultObject>(<any>null);
    }

    /**
     * @return Success
     */
    getDistrict(id: number): Observable<DistrictDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/geography/districts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDistrict(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDistrict(<any>response_);
                } catch (e) {
                    return <Observable<DistrictDtoApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<DistrictDtoApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processGetDistrict(response: HttpResponseBase): Observable<DistrictDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DistrictDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DistrictDtoApiResultObject>(<any>null);
    }

    /**
     * @param provinceId (optional) 
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getDistricts(provinceId: number | undefined, maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<DistrictListDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/geography/districts?";
        if (provinceId === null)
            throw new Error("The parameter 'provinceId' cannot be null.");
        else if (provinceId !== undefined)
            url_ += "ProvinceId=" + encodeURIComponent("" + provinceId) + "&";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDistricts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDistricts(<any>response_);
                } catch (e) {
                    return <Observable<DistrictListDtoPagingResultApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<DistrictListDtoPagingResultApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processGetDistricts(response: HttpResponseBase): Observable<DistrictListDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DistrictListDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DistrictListDtoPagingResultApiResultObject>(<any>null);
    }

    /**
     * @return Success
     */
    getArea(id: number): Observable<AreaDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/geography/areas/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetArea(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetArea(<any>response_);
                } catch (e) {
                    return <Observable<AreaDtoApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<AreaDtoApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processGetArea(response: HttpResponseBase): Observable<AreaDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AreaDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AreaDtoApiResultObject>(<any>null);
    }

    /**
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getAreas(maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<AreaDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/geography/areas?";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAreas(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAreas(<any>response_);
                } catch (e) {
                    return <Observable<AreaDtoPagingResultApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<AreaDtoPagingResultApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processGetAreas(response: HttpResponseBase): Observable<AreaDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AreaDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AreaDtoPagingResultApiResultObject>(<any>null);
    }

    /**
     * @param zoneId (optional) 
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getAreaByZones(zoneId: number | undefined, maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<AreaDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/geography/areabyzones?";
        if (zoneId === null)
            throw new Error("The parameter 'zoneId' cannot be null.");
        else if (zoneId !== undefined)
            url_ += "ZoneId=" + encodeURIComponent("" + zoneId) + "&";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAreaByZones(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAreaByZones(<any>response_);
                } catch (e) {
                    return <Observable<AreaDtoPagingResultApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<AreaDtoPagingResultApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processGetAreaByZones(response: HttpResponseBase): Observable<AreaDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AreaDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AreaDtoPagingResultApiResultObject>(<any>null);
    }

    /**
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getAreaByZoneNames(maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<AreaByZoneNameListDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/geography/areabyzonenames?";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAreaByZoneNames(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAreaByZoneNames(<any>response_);
                } catch (e) {
                    return <Observable<AreaByZoneNameListDtoPagingResultApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<AreaByZoneNameListDtoPagingResultApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processGetAreaByZoneNames(response: HttpResponseBase): Observable<AreaByZoneNameListDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AreaByZoneNameListDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AreaByZoneNameListDtoPagingResultApiResultObject>(<any>null);
    }

    /**
     * @return Success
     */
    getZone(id: number): Observable<ZoneDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/geography/zones/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetZone(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetZone(<any>response_);
                } catch (e) {
                    return <Observable<ZoneDtoApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<ZoneDtoApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processGetZone(response: HttpResponseBase): Observable<ZoneDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ZoneDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ZoneDtoApiResultObject>(<any>null);
    }

    /**
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getZones(maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<ZoneDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/geography/zones?";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetZones(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetZones(<any>response_);
                } catch (e) {
                    return <Observable<ZoneDtoPagingResultApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<ZoneDtoPagingResultApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processGetZones(response: HttpResponseBase): Observable<ZoneDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ZoneDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ZoneDtoPagingResultApiResultObject>(<any>null);
    }

    /**
     * @return Success
     */
    getWard(id: number): Observable<WardDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/geography/wards/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWard(<any>response_);
                } catch (e) {
                    return <Observable<WardDtoApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<WardDtoApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processGetWard(response: HttpResponseBase): Observable<WardDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WardDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WardDtoApiResultObject>(<any>null);
    }

    /**
     * @param districtId (optional) 
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getWards(districtId: number | undefined, maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<WardDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/geography/wards?";
        if (districtId === null)
            throw new Error("The parameter 'districtId' cannot be null.");
        else if (districtId !== undefined)
            url_ += "DistrictId=" + encodeURIComponent("" + districtId) + "&";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWards(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWards(<any>response_);
                } catch (e) {
                    return <Observable<WardDtoPagingResultApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<WardDtoPagingResultApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processGetWards(response: HttpResponseBase): Observable<WardDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WardDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WardDtoPagingResultApiResultObject>(<any>null);
    }

    /**
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getWardNames(maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<WardNameListDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/geography/wardnames?";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWardNames(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWardNames(<any>response_);
                } catch (e) {
                    return <Observable<WardNameListDtoPagingResultApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<WardNameListDtoPagingResultApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processGetWardNames(response: HttpResponseBase): Observable<WardNameListDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WardNameListDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WardNameListDtoPagingResultApiResultObject>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateSpoonCode(body: OrderUpdateSpoonCodeCommand | undefined): Observable<OrderDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/integration/update-spoon-code";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSpoonCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSpoonCode(<any>response_);
                } catch (e) {
                    return <Observable<OrderDtoApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrderDtoApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateSpoonCode(response: HttpResponseBase): Observable<OrderDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrderDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrderDtoApiResultObject>(<any>null);
    }

    /**
     * @param phone (optional) 
     * @return Success
     */
    tickets(phone: string | undefined): Observable<TicketGetByConsumerDtoListApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/integration/tickets?";
        if (phone === null)
            throw new Error("The parameter 'phone' cannot be null.");
        else if (phone !== undefined)
            url_ += "phone=" + encodeURIComponent("" + phone) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTickets(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTickets(<any>response_);
                } catch (e) {
                    return <Observable<TicketGetByConsumerDtoListApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<TicketGetByConsumerDtoListApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processTickets(response: HttpResponseBase): Observable<TicketGetByConsumerDtoListApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TicketGetByConsumerDtoListApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TicketGetByConsumerDtoListApiResultObject>(<any>null);
    }

    /**
     * @return Success
     */
    getInvestment(): Observable<InvestmentDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/investments";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvestment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvestment(<any>response_);
                } catch (e) {
                    return <Observable<InvestmentDtoApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<InvestmentDtoApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processGetInvestment(response: HttpResponseBase): Observable<InvestmentDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvestmentDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvestmentDtoApiResultObject>(<any>null);
    }

    /**
     * @return Success
     */
    getInvestmentSetting(): Observable<InvestmentSettingDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/investmentSetting";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvestmentSetting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvestmentSetting(<any>response_);
                } catch (e) {
                    return <Observable<InvestmentSettingDtoApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<InvestmentSettingDtoApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processGetInvestmentSetting(response: HttpResponseBase): Observable<InvestmentSettingDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvestmentSettingDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvestmentSettingDtoApiResultObject>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createInvestmentSetting(body: UpsertInvestmentSettingCommand | undefined): Observable<InvestmentSettingDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/investmentSetting";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateInvestmentSetting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateInvestmentSetting(<any>response_);
                } catch (e) {
                    return <Observable<InvestmentSettingDtoApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<InvestmentSettingDtoApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processCreateInvestmentSetting(response: HttpResponseBase): Observable<InvestmentSettingDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvestmentSettingDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvestmentSettingDtoApiResultObject>(<any>null);
    }

    /**
     * @param customerId (optional) 
     * @return Success
     */
    getInvestmentCustomerSetting(customerId: number | undefined): Observable<InvestmentCustomerSettingDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/investmentSetting/customer?";
        if (customerId === null)
            throw new Error("The parameter 'customerId' cannot be null.");
        else if (customerId !== undefined)
            url_ += "CustomerId=" + encodeURIComponent("" + customerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvestmentCustomerSetting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvestmentCustomerSetting(<any>response_);
                } catch (e) {
                    return <Observable<InvestmentCustomerSettingDtoApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<InvestmentCustomerSettingDtoApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processGetInvestmentCustomerSetting(response: HttpResponseBase): Observable<InvestmentCustomerSettingDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvestmentCustomerSettingDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvestmentCustomerSettingDtoApiResultObject>(<any>null);
    }

    /**
     * @param customerCode (optional) 
     * @return Success
     */
    getInvestmentCustomerSettingByCode(customerCode: string | undefined): Observable<InvestmentCustomerSettingDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/investmentSetting/customer/bycode?";
        if (customerCode === null)
            throw new Error("The parameter 'customerCode' cannot be null.");
        else if (customerCode !== undefined)
            url_ += "CustomerCode=" + encodeURIComponent("" + customerCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvestmentCustomerSettingByCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvestmentCustomerSettingByCode(<any>response_);
                } catch (e) {
                    return <Observable<InvestmentCustomerSettingDtoApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<InvestmentCustomerSettingDtoApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processGetInvestmentCustomerSettingByCode(response: HttpResponseBase): Observable<InvestmentCustomerSettingDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvestmentCustomerSettingDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvestmentCustomerSettingDtoApiResultObject>(<any>null);
    }

    /**
     * @return Success
     */
    deleteInvestmentSetting(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/investmentSetting/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteInvestmentSetting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteInvestmentSetting(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteInvestmentSetting(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateInvestmentSetting(id: number, body: UpsertInvestmentSettingCommand | undefined): Observable<InvestmentSettingDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/investmentSetting/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateInvestmentSetting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateInvestmentSetting(<any>response_);
                } catch (e) {
                    return <Observable<InvestmentSettingDtoApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<InvestmentSettingDtoApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateInvestmentSetting(response: HttpResponseBase): Observable<InvestmentSettingDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvestmentSettingDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvestmentSettingDtoApiResultObject>(<any>null);
    }

    /**
     * @return Success
     */
    getMaterial(id: number): Observable<MaterialDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/materials/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMaterial(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaterial(<any>response_);
                } catch (e) {
                    return <Observable<MaterialDtoApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<MaterialDtoApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processGetMaterial(response: HttpResponseBase): Observable<MaterialDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MaterialDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MaterialDtoApiResultObject>(<any>null);
    }

    /**
     * @return Success
     */
    deleteMaterial(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/materials/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteMaterial(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMaterial(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteMaterial(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateMaterial(id: number, body: MaterialUpsertCommand | undefined): Observable<MaterialDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/materials/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateMaterial(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMaterial(<any>response_);
                } catch (e) {
                    return <Observable<MaterialDtoApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<MaterialDtoApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateMaterial(response: HttpResponseBase): Observable<MaterialDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MaterialDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MaterialDtoApiResultObject>(<any>null);
    }

    /**
     * @param isActive (optional) 
     * @param materialTypeId (optional) 
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getMaterials(isActive: boolean | undefined, materialTypeId: number | undefined, maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<MaterialListItemDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/materials?";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (materialTypeId === null)
            throw new Error("The parameter 'materialTypeId' cannot be null.");
        else if (materialTypeId !== undefined)
            url_ += "MaterialTypeId=" + encodeURIComponent("" + materialTypeId) + "&";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMaterials(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaterials(<any>response_);
                } catch (e) {
                    return <Observable<MaterialListItemDtoPagingResultApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<MaterialListItemDtoPagingResultApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processGetMaterials(response: HttpResponseBase): Observable<MaterialListItemDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MaterialListItemDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MaterialListItemDtoPagingResultApiResultObject>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createMaterial(body: MaterialUpsertCommand | undefined): Observable<MaterialDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/materials";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateMaterial(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateMaterial(<any>response_);
                } catch (e) {
                    return <Observable<MaterialDtoApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<MaterialDtoApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processCreateMaterial(response: HttpResponseBase): Observable<MaterialDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MaterialDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MaterialDtoApiResultObject>(<any>null);
    }

    /**
     * @return Success
     */
    exportMaterial(): Observable<Stream> {
        let url_ = this.baseUrl + "/api/v1/materials/export";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportMaterial(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportMaterial(<any>response_);
                } catch (e) {
                    return <Observable<Stream>><any>_observableThrow(e);
                }
            } else
                return <Observable<Stream>><any>_observableThrow(response_);
        }));
    }

    protected processExportMaterial(response: HttpResponseBase): Observable<Stream> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Stream.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Stream>(<any>null);
    }

    /**
     * @param contentType (optional) 
     * @param contentDisposition (optional) 
     * @param headers (optional) 
     * @param length (optional) 
     * @param name (optional) 
     * @param fileName (optional) 
     * @return Success
     */
    importMaterial(contentType: string | undefined, contentDisposition: string | undefined, headers: { [key: string]: string[]; } | undefined, length: number | undefined, name: string | undefined, fileName: string | undefined): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/materials/import";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (contentType === null || contentType === undefined)
            throw new Error("The parameter 'contentType' cannot be null.");
        else
            content_.append("ContentType", contentType.toString());
        if (contentDisposition === null || contentDisposition === undefined)
            throw new Error("The parameter 'contentDisposition' cannot be null.");
        else
            content_.append("ContentDisposition", contentDisposition.toString());
        if (headers === null || headers === undefined)
            throw new Error("The parameter 'headers' cannot be null.");
        else
            content_.append("Headers", JSON.stringify(headers));
        if (length === null || length === undefined)
            throw new Error("The parameter 'length' cannot be null.");
        else
            content_.append("Length", length.toString());
        if (name === null || name === undefined)
            throw new Error("The parameter 'name' cannot be null.");
        else
            content_.append("Name", name.toString());
        if (fileName === null || fileName === undefined)
            throw new Error("The parameter 'fileName' cannot be null.");
        else
            content_.append("FileName", fileName.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportMaterial(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportMaterial(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processImportMaterial(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * @return Success
     */
    getMaterialType(id: number): Observable<MaterialTypeDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/material-types/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMaterialType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaterialType(<any>response_);
                } catch (e) {
                    return <Observable<MaterialTypeDtoApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<MaterialTypeDtoApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processGetMaterialType(response: HttpResponseBase): Observable<MaterialTypeDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MaterialTypeDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MaterialTypeDtoApiResultObject>(<any>null);
    }

    /**
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getMaterialTypes(maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<MaterialTypeDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/material-types?";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMaterialTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaterialTypes(<any>response_);
                } catch (e) {
                    return <Observable<MaterialTypeDtoPagingResultApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<MaterialTypeDtoPagingResultApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processGetMaterialTypes(response: HttpResponseBase): Observable<MaterialTypeDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MaterialTypeDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MaterialTypeDtoPagingResultApiResultObject>(<any>null);
    }

    /**
     * @return Success
     */
    getNotification(id: number): Observable<NotificationDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/notifications/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNotification(<any>response_);
                } catch (e) {
                    return <Observable<NotificationDtoApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<NotificationDtoApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processGetNotification(response: HttpResponseBase): Observable<NotificationDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NotificationDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NotificationDtoApiResultObject>(<any>null);
    }

    /**
     * @return Success
     */
    deleteNotification(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/notifications/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteNotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteNotification(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteNotification(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateNotification(id: number, body: NotificationUpsertCommand | undefined): Observable<NotificationDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/notifications/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateNotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateNotification(<any>response_);
                } catch (e) {
                    return <Observable<NotificationDtoApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<NotificationDtoApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateNotification(response: HttpResponseBase): Observable<NotificationDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NotificationDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NotificationDtoApiResultObject>(<any>null);
    }

    /**
     * @param status (optional) 
     * @param objectType (optional) 
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getNotifications(status: number | undefined, objectType: number | undefined, maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<NotificationListDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/notifications?";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        if (objectType === null)
            throw new Error("The parameter 'objectType' cannot be null.");
        else if (objectType !== undefined)
            url_ += "ObjectType=" + encodeURIComponent("" + objectType) + "&";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNotifications(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNotifications(<any>response_);
                } catch (e) {
                    return <Observable<NotificationListDtoPagingResultApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<NotificationListDtoPagingResultApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processGetNotifications(response: HttpResponseBase): Observable<NotificationListDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NotificationListDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NotificationListDtoPagingResultApiResultObject>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createNotification(body: NotificationUpsertCommand | undefined): Observable<NotificationDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/notifications";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateNotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateNotification(<any>response_);
                } catch (e) {
                    return <Observable<NotificationDtoApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<NotificationDtoApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processCreateNotification(response: HttpResponseBase): Observable<NotificationDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NotificationDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NotificationDtoApiResultObject>(<any>null);
    }

    /**
     * @return Success
     */
    sendNotification(id: number): Observable<NotificationDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/notifications/{id}/send";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendNotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendNotification(<any>response_);
                } catch (e) {
                    return <Observable<NotificationDtoApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<NotificationDtoApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processSendNotification(response: HttpResponseBase): Observable<NotificationDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NotificationDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NotificationDtoApiResultObject>(<any>null);
    }

    /**
     * @return Success
     */
    viewNotification(id: number): Observable<ObjectApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/notifications/{id}/view";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processViewNotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processViewNotification(<any>response_);
                } catch (e) {
                    return <Observable<ObjectApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<ObjectApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processViewNotification(response: HttpResponseBase): Observable<ObjectApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectApiResultObject>(<any>null);
    }

    /**
     * @param unread (optional) 
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getNotificationUsers(unread: boolean | undefined, maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<NotificationListDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/notifications/byuser?";
        if (unread === null)
            throw new Error("The parameter 'unread' cannot be null.");
        else if (unread !== undefined)
            url_ += "Unread=" + encodeURIComponent("" + unread) + "&";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNotificationUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNotificationUsers(<any>response_);
                } catch (e) {
                    return <Observable<NotificationListDtoPagingResultApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<NotificationListDtoPagingResultApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processGetNotificationUsers(response: HttpResponseBase): Observable<NotificationListDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NotificationListDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NotificationListDtoPagingResultApiResultObject>(<any>null);
    }

    /**
     * @return Success
     */
    getNotificationUnreadCount(): Observable<Int32ApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/notifications/unread-count";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNotificationUnreadCount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNotificationUnreadCount(<any>response_);
                } catch (e) {
                    return <Observable<Int32ApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<Int32ApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processGetNotificationUnreadCount(response: HttpResponseBase): Observable<Int32ApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Int32ApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Int32ApiResultObject>(<any>null);
    }

    /**
     * @return Success
     */
    getOrder(id: number): Observable<OrderDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/orders/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrder(<any>response_);
                } catch (e) {
                    return <Observable<OrderDtoApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrderDtoApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrder(response: HttpResponseBase): Observable<OrderDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrderDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrderDtoApiResultObject>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrder(body: OrderCreateCommand | undefined): Observable<OrderDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/orders";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrder(<any>response_);
                } catch (e) {
                    return <Observable<OrderDtoApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrderDtoApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrder(response: HttpResponseBase): Observable<OrderDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrderDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrderDtoApiResultObject>(<any>null);
    }

    /**
     * @param customerId (optional) 
     * @param rsmStaffId (optional) 
     * @param asmStaffId (optional) 
     * @param salesSupervisorStaffId (optional) 
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getOrders(customerId: number | undefined, rsmStaffId: number | undefined, asmStaffId: number | undefined, salesSupervisorStaffId: number | undefined, fromDate: Date | undefined, toDate: Date | undefined, maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<OrderListItemDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/orders?";
        if (customerId === null)
            throw new Error("The parameter 'customerId' cannot be null.");
        else if (customerId !== undefined)
            url_ += "CustomerId=" + encodeURIComponent("" + customerId) + "&";
        if (rsmStaffId === null)
            throw new Error("The parameter 'rsmStaffId' cannot be null.");
        else if (rsmStaffId !== undefined)
            url_ += "RsmStaffId=" + encodeURIComponent("" + rsmStaffId) + "&";
        if (asmStaffId === null)
            throw new Error("The parameter 'asmStaffId' cannot be null.");
        else if (asmStaffId !== undefined)
            url_ += "AsmStaffId=" + encodeURIComponent("" + asmStaffId) + "&";
        if (salesSupervisorStaffId === null)
            throw new Error("The parameter 'salesSupervisorStaffId' cannot be null.");
        else if (salesSupervisorStaffId !== undefined)
            url_ += "SalesSupervisorStaffId=" + encodeURIComponent("" + salesSupervisorStaffId) + "&";
        if (fromDate === null)
            throw new Error("The parameter 'fromDate' cannot be null.");
        else if (fromDate !== undefined)
            url_ += "FromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toJSON() : "") + "&";
        if (toDate === null)
            throw new Error("The parameter 'toDate' cannot be null.");
        else if (toDate !== undefined)
            url_ += "ToDate=" + encodeURIComponent(toDate ? "" + toDate.toJSON() : "") + "&";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrders(<any>response_);
                } catch (e) {
                    return <Observable<OrderListItemDtoPagingResultApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrderListItemDtoPagingResultApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrders(response: HttpResponseBase): Observable<OrderListItemDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrderListItemDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrderListItemDtoPagingResultApiResultObject>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addSalesItem(body: CustomerSalesItemCreateCommand | undefined): Observable<ObjectApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/orders/add-sales-item";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddSalesItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddSalesItem(<any>response_);
                } catch (e) {
                    return <Observable<ObjectApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<ObjectApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processAddSalesItem(response: HttpResponseBase): Observable<ObjectApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectApiResultObject>(<any>null);
    }

    /**
     * @param ticketInvestmentId (optional) 
     * @return Success
     */
    getOrdersForShop(ticketInvestmentId: number | undefined): Observable<OrderListItemDtoListApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/orders/get-for-shop?";
        if (ticketInvestmentId === null)
            throw new Error("The parameter 'ticketInvestmentId' cannot be null.");
        else if (ticketInvestmentId !== undefined)
            url_ += "TicketInvestmentId=" + encodeURIComponent("" + ticketInvestmentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrdersForShop(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrdersForShop(<any>response_);
                } catch (e) {
                    return <Observable<OrderListItemDtoListApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrderListItemDtoListApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrdersForShop(response: HttpResponseBase): Observable<OrderListItemDtoListApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrderListItemDtoListApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrderListItemDtoListApiResultObject>(<any>null);
    }

    /**
     * @param orderId (optional) 
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getOrderDetails(orderId: number | undefined, maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<OrderDetailDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/orders/getOrderDetails?";
        if (orderId === null)
            throw new Error("The parameter 'orderId' cannot be null.");
        else if (orderId !== undefined)
            url_ += "OrderId=" + encodeURIComponent("" + orderId) + "&";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrderDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrderDetails(<any>response_);
                } catch (e) {
                    return <Observable<OrderDetailDtoPagingResultApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrderDetailDtoPagingResultApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrderDetails(response: HttpResponseBase): Observable<OrderDetailDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrderDetailDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrderDetailDtoPagingResultApiResultObject>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    validateSpoonCode(body: OrderValidateSpoonCodeCommand | undefined): Observable<ObjectApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/orders/validate-spoon-code";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidateSpoonCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidateSpoonCode(<any>response_);
                } catch (e) {
                    return <Observable<ObjectApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<ObjectApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processValidateSpoonCode(response: HttpResponseBase): Observable<ObjectApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectApiResultObject>(<any>null);
    }

    /**
     * @return Success
     */
    getProduct(id: number): Observable<ProductBaseDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/products/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProduct(<any>response_);
                } catch (e) {
                    return <Observable<ProductBaseDtoApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductBaseDtoApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processGetProduct(response: HttpResponseBase): Observable<ProductBaseDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductBaseDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductBaseDtoApiResultObject>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateProduct(id: number, body: UpsertProductCommand | undefined): Observable<ProductBaseDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/products/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateProduct(<any>response_);
                } catch (e) {
                    return <Observable<ProductBaseDtoApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductBaseDtoApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateProduct(response: HttpResponseBase): Observable<ProductBaseDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductBaseDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductBaseDtoApiResultObject>(<any>null);
    }

    /**
     * @return Success
     */
    getProductItem(id: number): Observable<ProductItemDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/products/item/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductItem(<any>response_);
                } catch (e) {
                    return <Observable<ProductItemDtoApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductItemDtoApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processGetProductItem(response: HttpResponseBase): Observable<ProductItemDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductItemDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductItemDtoApiResultObject>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateProductItem(id: number, body: UpsertProductItemCommand | undefined): Observable<ProductItemDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/products/item/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateProductItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateProductItem(<any>response_);
                } catch (e) {
                    return <Observable<ProductItemDtoApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductItemDtoApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateProductItem(response: HttpResponseBase): Observable<ProductItemDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductItemDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductItemDtoApiResultObject>(<any>null);
    }

    /**
     * @param isActive (optional) 
     * @param productClassCode (optional) 
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getProducts(isActive: boolean | undefined, productClassCode: string | undefined, maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<ProductListItemDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/products?";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (productClassCode === null)
            throw new Error("The parameter 'productClassCode' cannot be null.");
        else if (productClassCode !== undefined)
            url_ += "ProductClassCode=" + encodeURIComponent("" + productClassCode) + "&";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProducts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProducts(<any>response_);
                } catch (e) {
                    return <Observable<ProductListItemDtoPagingResultApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductListItemDtoPagingResultApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processGetProducts(response: HttpResponseBase): Observable<ProductListItemDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductListItemDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductListItemDtoPagingResultApiResultObject>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createProduct(body: UpsertProductCommand | undefined): Observable<ProductBaseDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/products";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateProduct(<any>response_);
                } catch (e) {
                    return <Observable<ProductBaseDtoApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductBaseDtoApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processCreateProduct(response: HttpResponseBase): Observable<ProductBaseDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductBaseDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductBaseDtoApiResultObject>(<any>null);
    }

    /**
     * @param isActive (optional) 
     * @param classId (optional) 
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getProductItemClasses(isActive: boolean | undefined, classId: number | undefined, maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<ProductListItemDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/products/itembyclass?";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (classId === null)
            throw new Error("The parameter 'classId' cannot be null.");
        else if (classId !== undefined)
            url_ += "ClassId=" + encodeURIComponent("" + classId) + "&";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductItemClasses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductItemClasses(<any>response_);
                } catch (e) {
                    return <Observable<ProductListItemDtoPagingResultApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductListItemDtoPagingResultApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processGetProductItemClasses(response: HttpResponseBase): Observable<ProductListItemDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductListItemDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductListItemDtoPagingResultApiResultObject>(<any>null);
    }

    /**
     * @param qrCode (optional) 
     * @param smallUnitRequire (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    findProductByQrCode(qrCode: string | undefined, smallUnitRequire: boolean | undefined, queryId: string | undefined): Observable<ProductInfoDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/products/find?";
        if (qrCode === null)
            throw new Error("The parameter 'qrCode' cannot be null.");
        else if (qrCode !== undefined)
            url_ += "QrCode=" + encodeURIComponent("" + qrCode) + "&";
        if (smallUnitRequire === null)
            throw new Error("The parameter 'smallUnitRequire' cannot be null.");
        else if (smallUnitRequire !== undefined)
            url_ += "SmallUnitRequire=" + encodeURIComponent("" + smallUnitRequire) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindProductByQrCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindProductByQrCode(<any>response_);
                } catch (e) {
                    return <Observable<ProductInfoDtoApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductInfoDtoApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processFindProductByQrCode(response: HttpResponseBase): Observable<ProductInfoDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductInfoDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductInfoDtoApiResultObject>(<any>null);
    }

    /**
     * @return Success
     */
    getProductClass(id: number): Observable<ProductClassDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/product-classes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductClass(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductClass(<any>response_);
                } catch (e) {
                    return <Observable<ProductClassDtoApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductClassDtoApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processGetProductClass(response: HttpResponseBase): Observable<ProductClassDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductClassDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductClassDtoApiResultObject>(<any>null);
    }

    /**
     * @return Success
     */
    deleteProductClass(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/product-classes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteProductClass(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteProductClass(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteProductClass(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateProductClass(id: number, body: UpsertProductClassCommand | undefined): Observable<ProductClassDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/product-classes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateProductClass(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateProductClass(<any>response_);
                } catch (e) {
                    return <Observable<ProductClassDtoApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductClassDtoApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateProductClass(response: HttpResponseBase): Observable<ProductClassDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductClassDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductClassDtoApiResultObject>(<any>null);
    }

    /**
     * @param isActive (optional) 
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getProductClasses(isActive: boolean | undefined, maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<ProductClassDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/product-classes?";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductClasses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductClasses(<any>response_);
                } catch (e) {
                    return <Observable<ProductClassDtoPagingResultApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductClassDtoPagingResultApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processGetProductClasses(response: HttpResponseBase): Observable<ProductClassDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductClassDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductClassDtoPagingResultApiResultObject>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createProductClass(body: UpsertProductClassCommand | undefined): Observable<ProductClassDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/product-classes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateProductClass(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateProductClass(<any>response_);
                } catch (e) {
                    return <Observable<ProductClassDtoApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductClassDtoApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processCreateProductClass(response: HttpResponseBase): Observable<ProductClassDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductClassDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductClassDtoApiResultObject>(<any>null);
    }

    /**
     * @return Success
     */
    getProductPoint(id: number): Observable<ProductPointDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/product-points/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductPoint(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductPoint(<any>response_);
                } catch (e) {
                    return <Observable<ProductPointDtoApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductPointDtoApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processGetProductPoint(response: HttpResponseBase): Observable<ProductPointDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductPointDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductPointDtoApiResultObject>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateProductPoint(id: number, body: ProductPointUpsertCommand | undefined): Observable<ProductPointDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/product-points/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateProductPoint(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateProductPoint(<any>response_);
                } catch (e) {
                    return <Observable<ProductPointDtoApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductPointDtoApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateProductPoint(response: HttpResponseBase): Observable<ProductPointDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductPointDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductPointDtoApiResultObject>(<any>null);
    }

    /**
     * @return Success
     */
    deleteProductPoint(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/product-points/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteProductPoint(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteProductPoint(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteProductPoint(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param productClassId (optional) 
     * @param isActive (optional) 
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getProductPoints(productClassId: number | undefined, isActive: boolean | undefined, maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<ProductPointListItemDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/product-points?";
        if (productClassId === null)
            throw new Error("The parameter 'productClassId' cannot be null.");
        else if (productClassId !== undefined)
            url_ += "ProductClassId=" + encodeURIComponent("" + productClassId) + "&";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductPoints(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductPoints(<any>response_);
                } catch (e) {
                    return <Observable<ProductPointListItemDtoPagingResultApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductPointListItemDtoPagingResultApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processGetProductPoints(response: HttpResponseBase): Observable<ProductPointListItemDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductPointListItemDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductPointListItemDtoPagingResultApiResultObject>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createProductPoint(body: ProductPointUpsertCommand | undefined): Observable<ProductPointDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/product-points";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateProductPoint(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateProductPoint(<any>response_);
                } catch (e) {
                    return <Observable<ProductPointDtoApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductPointDtoApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processCreateProductPoint(response: HttpResponseBase): Observable<ProductPointDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductPointDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductPointDtoApiResultObject>(<any>null);
    }

    /**
     * @return Success
     */
    exportProductPoint(): Observable<Stream> {
        let url_ = this.baseUrl + "/api/v1/product-points/export";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportProductPoint(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportProductPoint(<any>response_);
                } catch (e) {
                    return <Observable<Stream>><any>_observableThrow(e);
                }
            } else
                return <Observable<Stream>><any>_observableThrow(response_);
        }));
    }

    protected processExportProductPoint(response: HttpResponseBase): Observable<Stream> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Stream.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Stream>(<any>null);
    }

    /**
     * @param contentType (optional) 
     * @param contentDisposition (optional) 
     * @param headers (optional) 
     * @param length (optional) 
     * @param name (optional) 
     * @param fileName (optional) 
     * @return Success
     */
    importProductPoint(contentType: string | undefined, contentDisposition: string | undefined, headers: { [key: string]: string[]; } | undefined, length: number | undefined, name: string | undefined, fileName: string | undefined): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/product-points/import";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (contentType === null || contentType === undefined)
            throw new Error("The parameter 'contentType' cannot be null.");
        else
            content_.append("ContentType", contentType.toString());
        if (contentDisposition === null || contentDisposition === undefined)
            throw new Error("The parameter 'contentDisposition' cannot be null.");
        else
            content_.append("ContentDisposition", contentDisposition.toString());
        if (headers === null || headers === undefined)
            throw new Error("The parameter 'headers' cannot be null.");
        else
            content_.append("Headers", JSON.stringify(headers));
        if (length === null || length === undefined)
            throw new Error("The parameter 'length' cannot be null.");
        else
            content_.append("Length", length.toString());
        if (name === null || name === undefined)
            throw new Error("The parameter 'name' cannot be null.");
        else
            content_.append("Name", name.toString());
        if (fileName === null || fileName === undefined)
            throw new Error("The parameter 'fileName' cannot be null.");
        else
            content_.append("FileName", fileName.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportProductPoint(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportProductPoint(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processImportProductPoint(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * @return Success
     */
    getProductUnit(id: number): Observable<ProductUnitDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/productUnits/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductUnit(<any>response_);
                } catch (e) {
                    return <Observable<ProductUnitDtoApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductUnitDtoApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processGetProductUnit(response: HttpResponseBase): Observable<ProductUnitDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductUnitDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductUnitDtoApiResultObject>(<any>null);
    }

    /**
     * @return Success
     */
    deleteProductUnit(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/productUnits/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteProductUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteProductUnit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteProductUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateProductUnit(id: number, body: UpsertProductUnitCommand | undefined): Observable<ProductUnitDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/productUnits/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateProductUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateProductUnit(<any>response_);
                } catch (e) {
                    return <Observable<ProductUnitDtoApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductUnitDtoApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateProductUnit(response: HttpResponseBase): Observable<ProductUnitDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductUnitDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductUnitDtoApiResultObject>(<any>null);
    }

    /**
     * @param productId (optional) 
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getProductUnits(productId: number | undefined, maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<ProductUnitDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/productUnits?";
        if (productId === null)
            throw new Error("The parameter 'productId' cannot be null.");
        else if (productId !== undefined)
            url_ += "ProductId=" + encodeURIComponent("" + productId) + "&";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductUnits(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductUnits(<any>response_);
                } catch (e) {
                    return <Observable<ProductUnitDtoPagingResultApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductUnitDtoPagingResultApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processGetProductUnits(response: HttpResponseBase): Observable<ProductUnitDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductUnitDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductUnitDtoPagingResultApiResultObject>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createProductUnit(body: UpsertProductUnitCommand | undefined): Observable<ProductUnitDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/productUnits";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateProductUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateProductUnit(<any>response_);
                } catch (e) {
                    return <Observable<ProductUnitDtoApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductUnitDtoApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processCreateProductUnit(response: HttpResponseBase): Observable<ProductUnitDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductUnitDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductUnitDtoApiResultObject>(<any>null);
    }

    /**
     * @param params (optional) 
     * @return Success
     */
    report(params: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/Report?";
        if (params === null)
            throw new Error("The parameter 'params' cannot be null.");
        else if (params !== undefined)
            url_ += "params=" + encodeURIComponent("" + params) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReport(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processReport(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getRewardPackage(id: number): Observable<RewardPackageDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/rewardPackages/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRewardPackage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRewardPackage(<any>response_);
                } catch (e) {
                    return <Observable<RewardPackageDtoApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<RewardPackageDtoApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processGetRewardPackage(response: HttpResponseBase): Observable<RewardPackageDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RewardPackageDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RewardPackageDtoApiResultObject>(<any>null);
    }

    /**
     * @return Success
     */
    deleteRewardPackage(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/rewardPackages/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRewardPackage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRewardPackage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteRewardPackage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateRewardPackage(id: number, body: RewardPackageUpsertCommand | undefined): Observable<RewardPackageDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/rewardPackages/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateRewardPackage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateRewardPackage(<any>response_);
                } catch (e) {
                    return <Observable<RewardPackageDtoApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<RewardPackageDtoApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateRewardPackage(response: HttpResponseBase): Observable<RewardPackageDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RewardPackageDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RewardPackageDtoApiResultObject>(<any>null);
    }

    /**
     * @param isActive (optional) 
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getRewardPackages(isActive: boolean | undefined, maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<RewardPackageListDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/rewardPackages?";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRewardPackages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRewardPackages(<any>response_);
                } catch (e) {
                    return <Observable<RewardPackageListDtoPagingResultApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<RewardPackageListDtoPagingResultApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processGetRewardPackages(response: HttpResponseBase): Observable<RewardPackageListDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RewardPackageListDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RewardPackageListDtoPagingResultApiResultObject>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createRewardPackage(body: RewardPackageUpsertCommand | undefined): Observable<RewardPackageDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/rewardPackages";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateRewardPackage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateRewardPackage(<any>response_);
                } catch (e) {
                    return <Observable<RewardPackageDtoApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<RewardPackageDtoApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processCreateRewardPackage(response: HttpResponseBase): Observable<RewardPackageDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RewardPackageDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RewardPackageDtoApiResultObject>(<any>null);
    }

    /**
     * @param type (optional) 
     * @param customerId (optional) 
     * @param isActive (optional) 
     * @param validDate (optional) 
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getRewardPackageListByTypeCustomerId(type: number | undefined, customerId: number | undefined, isActive: boolean | undefined, validDate: Date | undefined, maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<RewardPackageListDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/rewardPackages/getRewardPackageListByTypeCustomer?";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&";
        if (customerId === null)
            throw new Error("The parameter 'customerId' cannot be null.");
        else if (customerId !== undefined)
            url_ += "CustomerId=" + encodeURIComponent("" + customerId) + "&";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (validDate === null)
            throw new Error("The parameter 'validDate' cannot be null.");
        else if (validDate !== undefined)
            url_ += "ValidDate=" + encodeURIComponent(validDate ? "" + validDate.toJSON() : "") + "&";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRewardPackageListByTypeCustomerId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRewardPackageListByTypeCustomerId(<any>response_);
                } catch (e) {
                    return <Observable<RewardPackageListDtoPagingResultApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<RewardPackageListDtoPagingResultApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processGetRewardPackageListByTypeCustomerId(response: HttpResponseBase): Observable<RewardPackageListDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RewardPackageListDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RewardPackageListDtoPagingResultApiResultObject>(<any>null);
    }

    /**
     * @return Success
     */
    getStaffInfo(): Observable<StaffDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/staffs/info";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStaffInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStaffInfo(<any>response_);
                } catch (e) {
                    return <Observable<StaffDtoApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<StaffDtoApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processGetStaffInfo(response: HttpResponseBase): Observable<StaffDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StaffDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StaffDtoApiResultObject>(<any>null);
    }

    /**
     * @return Success
     */
    getStaff(id: number): Observable<StaffDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/staffs/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStaff(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStaff(<any>response_);
                } catch (e) {
                    return <Observable<StaffDtoApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<StaffDtoApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processGetStaff(response: HttpResponseBase): Observable<StaffDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StaffDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StaffDtoApiResultObject>(<any>null);
    }

    /**
     * @param supervisorId (optional) 
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getSalesSuppervisorStaffs(supervisorId: number | undefined, maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<StaffListDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/staffs/sales-supervisor?";
        if (supervisorId === null)
            throw new Error("The parameter 'supervisorId' cannot be null.");
        else if (supervisorId !== undefined)
            url_ += "SupervisorId=" + encodeURIComponent("" + supervisorId) + "&";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSalesSuppervisorStaffs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSalesSuppervisorStaffs(<any>response_);
                } catch (e) {
                    return <Observable<StaffListDtoPagingResultApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<StaffListDtoPagingResultApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processGetSalesSuppervisorStaffs(response: HttpResponseBase): Observable<StaffListDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StaffListDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StaffListDtoPagingResultApiResultObject>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param supervisorId (optional) 
     * @param staffTypeCode (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getStaffByRoleId(id: number | undefined, supervisorId: number | undefined, staffTypeCode: string | undefined, queryId: string | undefined): Observable<StaffListDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/staffs/get-staff-by-roleId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (supervisorId === null)
            throw new Error("The parameter 'supervisorId' cannot be null.");
        else if (supervisorId !== undefined)
            url_ += "SupervisorId=" + encodeURIComponent("" + supervisorId) + "&";
        if (staffTypeCode === null)
            throw new Error("The parameter 'staffTypeCode' cannot be null.");
        else if (staffTypeCode !== undefined)
            url_ += "StaffTypeCode=" + encodeURIComponent("" + staffTypeCode) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStaffByRoleId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStaffByRoleId(<any>response_);
                } catch (e) {
                    return <Observable<StaffListDtoApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<StaffListDtoApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processGetStaffByRoleId(response: HttpResponseBase): Observable<StaffListDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StaffListDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StaffListDtoApiResultObject>(<any>null);
    }

    /**
     * @param supervisorId (optional) 
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getAsmStaffs(supervisorId: number | undefined, maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<StaffListDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/staffs/asm?";
        if (supervisorId === null)
            throw new Error("The parameter 'supervisorId' cannot be null.");
        else if (supervisorId !== undefined)
            url_ += "SupervisorId=" + encodeURIComponent("" + supervisorId) + "&";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAsmStaffs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAsmStaffs(<any>response_);
                } catch (e) {
                    return <Observable<StaffListDtoPagingResultApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<StaffListDtoPagingResultApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processGetAsmStaffs(response: HttpResponseBase): Observable<StaffListDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StaffListDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StaffListDtoPagingResultApiResultObject>(<any>null);
    }

    /**
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getRsmStaffs(maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<StaffListDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/staffs/rsm?";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRsmStaffs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRsmStaffs(<any>response_);
                } catch (e) {
                    return <Observable<StaffListDtoPagingResultApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<StaffListDtoPagingResultApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processGetRsmStaffs(response: HttpResponseBase): Observable<StaffListDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StaffListDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StaffListDtoPagingResultApiResultObject>(<any>null);
    }

    /**
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getStaffs(maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<StaffListDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/staffs?";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStaffs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStaffs(<any>response_);
                } catch (e) {
                    return <Observable<StaffListDtoPagingResultApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<StaffListDtoPagingResultApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processGetStaffs(response: HttpResponseBase): Observable<StaffListDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StaffListDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StaffListDtoPagingResultApiResultObject>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateCreditPoint(id: number, body: StaffUpdateCreditPointCommand | undefined): Observable<ObjectApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/staffs/{id}/update-credit-point";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCreditPoint(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCreditPoint(<any>response_);
                } catch (e) {
                    return <Observable<ObjectApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<ObjectApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCreditPoint(response: HttpResponseBase): Observable<ObjectApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectApiResultObject>(<any>null);
    }

    /**
     * @return Success
     */
    getSubProductClass(id: number): Observable<SubProductClassDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/sub-product-classes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubProductClass(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubProductClass(<any>response_);
                } catch (e) {
                    return <Observable<SubProductClassDtoApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubProductClassDtoApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processGetSubProductClass(response: HttpResponseBase): Observable<SubProductClassDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubProductClassDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubProductClassDtoApiResultObject>(<any>null);
    }

    /**
     * @return Success
     */
    deleteSubProductClass(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/sub-product-classes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteSubProductClass(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteSubProductClass(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteSubProductClass(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateSubProductClass(id: number, body: SubProductClassUpsertCommand | undefined): Observable<SubProductClassDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/sub-product-classes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSubProductClass(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSubProductClass(<any>response_);
                } catch (e) {
                    return <Observable<SubProductClassDtoApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubProductClassDtoApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateSubProductClass(response: HttpResponseBase): Observable<SubProductClassDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubProductClassDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubProductClassDtoApiResultObject>(<any>null);
    }

    /**
     * @param isActive (optional) 
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getSubProductClasses(isActive: boolean | undefined, maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<SubProductClassDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/sub-product-classes?";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubProductClasses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubProductClasses(<any>response_);
                } catch (e) {
                    return <Observable<SubProductClassDtoPagingResultApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubProductClassDtoPagingResultApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processGetSubProductClasses(response: HttpResponseBase): Observable<SubProductClassDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubProductClassDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubProductClassDtoPagingResultApiResultObject>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createSubProductClass(body: SubProductClassUpsertCommand | undefined): Observable<SubProductClassDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/sub-product-classes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateSubProductClass(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateSubProductClass(<any>response_);
                } catch (e) {
                    return <Observable<SubProductClassDtoApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubProductClassDtoApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processCreateSubProductClass(response: HttpResponseBase): Observable<SubProductClassDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubProductClassDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubProductClassDtoApiResultObject>(<any>null);
    }

    /**
     * @return Success
     */
    getTicketInvestment(id: number): Observable<TicketInvestmentDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/ticket-investments/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTicketInvestment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTicketInvestment(<any>response_);
                } catch (e) {
                    return <Observable<TicketInvestmentDtoApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<TicketInvestmentDtoApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processGetTicketInvestment(response: HttpResponseBase): Observable<TicketInvestmentDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TicketInvestmentDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TicketInvestmentDtoApiResultObject>(<any>null);
    }

    /**
     * @return Success
     */
    getTicketInvestmentHistory(id: number): Observable<TicketInvestmentHistoryDtoListApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/ticket-investments/{id}/history";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTicketInvestmentHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTicketInvestmentHistory(<any>response_);
                } catch (e) {
                    return <Observable<TicketInvestmentHistoryDtoListApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<TicketInvestmentHistoryDtoListApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processGetTicketInvestmentHistory(response: HttpResponseBase): Observable<TicketInvestmentHistoryDtoListApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TicketInvestmentHistoryDtoListApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TicketInvestmentHistoryDtoListApiResultObject>(<any>null);
    }

    /**
     * @return Success
     */
    getTickets(id: number): Observable<TicketDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/ticket-investments/{id}/tickets";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTickets(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTickets(<any>response_);
                } catch (e) {
                    return <Observable<TicketDtoPagingResultApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<TicketDtoPagingResultApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processGetTickets(response: HttpResponseBase): Observable<TicketDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TicketDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TicketDtoPagingResultApiResultObject>(<any>null);
    }

    /**
     * @return Success
     */
    getTicketInvestmentSummary(id: number): Observable<TicketInvestmentSummaryDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/ticket-investments/{id}/summary";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTicketInvestmentSummary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTicketInvestmentSummary(<any>response_);
                } catch (e) {
                    return <Observable<TicketInvestmentSummaryDtoApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<TicketInvestmentSummaryDtoApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processGetTicketInvestmentSummary(response: HttpResponseBase): Observable<TicketInvestmentSummaryDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TicketInvestmentSummaryDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TicketInvestmentSummaryDtoApiResultObject>(<any>null);
    }

    /**
     * @return Success
     */
    getTicketInvestmentTracking(id: number): Observable<TicketInvestmentTrackingDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/ticket-investments/{id}/tracking";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTicketInvestmentTracking(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTicketInvestmentTracking(<any>response_);
                } catch (e) {
                    return <Observable<TicketInvestmentTrackingDtoApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<TicketInvestmentTrackingDtoApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processGetTicketInvestmentTracking(response: HttpResponseBase): Observable<TicketInvestmentTrackingDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TicketInvestmentTrackingDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TicketInvestmentTrackingDtoApiResultObject>(<any>null);
    }

    /**
     * @return Success
     */
    getActiveTicketInvestment(): Observable<TicketInvestmentTrackingDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/ticket-investments/active-program";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActiveTicketInvestment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActiveTicketInvestment(<any>response_);
                } catch (e) {
                    return <Observable<TicketInvestmentTrackingDtoApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<TicketInvestmentTrackingDtoApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processGetActiveTicketInvestment(response: HttpResponseBase): Observable<TicketInvestmentTrackingDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TicketInvestmentTrackingDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TicketInvestmentTrackingDtoApiResultObject>(<any>null);
    }

    /**
     * @return Success
     */
    getTicket(id: number): Observable<TicketDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/ticket-investments/tickets/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTicket(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTicket(<any>response_);
                } catch (e) {
                    return <Observable<TicketDtoApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<TicketDtoApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processGetTicket(response: HttpResponseBase): Observable<TicketDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TicketDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TicketDtoApiResultObject>(<any>null);
    }

    /**
     * @return Success
     */
    getTicketConsumerReward(id: number): Observable<TicketConsumerRewardDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/ticket-investments/consumer-rewards/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTicketConsumerReward(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTicketConsumerReward(<any>response_);
                } catch (e) {
                    return <Observable<TicketConsumerRewardDtoApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<TicketConsumerRewardDtoApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processGetTicketConsumerReward(response: HttpResponseBase): Observable<TicketConsumerRewardDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TicketConsumerRewardDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TicketConsumerRewardDtoApiResultObject>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    registerTicketInvestment(body: TicketInvestmentRegisterCommand | undefined): Observable<TicketInvestmentDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/ticket-investments/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterTicketInvestment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterTicketInvestment(<any>response_);
                } catch (e) {
                    return <Observable<TicketInvestmentDtoApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<TicketInvestmentDtoApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processRegisterTicketInvestment(response: HttpResponseBase): Observable<TicketInvestmentDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TicketInvestmentDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TicketInvestmentDtoApiResultObject>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateTicketInvestment(body: TicketInvestmentUpdateCommand | undefined): Observable<ObjectApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/ticket-investments/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTicketInvestment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTicketInvestment(<any>response_);
                } catch (e) {
                    return <Observable<ObjectApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<ObjectApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTicketInvestment(response: HttpResponseBase): Observable<ObjectApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectApiResultObject>(<any>null);
    }

    /**
     * @return Success
     */
    approveTicketInvestment(id: number): Observable<ObjectApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/ticket-investments/{id}/approve";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApproveTicketInvestment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApproveTicketInvestment(<any>response_);
                } catch (e) {
                    return <Observable<ObjectApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<ObjectApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processApproveTicketInvestment(response: HttpResponseBase): Observable<ObjectApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectApiResultObject>(<any>null);
    }

    /**
     * @return Success
     */
    denyTicketInvestment(id: number): Observable<ObjectApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/ticket-investments/{id}/deny";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDenyTicketInvestment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDenyTicketInvestment(<any>response_);
                } catch (e) {
                    return <Observable<ObjectApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<ObjectApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processDenyTicketInvestment(response: HttpResponseBase): Observable<ObjectApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectApiResultObject>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createTicketInvestmentProgress(id: number, body: TicketInvestmentUpsertProgressCommand | undefined): Observable<TicketInvestmentDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/ticket-investments/{id}/progresses";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateTicketInvestmentProgress(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTicketInvestmentProgress(<any>response_);
                } catch (e) {
                    return <Observable<TicketInvestmentDtoApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<TicketInvestmentDtoApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processCreateTicketInvestmentProgress(response: HttpResponseBase): Observable<TicketInvestmentDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TicketInvestmentDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TicketInvestmentDtoApiResultObject>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateTicketInvestmentProgress(id: number, progressId: number, body: TicketInvestmentUpsertProgressCommand | undefined): Observable<TicketInvestmentDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/ticket-investments/{id}/progresses/{progressId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (progressId === undefined || progressId === null)
            throw new Error("The parameter 'progressId' must be defined.");
        url_ = url_.replace("{progressId}", encodeURIComponent("" + progressId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTicketInvestmentProgress(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTicketInvestmentProgress(<any>response_);
                } catch (e) {
                    return <Observable<TicketInvestmentDtoApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<TicketInvestmentDtoApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTicketInvestmentProgress(response: HttpResponseBase): Observable<TicketInvestmentDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TicketInvestmentDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TicketInvestmentDtoApiResultObject>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    operateTicketInvestment(id: number, body: TicketInvestmentOperateCommand | undefined): Observable<TicketInvestmentDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/ticket-investments/{id}/operate";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOperateTicketInvestment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOperateTicketInvestment(<any>response_);
                } catch (e) {
                    return <Observable<TicketInvestmentDtoApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<TicketInvestmentDtoApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processOperateTicketInvestment(response: HttpResponseBase): Observable<TicketInvestmentDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TicketInvestmentDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TicketInvestmentDtoApiResultObject>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    acceptTicketInvestment(id: number, body: TicketInvestmentUpsertAcceptanceCommand | undefined): Observable<TicketInvestmentDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/ticket-investments/{id}/accept";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAcceptTicketInvestment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAcceptTicketInvestment(<any>response_);
                } catch (e) {
                    return <Observable<TicketInvestmentDtoApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<TicketInvestmentDtoApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processAcceptTicketInvestment(response: HttpResponseBase): Observable<TicketInvestmentDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TicketInvestmentDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TicketInvestmentDtoApiResultObject>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    finalSettlementTicketInvestment(id: number, body: TicketInvestmentUpsertFinalSettlementCommand | undefined): Observable<TicketInvestmentDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/ticket-investments/{id}/final-settlement";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFinalSettlementTicketInvestment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFinalSettlementTicketInvestment(<any>response_);
                } catch (e) {
                    return <Observable<TicketInvestmentDtoApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<TicketInvestmentDtoApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processFinalSettlementTicketInvestment(response: HttpResponseBase): Observable<TicketInvestmentDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TicketInvestmentDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TicketInvestmentDtoApiResultObject>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateTicketInvestmentConsumerReward(id: number, rewardItemId: number, body: TicketInvestmentUpsertConsumerRewardCommand | undefined): Observable<TicketConsumerRewardDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/ticket-investments/{id}/consumer-rewards/{rewardItemId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (rewardItemId === undefined || rewardItemId === null)
            throw new Error("The parameter 'rewardItemId' must be defined.");
        url_ = url_.replace("{rewardItemId}", encodeURIComponent("" + rewardItemId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTicketInvestmentConsumerReward(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTicketInvestmentConsumerReward(<any>response_);
                } catch (e) {
                    return <Observable<TicketConsumerRewardDtoApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<TicketConsumerRewardDtoApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTicketInvestmentConsumerReward(response: HttpResponseBase): Observable<TicketConsumerRewardDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TicketConsumerRewardDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TicketConsumerRewardDtoApiResultObject>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    salesRemarkTicketInvestment(id: number, body: TicketInvestmentSalesRemarkCommand | undefined): Observable<ObjectApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/ticket-investments/{id}/sales-remark";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSalesRemarkTicketInvestment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSalesRemarkTicketInvestment(<any>response_);
                } catch (e) {
                    return <Observable<ObjectApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<ObjectApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processSalesRemarkTicketInvestment(response: HttpResponseBase): Observable<ObjectApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectApiResultObject>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    companyRemarkTicketInvestment(id: number, body: TicketInvestmentCompanyRemarkCommand | undefined): Observable<ObjectApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/ticket-investments/{id}/company-remark";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCompanyRemarkTicketInvestment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCompanyRemarkTicketInvestment(<any>response_);
                } catch (e) {
                    return <Observable<ObjectApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<ObjectApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processCompanyRemarkTicketInvestment(response: HttpResponseBase): Observable<ObjectApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectApiResultObject>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    customerDevelopmentRemarkTicketInvestment(id: number, body: TicketInvestmentCustomerDevelopmentRemarkCommand | undefined): Observable<ObjectApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/ticket-investments/{id}/customer-development-remark";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCustomerDevelopmentRemarkTicketInvestment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCustomerDevelopmentRemarkTicketInvestment(<any>response_);
                } catch (e) {
                    return <Observable<ObjectApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<ObjectApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processCustomerDevelopmentRemarkTicketInvestment(response: HttpResponseBase): Observable<ObjectApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectApiResultObject>(<any>null);
    }

    /**
     * @param status (optional) 
     * @param cycleId (optional) 
     * @param staffId (optional) 
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getTicketInvestmentsByUser(status: number[] | undefined, cycleId: number | undefined, staffId: number | undefined, maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<TicketInvestmentListItemDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/ticket-investments/byuser?";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            status && status.forEach(item => { url_ += "Status=" + encodeURIComponent("" + item) + "&"; });
        if (cycleId === null)
            throw new Error("The parameter 'cycleId' cannot be null.");
        else if (cycleId !== undefined)
            url_ += "CycleId=" + encodeURIComponent("" + cycleId) + "&";
        if (staffId === null)
            throw new Error("The parameter 'staffId' cannot be null.");
        else if (staffId !== undefined)
            url_ += "StaffId=" + encodeURIComponent("" + staffId) + "&";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTicketInvestmentsByUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTicketInvestmentsByUser(<any>response_);
                } catch (e) {
                    return <Observable<TicketInvestmentListItemDtoPagingResultApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<TicketInvestmentListItemDtoPagingResultApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processGetTicketInvestmentsByUser(response: HttpResponseBase): Observable<TicketInvestmentListItemDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TicketInvestmentListItemDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TicketInvestmentListItemDtoPagingResultApiResultObject>(<any>null);
    }

    /**
     * @param staffId (optional) 
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getHoldingTicketInvestmentsByUser(staffId: number | undefined, maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<TicketInvestmentListItemDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/ticket-investments/holding?";
        if (staffId === null)
            throw new Error("The parameter 'staffId' cannot be null.");
        else if (staffId !== undefined)
            url_ += "StaffId=" + encodeURIComponent("" + staffId) + "&";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHoldingTicketInvestmentsByUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHoldingTicketInvestmentsByUser(<any>response_);
                } catch (e) {
                    return <Observable<TicketInvestmentListItemDtoPagingResultApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<TicketInvestmentListItemDtoPagingResultApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processGetHoldingTicketInvestmentsByUser(response: HttpResponseBase): Observable<TicketInvestmentListItemDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TicketInvestmentListItemDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TicketInvestmentListItemDtoPagingResultApiResultObject>(<any>null);
    }

    /**
     * @param staffId (optional) 
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getRequestTicketInvestmentsByUser(staffId: number | undefined, maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<TicketInvestmentListItemDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/ticket-investments/request?";
        if (staffId === null)
            throw new Error("The parameter 'staffId' cannot be null.");
        else if (staffId !== undefined)
            url_ += "StaffId=" + encodeURIComponent("" + staffId) + "&";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRequestTicketInvestmentsByUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRequestTicketInvestmentsByUser(<any>response_);
                } catch (e) {
                    return <Observable<TicketInvestmentListItemDtoPagingResultApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<TicketInvestmentListItemDtoPagingResultApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processGetRequestTicketInvestmentsByUser(response: HttpResponseBase): Observable<TicketInvestmentListItemDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TicketInvestmentListItemDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TicketInvestmentListItemDtoPagingResultApiResultObject>(<any>null);
    }

    /**
     * @param staffId (optional) 
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getApprovedTicketInvestmentsByUser(staffId: number | undefined, maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<TicketInvestmentListItemDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/ticket-investments/approved?";
        if (staffId === null)
            throw new Error("The parameter 'staffId' cannot be null.");
        else if (staffId !== undefined)
            url_ += "StaffId=" + encodeURIComponent("" + staffId) + "&";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApprovedTicketInvestmentsByUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApprovedTicketInvestmentsByUser(<any>response_);
                } catch (e) {
                    return <Observable<TicketInvestmentListItemDtoPagingResultApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<TicketInvestmentListItemDtoPagingResultApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processGetApprovedTicketInvestmentsByUser(response: HttpResponseBase): Observable<TicketInvestmentListItemDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TicketInvestmentListItemDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TicketInvestmentListItemDtoPagingResultApiResultObject>(<any>null);
    }

    /**
     * @param customerId (optional) 
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getTicketInvestmentsByCustomer(customerId: number | undefined, maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<TicketInvestmentListItemDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/ticket-investments/bycustomer?";
        if (customerId === null)
            throw new Error("The parameter 'customerId' cannot be null.");
        else if (customerId !== undefined)
            url_ += "CustomerId=" + encodeURIComponent("" + customerId) + "&";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTicketInvestmentsByCustomer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTicketInvestmentsByCustomer(<any>response_);
                } catch (e) {
                    return <Observable<TicketInvestmentListItemDtoPagingResultApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<TicketInvestmentListItemDtoPagingResultApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processGetTicketInvestmentsByCustomer(response: HttpResponseBase): Observable<TicketInvestmentListItemDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TicketInvestmentListItemDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TicketInvestmentListItemDtoPagingResultApiResultObject>(<any>null);
    }

    /**
     * @param status (optional) 
     * @param rsmStaffId (optional) 
     * @param asmStaffId (optional) 
     * @param salesSupervisorStaffId (optional) 
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param byOperationDate (optional) 
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getTicketInvestmentsByTime(status: number[] | undefined, rsmStaffId: number | undefined, asmStaffId: number | undefined, salesSupervisorStaffId: number | undefined, fromDate: Date | undefined, toDate: Date | undefined, byOperationDate: boolean | undefined, maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<TicketInvestmentListItemDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/ticket-investments/bytime?";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            status && status.forEach(item => { url_ += "Status=" + encodeURIComponent("" + item) + "&"; });
        if (rsmStaffId === null)
            throw new Error("The parameter 'rsmStaffId' cannot be null.");
        else if (rsmStaffId !== undefined)
            url_ += "RsmStaffId=" + encodeURIComponent("" + rsmStaffId) + "&";
        if (asmStaffId === null)
            throw new Error("The parameter 'asmStaffId' cannot be null.");
        else if (asmStaffId !== undefined)
            url_ += "AsmStaffId=" + encodeURIComponent("" + asmStaffId) + "&";
        if (salesSupervisorStaffId === null)
            throw new Error("The parameter 'salesSupervisorStaffId' cannot be null.");
        else if (salesSupervisorStaffId !== undefined)
            url_ += "SalesSupervisorStaffId=" + encodeURIComponent("" + salesSupervisorStaffId) + "&";
        if (fromDate === null)
            throw new Error("The parameter 'fromDate' cannot be null.");
        else if (fromDate !== undefined)
            url_ += "FromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toJSON() : "") + "&";
        if (toDate === null)
            throw new Error("The parameter 'toDate' cannot be null.");
        else if (toDate !== undefined)
            url_ += "ToDate=" + encodeURIComponent(toDate ? "" + toDate.toJSON() : "") + "&";
        if (byOperationDate === null)
            throw new Error("The parameter 'byOperationDate' cannot be null.");
        else if (byOperationDate !== undefined)
            url_ += "ByOperationDate=" + encodeURIComponent("" + byOperationDate) + "&";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTicketInvestmentsByTime(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTicketInvestmentsByTime(<any>response_);
                } catch (e) {
                    return <Observable<TicketInvestmentListItemDtoPagingResultApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<TicketInvestmentListItemDtoPagingResultApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processGetTicketInvestmentsByTime(response: HttpResponseBase): Observable<TicketInvestmentListItemDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TicketInvestmentListItemDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TicketInvestmentListItemDtoPagingResultApiResultObject>(<any>null);
    }

    /**
     * @param status (optional) 
     * @param rsmStaffId (optional) 
     * @param asmStaffId (optional) 
     * @param salesSupervisorStaffId (optional) 
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param byOperationDate (optional) 
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getOperationPlanInvestmentList(status: number[] | undefined, rsmStaffId: number | undefined, asmStaffId: number | undefined, salesSupervisorStaffId: number | undefined, fromDate: Date | undefined, toDate: Date | undefined, byOperationDate: boolean | undefined, maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<TicketInvestmentListItemDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/ticket-investments/getOperationPlanInvestmentList?";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            status && status.forEach(item => { url_ += "Status=" + encodeURIComponent("" + item) + "&"; });
        if (rsmStaffId === null)
            throw new Error("The parameter 'rsmStaffId' cannot be null.");
        else if (rsmStaffId !== undefined)
            url_ += "RsmStaffId=" + encodeURIComponent("" + rsmStaffId) + "&";
        if (asmStaffId === null)
            throw new Error("The parameter 'asmStaffId' cannot be null.");
        else if (asmStaffId !== undefined)
            url_ += "AsmStaffId=" + encodeURIComponent("" + asmStaffId) + "&";
        if (salesSupervisorStaffId === null)
            throw new Error("The parameter 'salesSupervisorStaffId' cannot be null.");
        else if (salesSupervisorStaffId !== undefined)
            url_ += "SalesSupervisorStaffId=" + encodeURIComponent("" + salesSupervisorStaffId) + "&";
        if (fromDate === null)
            throw new Error("The parameter 'fromDate' cannot be null.");
        else if (fromDate !== undefined)
            url_ += "FromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toJSON() : "") + "&";
        if (toDate === null)
            throw new Error("The parameter 'toDate' cannot be null.");
        else if (toDate !== undefined)
            url_ += "ToDate=" + encodeURIComponent(toDate ? "" + toDate.toJSON() : "") + "&";
        if (byOperationDate === null)
            throw new Error("The parameter 'byOperationDate' cannot be null.");
        else if (byOperationDate !== undefined)
            url_ += "ByOperationDate=" + encodeURIComponent("" + byOperationDate) + "&";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOperationPlanInvestmentList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOperationPlanInvestmentList(<any>response_);
                } catch (e) {
                    return <Observable<TicketInvestmentListItemDtoPagingResultApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<TicketInvestmentListItemDtoPagingResultApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processGetOperationPlanInvestmentList(response: HttpResponseBase): Observable<TicketInvestmentListItemDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TicketInvestmentListItemDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TicketInvestmentListItemDtoPagingResultApiResultObject>(<any>null);
    }

    /**
     * @param ticketInvestmentId (optional) 
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getTicketByTicketInvestmentId(ticketInvestmentId: number | undefined, maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<TicketListDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/ticket-investments/getTicketByTicketInvestmentId?";
        if (ticketInvestmentId === null)
            throw new Error("The parameter 'ticketInvestmentId' cannot be null.");
        else if (ticketInvestmentId !== undefined)
            url_ += "TicketInvestmentId=" + encodeURIComponent("" + ticketInvestmentId) + "&";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTicketByTicketInvestmentId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTicketByTicketInvestmentId(<any>response_);
                } catch (e) {
                    return <Observable<TicketListDtoPagingResultApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<TicketListDtoPagingResultApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processGetTicketByTicketInvestmentId(response: HttpResponseBase): Observable<TicketListDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TicketListDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TicketListDtoPagingResultApiResultObject>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    printTicket(body: TicketInvestmentUpdatePrintTicketQuantityCommand | undefined): Observable<ObjectApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/ticket-investments/print";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPrintTicket(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPrintTicket(<any>response_);
                } catch (e) {
                    return <Observable<ObjectApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<ObjectApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processPrintTicket(response: HttpResponseBase): Observable<ObjectApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectApiResultObject>(<any>null);
    }

    /**
     * @return Success
     */
    getUser(id: number): Observable<UserDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/user-management/users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUser(<any>response_);
                } catch (e) {
                    return <Observable<UserDtoApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDtoApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processGetUser(response: HttpResponseBase): Observable<UserDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDtoApiResultObject>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateUser(id: number, body: UpsertUserExtCommand | undefined): Observable<UserDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/user-management/users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUser(<any>response_);
                } catch (e) {
                    return <Observable<UserDtoApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDtoApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUser(response: HttpResponseBase): Observable<UserDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDtoApiResultObject>(<any>null);
    }

    /**
     * @return Success
     */
    deleteUser(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/user-management/users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param isActive (optional) 
     * @param roleId (optional) 
     * @param roleName (optional) 
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getUsers(isActive: boolean | undefined, roleId: number | undefined, roleName: string | undefined, maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<UserListItemDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/user-management/users?";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (roleId === null)
            throw new Error("The parameter 'roleId' cannot be null.");
        else if (roleId !== undefined)
            url_ += "RoleId=" + encodeURIComponent("" + roleId) + "&";
        if (roleName === null)
            throw new Error("The parameter 'roleName' cannot be null.");
        else if (roleName !== undefined)
            url_ += "RoleName=" + encodeURIComponent("" + roleName) + "&";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsers(<any>response_);
                } catch (e) {
                    return <Observable<UserListItemDtoPagingResultApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserListItemDtoPagingResultApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processGetUsers(response: HttpResponseBase): Observable<UserListItemDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserListItemDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserListItemDtoPagingResultApiResultObject>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createUser(body: UpsertUserExtCommand | undefined): Observable<UserDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/user-management/users";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUser(<any>response_);
                } catch (e) {
                    return <Observable<UserDtoApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDtoApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUser(response: HttpResponseBase): Observable<UserDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDtoApiResultObject>(<any>null);
    }

    /**
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getCustomerDevelopmentUsers(maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<UserListItemDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/user-management/customer-development-users?";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomerDevelopmentUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomerDevelopmentUsers(<any>response_);
                } catch (e) {
                    return <Observable<UserListItemDtoPagingResultApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserListItemDtoPagingResultApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processGetCustomerDevelopmentUsers(response: HttpResponseBase): Observable<UserListItemDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserListItemDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserListItemDtoPagingResultApiResultObject>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeUserPassword(body: ChangeUserPasswordCommand | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/user-management/users/change-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeUserPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeUserPassword(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangeUserPassword(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateProfile(body: UpdateProfileCommand | undefined): Observable<UserDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/user-management/update-profile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateProfile(<any>response_);
                } catch (e) {
                    return <Observable<UserDtoApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDtoApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateProfile(response: HttpResponseBase): Observable<UserDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDtoApiResultObject>(<any>null);
    }

    /**
     * @return Success
     */
    getRole(id: number): Observable<RoleDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/user-management/roles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRole(<any>response_);
                } catch (e) {
                    return <Observable<RoleDtoApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDtoApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processGetRole(response: HttpResponseBase): Observable<RoleDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDtoApiResultObject>(<any>null);
    }

    /**
     * @return Success
     */
    deleteRole(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/user-management/roles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRole(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteRole(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateRole(id: number, body: UpsertRoleCommand | undefined): Observable<RoleDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/user-management/roles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateRole(<any>response_);
                } catch (e) {
                    return <Observable<RoleDtoApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDtoApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateRole(response: HttpResponseBase): Observable<RoleDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDtoApiResultObject>(<any>null);
    }

    /**
     * @param isActive (optional) 
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getRoles(isActive: boolean | undefined, maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<RoleListItemDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/user-management/roles?";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoles(<any>response_);
                } catch (e) {
                    return <Observable<RoleListItemDtoPagingResultApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleListItemDtoPagingResultApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoles(response: HttpResponseBase): Observable<RoleListItemDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleListItemDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleListItemDtoPagingResultApiResultObject>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createRole(body: UpsertRoleCommand | undefined): Observable<RoleDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/user-management/roles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateRole(<any>response_);
                } catch (e) {
                    return <Observable<RoleDtoApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDtoApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processCreateRole(response: HttpResponseBase): Observable<RoleDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDtoApiResultObject>(<any>null);
    }

    /**
     * @return Success
     */
    getPermission(id: number): Observable<PermissionDtoApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/user-management/permissions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPermission(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPermission(<any>response_);
                } catch (e) {
                    return <Observable<PermissionDtoApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<PermissionDtoApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processGetPermission(response: HttpResponseBase): Observable<PermissionDtoApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PermissionDtoApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PermissionDtoApiResultObject>(<any>null);
    }

    /**
     * @param maxResult (optional) 
     * @param skip (optional) 
     * @param keyword (optional) 
     * @param sort (optional) 
     * @param queryId (optional) 
     * @return Success
     */
    getPermissions(maxResult: number | undefined, skip: number | undefined, keyword: string | undefined, sort: string | undefined, queryId: string | undefined): Observable<PermissionDtoPagingResultApiResultObject> {
        let url_ = this.baseUrl + "/api/v1/user-management/permissions?";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "MaxResult=" + encodeURIComponent("" + maxResult) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (queryId === null)
            throw new Error("The parameter 'queryId' cannot be null.");
        else if (queryId !== undefined)
            url_ += "QueryId=" + encodeURIComponent("" + queryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPermissions(<any>response_);
                } catch (e) {
                    return <Observable<PermissionDtoPagingResultApiResultObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<PermissionDtoPagingResultApiResultObject>><any>_observableThrow(response_);
        }));
    }

    protected processGetPermissions(response: HttpResponseBase): Observable<PermissionDtoPagingResultApiResultObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PermissionDtoPagingResultApiResultObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PermissionDtoPagingResultApiResultObject>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendEmailResetPassword(body: SendEmailResetPasswordCommand | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/user-management/send-email-reset-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendEmailResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendEmailResetPassword(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendEmailResetPassword(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resetPassword(body: ResetPasswordCommand | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/user-management/reset-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

export class AppSettingDto implements IAppSettingDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    value?: string | undefined;
    description?: string | undefined;

    constructor(data?: IAppSettingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.value = _data["value"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): AppSettingDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppSettingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["value"] = this.value;
        data["description"] = this.description;
        return data; 
    }

    clone(): AppSettingDto {
        const json = this.toJSON();
        let result = new AppSettingDto();
        result.init(json);
        return result;
    }
}

export interface IAppSettingDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    value?: string | undefined;
    description?: string | undefined;
}

export class AppSettingDtoApiResultObject implements IAppSettingDtoApiResultObject {
    result?: AppSettingDto;
    success?: boolean;

    constructor(data?: IAppSettingDtoApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? AppSettingDto.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): AppSettingDtoApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new AppSettingDtoApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data; 
    }

    clone(): AppSettingDtoApiResultObject {
        const json = this.toJSON();
        let result = new AppSettingDtoApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IAppSettingDtoApiResultObject {
    result?: AppSettingDto;
    success?: boolean;
}

export class AppSettingDtoPagingResult implements IAppSettingDtoPagingResult {
    items?: AppSettingDto[] | undefined;
    totalCount?: number;

    constructor(data?: IAppSettingDtoPagingResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AppSettingDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): AppSettingDtoPagingResult {
        data = typeof data === 'object' ? data : {};
        let result = new AppSettingDtoPagingResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): AppSettingDtoPagingResult {
        const json = this.toJSON();
        let result = new AppSettingDtoPagingResult();
        result.init(json);
        return result;
    }
}

export interface IAppSettingDtoPagingResult {
    items?: AppSettingDto[] | undefined;
    totalCount?: number;
}

export class AppSettingDtoPagingResultApiResultObject implements IAppSettingDtoPagingResultApiResultObject {
    result?: AppSettingDtoPagingResult;
    success?: boolean;

    constructor(data?: IAppSettingDtoPagingResultApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? AppSettingDtoPagingResult.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): AppSettingDtoPagingResultApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new AppSettingDtoPagingResultApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data; 
    }

    clone(): AppSettingDtoPagingResultApiResultObject {
        const json = this.toJSON();
        let result = new AppSettingDtoPagingResultApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IAppSettingDtoPagingResultApiResultObject {
    result?: AppSettingDtoPagingResult;
    success?: boolean;
}

export class AreaByZoneNameListDto implements IAreaByZoneNameListDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    zoneId?: number;
    salesOrgId?: number;
    zoneName?: string | undefined;

    constructor(data?: IAreaByZoneNameListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.zoneId = _data["zoneId"];
            this.salesOrgId = _data["salesOrgId"];
            this.zoneName = _data["zoneName"];
        }
    }

    static fromJS(data: any): AreaByZoneNameListDto {
        data = typeof data === 'object' ? data : {};
        let result = new AreaByZoneNameListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["zoneId"] = this.zoneId;
        data["salesOrgId"] = this.salesOrgId;
        data["zoneName"] = this.zoneName;
        return data; 
    }

    clone(): AreaByZoneNameListDto {
        const json = this.toJSON();
        let result = new AreaByZoneNameListDto();
        result.init(json);
        return result;
    }
}

export interface IAreaByZoneNameListDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    zoneId?: number;
    salesOrgId?: number;
    zoneName?: string | undefined;
}

export class AreaByZoneNameListDtoPagingResult implements IAreaByZoneNameListDtoPagingResult {
    items?: AreaByZoneNameListDto[] | undefined;
    totalCount?: number;

    constructor(data?: IAreaByZoneNameListDtoPagingResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AreaByZoneNameListDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): AreaByZoneNameListDtoPagingResult {
        data = typeof data === 'object' ? data : {};
        let result = new AreaByZoneNameListDtoPagingResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): AreaByZoneNameListDtoPagingResult {
        const json = this.toJSON();
        let result = new AreaByZoneNameListDtoPagingResult();
        result.init(json);
        return result;
    }
}

export interface IAreaByZoneNameListDtoPagingResult {
    items?: AreaByZoneNameListDto[] | undefined;
    totalCount?: number;
}

export class AreaByZoneNameListDtoPagingResultApiResultObject implements IAreaByZoneNameListDtoPagingResultApiResultObject {
    result?: AreaByZoneNameListDtoPagingResult;
    success?: boolean;

    constructor(data?: IAreaByZoneNameListDtoPagingResultApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? AreaByZoneNameListDtoPagingResult.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): AreaByZoneNameListDtoPagingResultApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new AreaByZoneNameListDtoPagingResultApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data; 
    }

    clone(): AreaByZoneNameListDtoPagingResultApiResultObject {
        const json = this.toJSON();
        let result = new AreaByZoneNameListDtoPagingResultApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IAreaByZoneNameListDtoPagingResultApiResultObject {
    result?: AreaByZoneNameListDtoPagingResult;
    success?: boolean;
}

export class AreaDto implements IAreaDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    zoneId?: number;
    salesOrgId?: number;

    constructor(data?: IAreaDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.zoneId = _data["zoneId"];
            this.salesOrgId = _data["salesOrgId"];
        }
    }

    static fromJS(data: any): AreaDto {
        data = typeof data === 'object' ? data : {};
        let result = new AreaDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["zoneId"] = this.zoneId;
        data["salesOrgId"] = this.salesOrgId;
        return data; 
    }

    clone(): AreaDto {
        const json = this.toJSON();
        let result = new AreaDto();
        result.init(json);
        return result;
    }
}

export interface IAreaDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    zoneId?: number;
    salesOrgId?: number;
}

export class AreaDtoApiResultObject implements IAreaDtoApiResultObject {
    result?: AreaDto;
    success?: boolean;

    constructor(data?: IAreaDtoApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? AreaDto.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): AreaDtoApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new AreaDtoApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data; 
    }

    clone(): AreaDtoApiResultObject {
        const json = this.toJSON();
        let result = new AreaDtoApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IAreaDtoApiResultObject {
    result?: AreaDto;
    success?: boolean;
}

export class AreaDtoPagingResult implements IAreaDtoPagingResult {
    items?: AreaDto[] | undefined;
    totalCount?: number;

    constructor(data?: IAreaDtoPagingResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AreaDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): AreaDtoPagingResult {
        data = typeof data === 'object' ? data : {};
        let result = new AreaDtoPagingResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): AreaDtoPagingResult {
        const json = this.toJSON();
        let result = new AreaDtoPagingResult();
        result.init(json);
        return result;
    }
}

export interface IAreaDtoPagingResult {
    items?: AreaDto[] | undefined;
    totalCount?: number;
}

export class AreaDtoPagingResultApiResultObject implements IAreaDtoPagingResultApiResultObject {
    result?: AreaDtoPagingResult;
    success?: boolean;

    constructor(data?: IAreaDtoPagingResultApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? AreaDtoPagingResult.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): AreaDtoPagingResultApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new AreaDtoPagingResultApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data; 
    }

    clone(): AreaDtoPagingResultApiResultObject {
        const json = this.toJSON();
        let result = new AreaDtoPagingResultApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IAreaDtoPagingResultApiResultObject {
    result?: AreaDtoPagingResult;
    success?: boolean;
}

export class BranchDto implements IBranchDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    areaId?: number;
    salesOrgId?: number;
    zoneId?: number;
    isActive?: boolean;
    channelId?: number | undefined;

    constructor(data?: IBranchDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.areaId = _data["areaId"];
            this.salesOrgId = _data["salesOrgId"];
            this.zoneId = _data["zoneId"];
            this.isActive = _data["isActive"];
            this.channelId = _data["channelId"];
        }
    }

    static fromJS(data: any): BranchDto {
        data = typeof data === 'object' ? data : {};
        let result = new BranchDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["areaId"] = this.areaId;
        data["salesOrgId"] = this.salesOrgId;
        data["zoneId"] = this.zoneId;
        data["isActive"] = this.isActive;
        data["channelId"] = this.channelId;
        return data; 
    }

    clone(): BranchDto {
        const json = this.toJSON();
        let result = new BranchDto();
        result.init(json);
        return result;
    }
}

export interface IBranchDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    areaId?: number;
    salesOrgId?: number;
    zoneId?: number;
    isActive?: boolean;
    channelId?: number | undefined;
}

export class BranchDtoApiResultObject implements IBranchDtoApiResultObject {
    result?: BranchDto;
    success?: boolean;

    constructor(data?: IBranchDtoApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? BranchDto.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): BranchDtoApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new BranchDtoApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data; 
    }

    clone(): BranchDtoApiResultObject {
        const json = this.toJSON();
        let result = new BranchDtoApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IBranchDtoApiResultObject {
    result?: BranchDto;
    success?: boolean;
}

export class BranchListItemDto implements IBranchListItemDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    areaId?: number;
    salesOrgId?: number;
    zoneId?: number;
    isActive?: boolean;
    channelId?: number | undefined;
    zoneName?: string | undefined;
    areaName?: string | undefined;
    channelName?: string | undefined;
    provinccId?: number | undefined;
    provinceName?: string | undefined;

    constructor(data?: IBranchListItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.areaId = _data["areaId"];
            this.salesOrgId = _data["salesOrgId"];
            this.zoneId = _data["zoneId"];
            this.isActive = _data["isActive"];
            this.channelId = _data["channelId"];
            this.zoneName = _data["zoneName"];
            this.areaName = _data["areaName"];
            this.channelName = _data["channelName"];
            this.provinccId = _data["provinccId"];
            this.provinceName = _data["provinceName"];
        }
    }

    static fromJS(data: any): BranchListItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new BranchListItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["areaId"] = this.areaId;
        data["salesOrgId"] = this.salesOrgId;
        data["zoneId"] = this.zoneId;
        data["isActive"] = this.isActive;
        data["channelId"] = this.channelId;
        data["zoneName"] = this.zoneName;
        data["areaName"] = this.areaName;
        data["channelName"] = this.channelName;
        data["provinccId"] = this.provinccId;
        data["provinceName"] = this.provinceName;
        return data; 
    }

    clone(): BranchListItemDto {
        const json = this.toJSON();
        let result = new BranchListItemDto();
        result.init(json);
        return result;
    }
}

export interface IBranchListItemDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    areaId?: number;
    salesOrgId?: number;
    zoneId?: number;
    isActive?: boolean;
    channelId?: number | undefined;
    zoneName?: string | undefined;
    areaName?: string | undefined;
    channelName?: string | undefined;
    provinccId?: number | undefined;
    provinceName?: string | undefined;
}

export class BranchListItemDtoPagingResult implements IBranchListItemDtoPagingResult {
    items?: BranchListItemDto[] | undefined;
    totalCount?: number;

    constructor(data?: IBranchListItemDtoPagingResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(BranchListItemDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): BranchListItemDtoPagingResult {
        data = typeof data === 'object' ? data : {};
        let result = new BranchListItemDtoPagingResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): BranchListItemDtoPagingResult {
        const json = this.toJSON();
        let result = new BranchListItemDtoPagingResult();
        result.init(json);
        return result;
    }
}

export interface IBranchListItemDtoPagingResult {
    items?: BranchListItemDto[] | undefined;
    totalCount?: number;
}

export class BranchListItemDtoPagingResultApiResultObject implements IBranchListItemDtoPagingResultApiResultObject {
    result?: BranchListItemDtoPagingResult;
    success?: boolean;

    constructor(data?: IBranchListItemDtoPagingResultApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? BranchListItemDtoPagingResult.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): BranchListItemDtoPagingResultApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new BranchListItemDtoPagingResultApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data; 
    }

    clone(): BranchListItemDtoPagingResultApiResultObject {
        const json = this.toJSON();
        let result = new BranchListItemDtoPagingResultApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IBranchListItemDtoPagingResultApiResultObject {
    result?: BranchListItemDtoPagingResult;
    success?: boolean;
}

export class BrandDto implements IBrandDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    isActive?: boolean;

    constructor(data?: IBrandDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): BrandDto {
        data = typeof data === 'object' ? data : {};
        let result = new BrandDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): BrandDto {
        const json = this.toJSON();
        let result = new BrandDto();
        result.init(json);
        return result;
    }
}

export interface IBrandDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    isActive?: boolean;
}

export class BrandDtoApiResultObject implements IBrandDtoApiResultObject {
    result?: BrandDto;
    success?: boolean;

    constructor(data?: IBrandDtoApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? BrandDto.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): BrandDtoApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new BrandDtoApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data; 
    }

    clone(): BrandDtoApiResultObject {
        const json = this.toJSON();
        let result = new BrandDtoApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IBrandDtoApiResultObject {
    result?: BrandDto;
    success?: boolean;
}

export class BrandDtoPagingResult implements IBrandDtoPagingResult {
    items?: BrandDto[] | undefined;
    totalCount?: number;

    constructor(data?: IBrandDtoPagingResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(BrandDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): BrandDtoPagingResult {
        data = typeof data === 'object' ? data : {};
        let result = new BrandDtoPagingResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): BrandDtoPagingResult {
        const json = this.toJSON();
        let result = new BrandDtoPagingResult();
        result.init(json);
        return result;
    }
}

export interface IBrandDtoPagingResult {
    items?: BrandDto[] | undefined;
    totalCount?: number;
}

export class BrandDtoPagingResultApiResultObject implements IBrandDtoPagingResultApiResultObject {
    result?: BrandDtoPagingResult;
    success?: boolean;

    constructor(data?: IBrandDtoPagingResultApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? BrandDtoPagingResult.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): BrandDtoPagingResultApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new BrandDtoPagingResultApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data; 
    }

    clone(): BrandDtoPagingResultApiResultObject {
        const json = this.toJSON();
        let result = new BrandDtoPagingResultApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IBrandDtoPagingResultApiResultObject {
    result?: BrandDtoPagingResult;
    success?: boolean;
}

export class BudgetAreaDto implements IBudgetAreaDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    areaId?: number;
    areaCode?: string | undefined;
    areaName?: string | undefined;
    zoneId?: number;
    zoneName?: string | undefined;
    salesOrgId?: number;
    parentSalesOrgId?: number;
    allocateAmount?: number;
    remainAmount?: number;
    usedAmount?: number;
    tempRemainAmount?: number;
    tempUsedAmount?: number;

    constructor(data?: IBudgetAreaDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.areaId = _data["areaId"];
            this.areaCode = _data["areaCode"];
            this.areaName = _data["areaName"];
            this.zoneId = _data["zoneId"];
            this.zoneName = _data["zoneName"];
            this.salesOrgId = _data["salesOrgId"];
            this.parentSalesOrgId = _data["parentSalesOrgId"];
            this.allocateAmount = _data["allocateAmount"];
            this.remainAmount = _data["remainAmount"];
            this.usedAmount = _data["usedAmount"];
            this.tempRemainAmount = _data["tempRemainAmount"];
            this.tempUsedAmount = _data["tempUsedAmount"];
        }
    }

    static fromJS(data: any): BudgetAreaDto {
        data = typeof data === 'object' ? data : {};
        let result = new BudgetAreaDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["areaId"] = this.areaId;
        data["areaCode"] = this.areaCode;
        data["areaName"] = this.areaName;
        data["zoneId"] = this.zoneId;
        data["zoneName"] = this.zoneName;
        data["salesOrgId"] = this.salesOrgId;
        data["parentSalesOrgId"] = this.parentSalesOrgId;
        data["allocateAmount"] = this.allocateAmount;
        data["remainAmount"] = this.remainAmount;
        data["usedAmount"] = this.usedAmount;
        data["tempRemainAmount"] = this.tempRemainAmount;
        data["tempUsedAmount"] = this.tempUsedAmount;
        return data; 
    }

    clone(): BudgetAreaDto {
        const json = this.toJSON();
        let result = new BudgetAreaDto();
        result.init(json);
        return result;
    }
}

export interface IBudgetAreaDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    areaId?: number;
    areaCode?: string | undefined;
    areaName?: string | undefined;
    zoneId?: number;
    zoneName?: string | undefined;
    salesOrgId?: number;
    parentSalesOrgId?: number;
    allocateAmount?: number;
    remainAmount?: number;
    usedAmount?: number;
    tempRemainAmount?: number;
    tempUsedAmount?: number;
}

export class BudgetAreaUpsertDto implements IBudgetAreaUpsertDto {
    id?: number;
    areaId?: number;
    areaCode?: string | undefined;
    areaName?: string | undefined;
    salesOrgId?: number;
    parentSalesOrgId?: number;
    allocateAmount?: number;
    remainAmount?: number;
    usedAmount?: number;

    constructor(data?: IBudgetAreaUpsertDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.areaId = _data["areaId"];
            this.areaCode = _data["areaCode"];
            this.areaName = _data["areaName"];
            this.salesOrgId = _data["salesOrgId"];
            this.parentSalesOrgId = _data["parentSalesOrgId"];
            this.allocateAmount = _data["allocateAmount"];
            this.remainAmount = _data["remainAmount"];
            this.usedAmount = _data["usedAmount"];
        }
    }

    static fromJS(data: any): BudgetAreaUpsertDto {
        data = typeof data === 'object' ? data : {};
        let result = new BudgetAreaUpsertDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["areaId"] = this.areaId;
        data["areaCode"] = this.areaCode;
        data["areaName"] = this.areaName;
        data["salesOrgId"] = this.salesOrgId;
        data["parentSalesOrgId"] = this.parentSalesOrgId;
        data["allocateAmount"] = this.allocateAmount;
        data["remainAmount"] = this.remainAmount;
        data["usedAmount"] = this.usedAmount;
        return data; 
    }

    clone(): BudgetAreaUpsertDto {
        const json = this.toJSON();
        let result = new BudgetAreaUpsertDto();
        result.init(json);
        return result;
    }
}

export interface IBudgetAreaUpsertDto {
    id?: number;
    areaId?: number;
    areaCode?: string | undefined;
    areaName?: string | undefined;
    salesOrgId?: number;
    parentSalesOrgId?: number;
    allocateAmount?: number;
    remainAmount?: number;
    usedAmount?: number;
}

export class BudgetAreaUpsertDtoCrudListDto implements IBudgetAreaUpsertDtoCrudListDto {
    upsertedItems?: BudgetAreaUpsertDto[] | undefined;
    deletedItems?: BudgetAreaUpsertDto[] | undefined;

    constructor(data?: IBudgetAreaUpsertDtoCrudListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["upsertedItems"])) {
                this.upsertedItems = [] as any;
                for (let item of _data["upsertedItems"])
                    this.upsertedItems!.push(BudgetAreaUpsertDto.fromJS(item));
            }
            if (Array.isArray(_data["deletedItems"])) {
                this.deletedItems = [] as any;
                for (let item of _data["deletedItems"])
                    this.deletedItems!.push(BudgetAreaUpsertDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BudgetAreaUpsertDtoCrudListDto {
        data = typeof data === 'object' ? data : {};
        let result = new BudgetAreaUpsertDtoCrudListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.upsertedItems)) {
            data["upsertedItems"] = [];
            for (let item of this.upsertedItems)
                data["upsertedItems"].push(item.toJSON());
        }
        if (Array.isArray(this.deletedItems)) {
            data["deletedItems"] = [];
            for (let item of this.deletedItems)
                data["deletedItems"].push(item.toJSON());
        }
        return data; 
    }

    clone(): BudgetAreaUpsertDtoCrudListDto {
        const json = this.toJSON();
        let result = new BudgetAreaUpsertDtoCrudListDto();
        result.init(json);
        return result;
    }
}

export interface IBudgetAreaUpsertDtoCrudListDto {
    upsertedItems?: BudgetAreaUpsertDto[] | undefined;
    deletedItems?: BudgetAreaUpsertDto[] | undefined;
}

export class BudgetBranchDto implements IBudgetBranchDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    branchId?: number;
    branchCode?: string | undefined;
    branchName?: string | undefined;
    zoneId?: number;
    zoneName?: string | undefined;
    areaId?: number;
    areaName?: string | undefined;
    salesOrgId?: number;
    parentSalesOrgId?: number;
    allocateAmount?: number;
    remainAmount?: number;
    usedAmount?: number;
    tempRemainAmount?: number;
    tempUsedAmount?: number;

    constructor(data?: IBudgetBranchDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.branchId = _data["branchId"];
            this.branchCode = _data["branchCode"];
            this.branchName = _data["branchName"];
            this.zoneId = _data["zoneId"];
            this.zoneName = _data["zoneName"];
            this.areaId = _data["areaId"];
            this.areaName = _data["areaName"];
            this.salesOrgId = _data["salesOrgId"];
            this.parentSalesOrgId = _data["parentSalesOrgId"];
            this.allocateAmount = _data["allocateAmount"];
            this.remainAmount = _data["remainAmount"];
            this.usedAmount = _data["usedAmount"];
            this.tempRemainAmount = _data["tempRemainAmount"];
            this.tempUsedAmount = _data["tempUsedAmount"];
        }
    }

    static fromJS(data: any): BudgetBranchDto {
        data = typeof data === 'object' ? data : {};
        let result = new BudgetBranchDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["branchId"] = this.branchId;
        data["branchCode"] = this.branchCode;
        data["branchName"] = this.branchName;
        data["zoneId"] = this.zoneId;
        data["zoneName"] = this.zoneName;
        data["areaId"] = this.areaId;
        data["areaName"] = this.areaName;
        data["salesOrgId"] = this.salesOrgId;
        data["parentSalesOrgId"] = this.parentSalesOrgId;
        data["allocateAmount"] = this.allocateAmount;
        data["remainAmount"] = this.remainAmount;
        data["usedAmount"] = this.usedAmount;
        data["tempRemainAmount"] = this.tempRemainAmount;
        data["tempUsedAmount"] = this.tempUsedAmount;
        return data; 
    }

    clone(): BudgetBranchDto {
        const json = this.toJSON();
        let result = new BudgetBranchDto();
        result.init(json);
        return result;
    }
}

export interface IBudgetBranchDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    branchId?: number;
    branchCode?: string | undefined;
    branchName?: string | undefined;
    zoneId?: number;
    zoneName?: string | undefined;
    areaId?: number;
    areaName?: string | undefined;
    salesOrgId?: number;
    parentSalesOrgId?: number;
    allocateAmount?: number;
    remainAmount?: number;
    usedAmount?: number;
    tempRemainAmount?: number;
    tempUsedAmount?: number;
}

export class BudgetBranchUpsertDto implements IBudgetBranchUpsertDto {
    id?: number;
    branchId?: number;
    branchCode?: string | undefined;
    branchName?: string | undefined;
    salesOrgId?: number;
    parentSalesOrgId?: number;
    allocateAmount?: number;
    remainAmount?: number;
    usedAmount?: number;

    constructor(data?: IBudgetBranchUpsertDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.branchId = _data["branchId"];
            this.branchCode = _data["branchCode"];
            this.branchName = _data["branchName"];
            this.salesOrgId = _data["salesOrgId"];
            this.parentSalesOrgId = _data["parentSalesOrgId"];
            this.allocateAmount = _data["allocateAmount"];
            this.remainAmount = _data["remainAmount"];
            this.usedAmount = _data["usedAmount"];
        }
    }

    static fromJS(data: any): BudgetBranchUpsertDto {
        data = typeof data === 'object' ? data : {};
        let result = new BudgetBranchUpsertDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["branchId"] = this.branchId;
        data["branchCode"] = this.branchCode;
        data["branchName"] = this.branchName;
        data["salesOrgId"] = this.salesOrgId;
        data["parentSalesOrgId"] = this.parentSalesOrgId;
        data["allocateAmount"] = this.allocateAmount;
        data["remainAmount"] = this.remainAmount;
        data["usedAmount"] = this.usedAmount;
        return data; 
    }

    clone(): BudgetBranchUpsertDto {
        const json = this.toJSON();
        let result = new BudgetBranchUpsertDto();
        result.init(json);
        return result;
    }
}

export interface IBudgetBranchUpsertDto {
    id?: number;
    branchId?: number;
    branchCode?: string | undefined;
    branchName?: string | undefined;
    salesOrgId?: number;
    parentSalesOrgId?: number;
    allocateAmount?: number;
    remainAmount?: number;
    usedAmount?: number;
}

export class BudgetBranchUpsertDtoCrudListDto implements IBudgetBranchUpsertDtoCrudListDto {
    upsertedItems?: BudgetBranchUpsertDto[] | undefined;
    deletedItems?: BudgetBranchUpsertDto[] | undefined;

    constructor(data?: IBudgetBranchUpsertDtoCrudListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["upsertedItems"])) {
                this.upsertedItems = [] as any;
                for (let item of _data["upsertedItems"])
                    this.upsertedItems!.push(BudgetBranchUpsertDto.fromJS(item));
            }
            if (Array.isArray(_data["deletedItems"])) {
                this.deletedItems = [] as any;
                for (let item of _data["deletedItems"])
                    this.deletedItems!.push(BudgetBranchUpsertDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BudgetBranchUpsertDtoCrudListDto {
        data = typeof data === 'object' ? data : {};
        let result = new BudgetBranchUpsertDtoCrudListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.upsertedItems)) {
            data["upsertedItems"] = [];
            for (let item of this.upsertedItems)
                data["upsertedItems"].push(item.toJSON());
        }
        if (Array.isArray(this.deletedItems)) {
            data["deletedItems"] = [];
            for (let item of this.deletedItems)
                data["deletedItems"].push(item.toJSON());
        }
        return data; 
    }

    clone(): BudgetBranchUpsertDtoCrudListDto {
        const json = this.toJSON();
        let result = new BudgetBranchUpsertDtoCrudListDto();
        result.init(json);
        return result;
    }
}

export interface IBudgetBranchUpsertDtoCrudListDto {
    upsertedItems?: BudgetBranchUpsertDto[] | undefined;
    deletedItems?: BudgetBranchUpsertDto[] | undefined;
}

export class BudgetDto implements IBudgetDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    cycleId?: number;
    fromDate?: Date;
    toDate?: Date;
    investmentType?: number;
    zones?: BudgetZoneDto[] | undefined;
    areas?: BudgetAreaDto[] | undefined;
    branches?: BudgetBranchDto[] | undefined;

    constructor(data?: IBudgetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.cycleId = _data["cycleId"];
            this.fromDate = _data["fromDate"] ? new Date(_data["fromDate"].toString()) : <any>undefined;
            this.toDate = _data["toDate"] ? new Date(_data["toDate"].toString()) : <any>undefined;
            this.investmentType = _data["investmentType"];
            if (Array.isArray(_data["zones"])) {
                this.zones = [] as any;
                for (let item of _data["zones"])
                    this.zones!.push(BudgetZoneDto.fromJS(item));
            }
            if (Array.isArray(_data["areas"])) {
                this.areas = [] as any;
                for (let item of _data["areas"])
                    this.areas!.push(BudgetAreaDto.fromJS(item));
            }
            if (Array.isArray(_data["branches"])) {
                this.branches = [] as any;
                for (let item of _data["branches"])
                    this.branches!.push(BudgetBranchDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BudgetDto {
        data = typeof data === 'object' ? data : {};
        let result = new BudgetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["cycleId"] = this.cycleId;
        data["fromDate"] = this.fromDate ? this.fromDate.toISOString() : <any>undefined;
        data["toDate"] = this.toDate ? this.toDate.toISOString() : <any>undefined;
        data["investmentType"] = this.investmentType;
        if (Array.isArray(this.zones)) {
            data["zones"] = [];
            for (let item of this.zones)
                data["zones"].push(item.toJSON());
        }
        if (Array.isArray(this.areas)) {
            data["areas"] = [];
            for (let item of this.areas)
                data["areas"].push(item.toJSON());
        }
        if (Array.isArray(this.branches)) {
            data["branches"] = [];
            for (let item of this.branches)
                data["branches"].push(item.toJSON());
        }
        return data; 
    }

    clone(): BudgetDto {
        const json = this.toJSON();
        let result = new BudgetDto();
        result.init(json);
        return result;
    }
}

export interface IBudgetDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    cycleId?: number;
    fromDate?: Date;
    toDate?: Date;
    investmentType?: number;
    zones?: BudgetZoneDto[] | undefined;
    areas?: BudgetAreaDto[] | undefined;
    branches?: BudgetBranchDto[] | undefined;
}

export class BudgetDtoApiResultObject implements IBudgetDtoApiResultObject {
    result?: BudgetDto;
    success?: boolean;

    constructor(data?: IBudgetDtoApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? BudgetDto.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): BudgetDtoApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new BudgetDtoApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data; 
    }

    clone(): BudgetDtoApiResultObject {
        const json = this.toJSON();
        let result = new BudgetDtoApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IBudgetDtoApiResultObject {
    result?: BudgetDto;
    success?: boolean;
}

export class BudgetInitDetailDto implements IBudgetInitDetailDto {
    zones?: BudgetZoneDto[] | undefined;
    areas?: BudgetAreaDto[] | undefined;
    branches?: BudgetBranchDto[] | undefined;

    constructor(data?: IBudgetInitDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["zones"])) {
                this.zones = [] as any;
                for (let item of _data["zones"])
                    this.zones!.push(BudgetZoneDto.fromJS(item));
            }
            if (Array.isArray(_data["areas"])) {
                this.areas = [] as any;
                for (let item of _data["areas"])
                    this.areas!.push(BudgetAreaDto.fromJS(item));
            }
            if (Array.isArray(_data["branches"])) {
                this.branches = [] as any;
                for (let item of _data["branches"])
                    this.branches!.push(BudgetBranchDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BudgetInitDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new BudgetInitDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.zones)) {
            data["zones"] = [];
            for (let item of this.zones)
                data["zones"].push(item.toJSON());
        }
        if (Array.isArray(this.areas)) {
            data["areas"] = [];
            for (let item of this.areas)
                data["areas"].push(item.toJSON());
        }
        if (Array.isArray(this.branches)) {
            data["branches"] = [];
            for (let item of this.branches)
                data["branches"].push(item.toJSON());
        }
        return data; 
    }

    clone(): BudgetInitDetailDto {
        const json = this.toJSON();
        let result = new BudgetInitDetailDto();
        result.init(json);
        return result;
    }
}

export interface IBudgetInitDetailDto {
    zones?: BudgetZoneDto[] | undefined;
    areas?: BudgetAreaDto[] | undefined;
    branches?: BudgetBranchDto[] | undefined;
}

export class BudgetInitDetailDtoApiResultObject implements IBudgetInitDetailDtoApiResultObject {
    result?: BudgetInitDetailDto;
    success?: boolean;

    constructor(data?: IBudgetInitDetailDtoApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? BudgetInitDetailDto.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): BudgetInitDetailDtoApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new BudgetInitDetailDtoApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data; 
    }

    clone(): BudgetInitDetailDtoApiResultObject {
        const json = this.toJSON();
        let result = new BudgetInitDetailDtoApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IBudgetInitDetailDtoApiResultObject {
    result?: BudgetInitDetailDto;
    success?: boolean;
}

export enum BudgetInvestmentType {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export class BudgetListItemDto implements IBudgetListItemDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    cycleId?: number;
    cycleNumber?: string | undefined;
    investmentType?: number;
    usedAmount?: number;
    remainAmount?: number;
    allocateAmount?: number;
    tempRemainAmount?: number;
    tempUsedAmount?: number;

    constructor(data?: IBudgetListItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.cycleId = _data["cycleId"];
            this.cycleNumber = _data["cycleNumber"];
            this.investmentType = _data["investmentType"];
            this.usedAmount = _data["usedAmount"];
            this.remainAmount = _data["remainAmount"];
            this.allocateAmount = _data["allocateAmount"];
            this.tempRemainAmount = _data["tempRemainAmount"];
            this.tempUsedAmount = _data["tempUsedAmount"];
        }
    }

    static fromJS(data: any): BudgetListItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new BudgetListItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["cycleId"] = this.cycleId;
        data["cycleNumber"] = this.cycleNumber;
        data["investmentType"] = this.investmentType;
        data["usedAmount"] = this.usedAmount;
        data["remainAmount"] = this.remainAmount;
        data["allocateAmount"] = this.allocateAmount;
        data["tempRemainAmount"] = this.tempRemainAmount;
        data["tempUsedAmount"] = this.tempUsedAmount;
        return data; 
    }

    clone(): BudgetListItemDto {
        const json = this.toJSON();
        let result = new BudgetListItemDto();
        result.init(json);
        return result;
    }
}

export interface IBudgetListItemDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    cycleId?: number;
    cycleNumber?: string | undefined;
    investmentType?: number;
    usedAmount?: number;
    remainAmount?: number;
    allocateAmount?: number;
    tempRemainAmount?: number;
    tempUsedAmount?: number;
}

export class BudgetListItemDtoPagingResult implements IBudgetListItemDtoPagingResult {
    items?: BudgetListItemDto[] | undefined;
    totalCount?: number;

    constructor(data?: IBudgetListItemDtoPagingResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(BudgetListItemDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): BudgetListItemDtoPagingResult {
        data = typeof data === 'object' ? data : {};
        let result = new BudgetListItemDtoPagingResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): BudgetListItemDtoPagingResult {
        const json = this.toJSON();
        let result = new BudgetListItemDtoPagingResult();
        result.init(json);
        return result;
    }
}

export interface IBudgetListItemDtoPagingResult {
    items?: BudgetListItemDto[] | undefined;
    totalCount?: number;
}

export class BudgetListItemDtoPagingResultApiResultObject implements IBudgetListItemDtoPagingResultApiResultObject {
    result?: BudgetListItemDtoPagingResult;
    success?: boolean;

    constructor(data?: IBudgetListItemDtoPagingResultApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? BudgetListItemDtoPagingResult.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): BudgetListItemDtoPagingResultApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new BudgetListItemDtoPagingResultApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data; 
    }

    clone(): BudgetListItemDtoPagingResultApiResultObject {
        const json = this.toJSON();
        let result = new BudgetListItemDtoPagingResultApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IBudgetListItemDtoPagingResultApiResultObject {
    result?: BudgetListItemDtoPagingResult;
    success?: boolean;
}

export class BudgetUpsertCommand implements IBudgetUpsertCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: BudgetUpsertDto;
    readonly handleType?: string | undefined;

    constructor(data?: IBudgetUpsertCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? BudgetUpsertDto.fromJS(_data["data"]) : <any>undefined;
            (<any>this).handleType = _data["handleType"];
        }
    }

    static fromJS(data: any): BudgetUpsertCommand {
        data = typeof data === 'object' ? data : {};
        let result = new BudgetUpsertCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["handleType"] = this.handleType;
        return data; 
    }

    clone(): BudgetUpsertCommand {
        const json = this.toJSON();
        let result = new BudgetUpsertCommand();
        result.init(json);
        return result;
    }
}

export interface IBudgetUpsertCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: BudgetUpsertDto;
    handleType?: string | undefined;
}

export class BudgetUpsertDto implements IBudgetUpsertDto {
    id?: number;
    cycleId?: number;
    investmentType?: BudgetInvestmentType;
    zonesChanges?: BudgetZoneUpsertDtoCrudListDto;
    areasChanges?: BudgetAreaUpsertDtoCrudListDto;
    branchesChanges?: BudgetBranchUpsertDtoCrudListDto;

    constructor(data?: IBudgetUpsertDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.cycleId = _data["cycleId"];
            this.investmentType = _data["investmentType"];
            this.zonesChanges = _data["zonesChanges"] ? BudgetZoneUpsertDtoCrudListDto.fromJS(_data["zonesChanges"]) : <any>undefined;
            this.areasChanges = _data["areasChanges"] ? BudgetAreaUpsertDtoCrudListDto.fromJS(_data["areasChanges"]) : <any>undefined;
            this.branchesChanges = _data["branchesChanges"] ? BudgetBranchUpsertDtoCrudListDto.fromJS(_data["branchesChanges"]) : <any>undefined;
        }
    }

    static fromJS(data: any): BudgetUpsertDto {
        data = typeof data === 'object' ? data : {};
        let result = new BudgetUpsertDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["cycleId"] = this.cycleId;
        data["investmentType"] = this.investmentType;
        data["zonesChanges"] = this.zonesChanges ? this.zonesChanges.toJSON() : <any>undefined;
        data["areasChanges"] = this.areasChanges ? this.areasChanges.toJSON() : <any>undefined;
        data["branchesChanges"] = this.branchesChanges ? this.branchesChanges.toJSON() : <any>undefined;
        return data; 
    }

    clone(): BudgetUpsertDto {
        const json = this.toJSON();
        let result = new BudgetUpsertDto();
        result.init(json);
        return result;
    }
}

export interface IBudgetUpsertDto {
    id?: number;
    cycleId?: number;
    investmentType?: BudgetInvestmentType;
    zonesChanges?: BudgetZoneUpsertDtoCrudListDto;
    areasChanges?: BudgetAreaUpsertDtoCrudListDto;
    branchesChanges?: BudgetBranchUpsertDtoCrudListDto;
}

export class BudgetZoneDto implements IBudgetZoneDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    zoneId?: number;
    zoneCode?: string | undefined;
    zoneName?: string | undefined;
    salesOrgId?: number;
    parentSalesOrgId?: number;
    allocateAmount?: number;
    remainAmount?: number;
    usedAmount?: number;
    tempRemainAmount?: number;
    tempUsedAmount?: number;

    constructor(data?: IBudgetZoneDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.zoneId = _data["zoneId"];
            this.zoneCode = _data["zoneCode"];
            this.zoneName = _data["zoneName"];
            this.salesOrgId = _data["salesOrgId"];
            this.parentSalesOrgId = _data["parentSalesOrgId"];
            this.allocateAmount = _data["allocateAmount"];
            this.remainAmount = _data["remainAmount"];
            this.usedAmount = _data["usedAmount"];
            this.tempRemainAmount = _data["tempRemainAmount"];
            this.tempUsedAmount = _data["tempUsedAmount"];
        }
    }

    static fromJS(data: any): BudgetZoneDto {
        data = typeof data === 'object' ? data : {};
        let result = new BudgetZoneDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["zoneId"] = this.zoneId;
        data["zoneCode"] = this.zoneCode;
        data["zoneName"] = this.zoneName;
        data["salesOrgId"] = this.salesOrgId;
        data["parentSalesOrgId"] = this.parentSalesOrgId;
        data["allocateAmount"] = this.allocateAmount;
        data["remainAmount"] = this.remainAmount;
        data["usedAmount"] = this.usedAmount;
        data["tempRemainAmount"] = this.tempRemainAmount;
        data["tempUsedAmount"] = this.tempUsedAmount;
        return data; 
    }

    clone(): BudgetZoneDto {
        const json = this.toJSON();
        let result = new BudgetZoneDto();
        result.init(json);
        return result;
    }
}

export interface IBudgetZoneDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    zoneId?: number;
    zoneCode?: string | undefined;
    zoneName?: string | undefined;
    salesOrgId?: number;
    parentSalesOrgId?: number;
    allocateAmount?: number;
    remainAmount?: number;
    usedAmount?: number;
    tempRemainAmount?: number;
    tempUsedAmount?: number;
}

export class BudgetZoneUpsertDto implements IBudgetZoneUpsertDto {
    id?: number;
    zoneId?: number;
    zoneCode?: string | undefined;
    zoneName?: string | undefined;
    salesOrgId?: number;
    parentSalesOrgId?: number;
    allocateAmount?: number;
    remainAmount?: number;
    usedAmount?: number;

    constructor(data?: IBudgetZoneUpsertDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.zoneId = _data["zoneId"];
            this.zoneCode = _data["zoneCode"];
            this.zoneName = _data["zoneName"];
            this.salesOrgId = _data["salesOrgId"];
            this.parentSalesOrgId = _data["parentSalesOrgId"];
            this.allocateAmount = _data["allocateAmount"];
            this.remainAmount = _data["remainAmount"];
            this.usedAmount = _data["usedAmount"];
        }
    }

    static fromJS(data: any): BudgetZoneUpsertDto {
        data = typeof data === 'object' ? data : {};
        let result = new BudgetZoneUpsertDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["zoneId"] = this.zoneId;
        data["zoneCode"] = this.zoneCode;
        data["zoneName"] = this.zoneName;
        data["salesOrgId"] = this.salesOrgId;
        data["parentSalesOrgId"] = this.parentSalesOrgId;
        data["allocateAmount"] = this.allocateAmount;
        data["remainAmount"] = this.remainAmount;
        data["usedAmount"] = this.usedAmount;
        return data; 
    }

    clone(): BudgetZoneUpsertDto {
        const json = this.toJSON();
        let result = new BudgetZoneUpsertDto();
        result.init(json);
        return result;
    }
}

export interface IBudgetZoneUpsertDto {
    id?: number;
    zoneId?: number;
    zoneCode?: string | undefined;
    zoneName?: string | undefined;
    salesOrgId?: number;
    parentSalesOrgId?: number;
    allocateAmount?: number;
    remainAmount?: number;
    usedAmount?: number;
}

export class BudgetZoneUpsertDtoCrudListDto implements IBudgetZoneUpsertDtoCrudListDto {
    upsertedItems?: BudgetZoneUpsertDto[] | undefined;
    deletedItems?: BudgetZoneUpsertDto[] | undefined;

    constructor(data?: IBudgetZoneUpsertDtoCrudListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["upsertedItems"])) {
                this.upsertedItems = [] as any;
                for (let item of _data["upsertedItems"])
                    this.upsertedItems!.push(BudgetZoneUpsertDto.fromJS(item));
            }
            if (Array.isArray(_data["deletedItems"])) {
                this.deletedItems = [] as any;
                for (let item of _data["deletedItems"])
                    this.deletedItems!.push(BudgetZoneUpsertDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BudgetZoneUpsertDtoCrudListDto {
        data = typeof data === 'object' ? data : {};
        let result = new BudgetZoneUpsertDtoCrudListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.upsertedItems)) {
            data["upsertedItems"] = [];
            for (let item of this.upsertedItems)
                data["upsertedItems"].push(item.toJSON());
        }
        if (Array.isArray(this.deletedItems)) {
            data["deletedItems"] = [];
            for (let item of this.deletedItems)
                data["deletedItems"].push(item.toJSON());
        }
        return data; 
    }

    clone(): BudgetZoneUpsertDtoCrudListDto {
        const json = this.toJSON();
        let result = new BudgetZoneUpsertDtoCrudListDto();
        result.init(json);
        return result;
    }
}

export interface IBudgetZoneUpsertDtoCrudListDto {
    upsertedItems?: BudgetZoneUpsertDto[] | undefined;
    deletedItems?: BudgetZoneUpsertDto[] | undefined;
}

export class ChangeUserPasswordCommand implements IChangeUserPasswordCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    newPassword?: string | undefined;

    constructor(data?: IChangeUserPasswordCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ChangeUserPasswordCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUserPasswordCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["newPassword"] = this.newPassword;
        return data; 
    }

    clone(): ChangeUserPasswordCommand {
        const json = this.toJSON();
        let result = new ChangeUserPasswordCommand();
        result.init(json);
        return result;
    }
}

export interface IChangeUserPasswordCommand {
    commandId?: string;
    occuredDate?: Date;
    newPassword?: string | undefined;
}

export class ConsumerInfoDto implements IConsumerInfoDto {
    name?: string | undefined;
    phone?: string | undefined;

    constructor(data?: IConsumerInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.phone = _data["phone"];
        }
    }

    static fromJS(data: any): ConsumerInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConsumerInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["phone"] = this.phone;
        return data; 
    }

    clone(): ConsumerInfoDto {
        const json = this.toJSON();
        let result = new ConsumerInfoDto();
        result.init(json);
        return result;
    }
}

export interface IConsumerInfoDto {
    name?: string | undefined;
    phone?: string | undefined;
}

export class ConsumerInfoDtoApiResultObject implements IConsumerInfoDtoApiResultObject {
    result?: ConsumerInfoDto;
    success?: boolean;

    constructor(data?: IConsumerInfoDtoApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? ConsumerInfoDto.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): ConsumerInfoDtoApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new ConsumerInfoDtoApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data; 
    }

    clone(): ConsumerInfoDtoApiResultObject {
        const json = this.toJSON();
        let result = new ConsumerInfoDtoApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IConsumerInfoDtoApiResultObject {
    result?: ConsumerInfoDto;
    success?: boolean;
}

export class ConsumerRewardDetail implements IConsumerRewardDetail {
    id?: number;
    ticketId?: number;
    note?: string | undefined;

    constructor(data?: IConsumerRewardDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.ticketId = _data["ticketId"];
            this.note = _data["note"];
        }
    }

    static fromJS(data: any): ConsumerRewardDetail {
        data = typeof data === 'object' ? data : {};
        let result = new ConsumerRewardDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["ticketId"] = this.ticketId;
        data["note"] = this.note;
        return data; 
    }

    clone(): ConsumerRewardDetail {
        const json = this.toJSON();
        let result = new ConsumerRewardDetail();
        result.init(json);
        return result;
    }
}

export interface IConsumerRewardDetail {
    id?: number;
    ticketId?: number;
    note?: string | undefined;
}

export class ConsumerRewardDetailCrudListDto implements IConsumerRewardDetailCrudListDto {
    upsertedItems?: ConsumerRewardDetail[] | undefined;
    deletedItems?: ConsumerRewardDetail[] | undefined;

    constructor(data?: IConsumerRewardDetailCrudListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["upsertedItems"])) {
                this.upsertedItems = [] as any;
                for (let item of _data["upsertedItems"])
                    this.upsertedItems!.push(ConsumerRewardDetail.fromJS(item));
            }
            if (Array.isArray(_data["deletedItems"])) {
                this.deletedItems = [] as any;
                for (let item of _data["deletedItems"])
                    this.deletedItems!.push(ConsumerRewardDetail.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ConsumerRewardDetailCrudListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConsumerRewardDetailCrudListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.upsertedItems)) {
            data["upsertedItems"] = [];
            for (let item of this.upsertedItems)
                data["upsertedItems"].push(item.toJSON());
        }
        if (Array.isArray(this.deletedItems)) {
            data["deletedItems"] = [];
            for (let item of this.deletedItems)
                data["deletedItems"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ConsumerRewardDetailCrudListDto {
        const json = this.toJSON();
        let result = new ConsumerRewardDetailCrudListDto();
        result.init(json);
        return result;
    }
}

export interface IConsumerRewardDetailCrudListDto {
    upsertedItems?: ConsumerRewardDetail[] | undefined;
    deletedItems?: ConsumerRewardDetail[] | undefined;
}

export class ConsumerSendOtpCommand implements IConsumerSendOtpCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: ConsumerSendOtpDto;

    constructor(data?: IConsumerSendOtpCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? ConsumerSendOtpDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ConsumerSendOtpCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ConsumerSendOtpCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data; 
    }

    clone(): ConsumerSendOtpCommand {
        const json = this.toJSON();
        let result = new ConsumerSendOtpCommand();
        result.init(json);
        return result;
    }
}

export interface IConsumerSendOtpCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: ConsumerSendOtpDto;
}

export class ConsumerSendOtpDto implements IConsumerSendOtpDto {
    phone?: string | undefined;

    constructor(data?: IConsumerSendOtpDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.phone = _data["phone"];
        }
    }

    static fromJS(data: any): ConsumerSendOtpDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConsumerSendOtpDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["phone"] = this.phone;
        return data; 
    }

    clone(): ConsumerSendOtpDto {
        const json = this.toJSON();
        let result = new ConsumerSendOtpDto();
        result.init(json);
        return result;
    }
}

export interface IConsumerSendOtpDto {
    phone?: string | undefined;
}

export class ConsumerValidateOtpCommand implements IConsumerValidateOtpCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: ConsumerValidateOtpDto;

    constructor(data?: IConsumerValidateOtpCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? ConsumerValidateOtpDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ConsumerValidateOtpCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ConsumerValidateOtpCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data; 
    }

    clone(): ConsumerValidateOtpCommand {
        const json = this.toJSON();
        let result = new ConsumerValidateOtpCommand();
        result.init(json);
        return result;
    }
}

export interface IConsumerValidateOtpCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: ConsumerValidateOtpDto;
}

export class ConsumerValidateOtpDto implements IConsumerValidateOtpDto {
    phone?: string | undefined;
    otpCode?: string | undefined;

    constructor(data?: IConsumerValidateOtpDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.phone = _data["phone"];
            this.otpCode = _data["otpCode"];
        }
    }

    static fromJS(data: any): ConsumerValidateOtpDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConsumerValidateOtpDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["phone"] = this.phone;
        data["otpCode"] = this.otpCode;
        return data; 
    }

    clone(): ConsumerValidateOtpDto {
        const json = this.toJSON();
        let result = new ConsumerValidateOtpDto();
        result.init(json);
        return result;
    }
}

export interface IConsumerValidateOtpDto {
    phone?: string | undefined;
    otpCode?: string | undefined;
}

export class CustomerActivateKeyShopCommand implements ICustomerActivateKeyShopCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: CustomerActivateKeyShopDto;

    constructor(data?: ICustomerActivateKeyShopCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? CustomerActivateKeyShopDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CustomerActivateKeyShopCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerActivateKeyShopCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CustomerActivateKeyShopCommand {
        const json = this.toJSON();
        let result = new CustomerActivateKeyShopCommand();
        result.init(json);
        return result;
    }
}

export interface ICustomerActivateKeyShopCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: CustomerActivateKeyShopDto;
}

export class CustomerActivateKeyShopDto implements ICustomerActivateKeyShopDto {
    code?: string | undefined;
    otpCode?: string | undefined;
    password?: string | undefined;

    constructor(data?: ICustomerActivateKeyShopDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.otpCode = _data["otpCode"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): CustomerActivateKeyShopDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerActivateKeyShopDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["otpCode"] = this.otpCode;
        data["password"] = this.password;
        return data; 
    }

    clone(): CustomerActivateKeyShopDto {
        const json = this.toJSON();
        let result = new CustomerActivateKeyShopDto();
        result.init(json);
        return result;
    }
}

export interface ICustomerActivateKeyShopDto {
    code?: string | undefined;
    otpCode?: string | undefined;
    password?: string | undefined;
}

export class CustomerApproveKeyShopCommand implements ICustomerApproveKeyShopCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: number[] | undefined;

    constructor(data?: ICustomerApproveKeyShopCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(item);
            }
        }
    }

    static fromJS(data: any): CustomerApproveKeyShopCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerApproveKeyShopCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item);
        }
        return data; 
    }

    clone(): CustomerApproveKeyShopCommand {
        const json = this.toJSON();
        let result = new CustomerApproveKeyShopCommand();
        result.init(json);
        return result;
    }
}

export interface ICustomerApproveKeyShopCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: number[] | undefined;
}

export class CustomerApproveKeyShopListDto implements ICustomerApproveKeyShopListDto {
    id?: string | undefined;
    isSelected?: boolean;
    code?: string | undefined;
    name?: string | undefined;
    mobilePhone?: string | undefined;
    birthday?: Date | undefined;
    address?: string | undefined;
    keyShopStatus?: number;
    keyShopRegisterStaffId?: number;
    staffName?: string | undefined;
    channelCode?: string | undefined;
    channelName?: string | undefined;
    email?: string | undefined;
    keyShopAuthCode?: string | undefined;
    zoneId?: number;
    areaId?: number;

    constructor(data?: ICustomerApproveKeyShopListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.isSelected = _data["isSelected"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.mobilePhone = _data["mobilePhone"];
            this.birthday = _data["birthday"] ? new Date(_data["birthday"].toString()) : <any>undefined;
            this.address = _data["address"];
            this.keyShopStatus = _data["keyShopStatus"];
            this.keyShopRegisterStaffId = _data["keyShopRegisterStaffId"];
            this.staffName = _data["staffName"];
            this.channelCode = _data["channelCode"];
            this.channelName = _data["channelName"];
            this.email = _data["email"];
            this.keyShopAuthCode = _data["keyShopAuthCode"];
            this.zoneId = _data["zoneId"];
            this.areaId = _data["areaId"];
        }
    }

    static fromJS(data: any): CustomerApproveKeyShopListDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerApproveKeyShopListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["isSelected"] = this.isSelected;
        data["code"] = this.code;
        data["name"] = this.name;
        data["mobilePhone"] = this.mobilePhone;
        data["birthday"] = this.birthday ? this.birthday.toISOString() : <any>undefined;
        data["address"] = this.address;
        data["keyShopStatus"] = this.keyShopStatus;
        data["keyShopRegisterStaffId"] = this.keyShopRegisterStaffId;
        data["staffName"] = this.staffName;
        data["channelCode"] = this.channelCode;
        data["channelName"] = this.channelName;
        data["email"] = this.email;
        data["keyShopAuthCode"] = this.keyShopAuthCode;
        data["zoneId"] = this.zoneId;
        data["areaId"] = this.areaId;
        return data; 
    }

    clone(): CustomerApproveKeyShopListDto {
        const json = this.toJSON();
        let result = new CustomerApproveKeyShopListDto();
        result.init(json);
        return result;
    }
}

export interface ICustomerApproveKeyShopListDto {
    id?: string | undefined;
    isSelected?: boolean;
    code?: string | undefined;
    name?: string | undefined;
    mobilePhone?: string | undefined;
    birthday?: Date | undefined;
    address?: string | undefined;
    keyShopStatus?: number;
    keyShopRegisterStaffId?: number;
    staffName?: string | undefined;
    channelCode?: string | undefined;
    channelName?: string | undefined;
    email?: string | undefined;
    keyShopAuthCode?: string | undefined;
    zoneId?: number;
    areaId?: number;
}

export class CustomerApproveKeyShopListDtoPagingResult implements ICustomerApproveKeyShopListDtoPagingResult {
    items?: CustomerApproveKeyShopListDto[] | undefined;
    totalCount?: number;

    constructor(data?: ICustomerApproveKeyShopListDtoPagingResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CustomerApproveKeyShopListDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): CustomerApproveKeyShopListDtoPagingResult {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerApproveKeyShopListDtoPagingResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): CustomerApproveKeyShopListDtoPagingResult {
        const json = this.toJSON();
        let result = new CustomerApproveKeyShopListDtoPagingResult();
        result.init(json);
        return result;
    }
}

export interface ICustomerApproveKeyShopListDtoPagingResult {
    items?: CustomerApproveKeyShopListDto[] | undefined;
    totalCount?: number;
}

export class CustomerApproveKeyShopListDtoPagingResultApiResultObject implements ICustomerApproveKeyShopListDtoPagingResultApiResultObject {
    result?: CustomerApproveKeyShopListDtoPagingResult;
    success?: boolean;

    constructor(data?: ICustomerApproveKeyShopListDtoPagingResultApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? CustomerApproveKeyShopListDtoPagingResult.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): CustomerApproveKeyShopListDtoPagingResultApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerApproveKeyShopListDtoPagingResultApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data; 
    }

    clone(): CustomerApproveKeyShopListDtoPagingResultApiResultObject {
        const json = this.toJSON();
        let result = new CustomerApproveKeyShopListDtoPagingResultApiResultObject();
        result.init(json);
        return result;
    }
}

export interface ICustomerApproveKeyShopListDtoPagingResultApiResultObject {
    result?: CustomerApproveKeyShopListDtoPagingResult;
    success?: boolean;
}

export class CustomerByStaffListDto implements ICustomerByStaffListDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    branchId?: number | undefined;
    contactName?: string | undefined;
    mobilePhone?: string | undefined;
    phone?: string | undefined;
    email?: string | undefined;
    channelCode?: string | undefined;
    channelName?: string | undefined;
    houseNumber?: string | undefined;
    street?: string | undefined;
    address?: string | undefined;
    wardId?: number | undefined;
    districtId?: number | undefined;
    provinceId?: number | undefined;
    isActive?: boolean;
    lat?: number;
    lng?: number;
    birthday?: Date | undefined;
    userId?: number | undefined;
    isKeyShop?: boolean;
    isAllowKeyShopRegister?: boolean;
    keyShopStatus?: number;
    keyShopAuthCode?: string | undefined;
    salesSupervisorStaffId?: number | undefined;
    areaId?: number | undefined;
    zoneId?: number | undefined;
    efficient?: number | undefined;
    rsmStaffId?: number | undefined;
    asmStaffId?: number | undefined;
    zoneName?: string | undefined;
    areaName?: string | undefined;
    wardName?: string | undefined;
    districtName?: string | undefined;
    provinceName?: string | undefined;
    salesSupervisorStaffCode?: string | undefined;
    salesSupervisorStaffName?: string | undefined;

    constructor(data?: ICustomerByStaffListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.branchId = _data["branchId"];
            this.contactName = _data["contactName"];
            this.mobilePhone = _data["mobilePhone"];
            this.phone = _data["phone"];
            this.email = _data["email"];
            this.channelCode = _data["channelCode"];
            this.channelName = _data["channelName"];
            this.houseNumber = _data["houseNumber"];
            this.street = _data["street"];
            this.address = _data["address"];
            this.wardId = _data["wardId"];
            this.districtId = _data["districtId"];
            this.provinceId = _data["provinceId"];
            this.isActive = _data["isActive"];
            this.lat = _data["lat"];
            this.lng = _data["lng"];
            this.birthday = _data["birthday"] ? new Date(_data["birthday"].toString()) : <any>undefined;
            this.userId = _data["userId"];
            this.isKeyShop = _data["isKeyShop"];
            this.isAllowKeyShopRegister = _data["isAllowKeyShopRegister"];
            this.keyShopStatus = _data["keyShopStatus"];
            this.keyShopAuthCode = _data["keyShopAuthCode"];
            this.salesSupervisorStaffId = _data["salesSupervisorStaffId"];
            this.areaId = _data["areaId"];
            this.zoneId = _data["zoneId"];
            this.efficient = _data["efficient"];
            this.rsmStaffId = _data["rsmStaffId"];
            this.asmStaffId = _data["asmStaffId"];
            this.zoneName = _data["zoneName"];
            this.areaName = _data["areaName"];
            this.wardName = _data["wardName"];
            this.districtName = _data["districtName"];
            this.provinceName = _data["provinceName"];
            this.salesSupervisorStaffCode = _data["salesSupervisorStaffCode"];
            this.salesSupervisorStaffName = _data["salesSupervisorStaffName"];
        }
    }

    static fromJS(data: any): CustomerByStaffListDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerByStaffListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["branchId"] = this.branchId;
        data["contactName"] = this.contactName;
        data["mobilePhone"] = this.mobilePhone;
        data["phone"] = this.phone;
        data["email"] = this.email;
        data["channelCode"] = this.channelCode;
        data["channelName"] = this.channelName;
        data["houseNumber"] = this.houseNumber;
        data["street"] = this.street;
        data["address"] = this.address;
        data["wardId"] = this.wardId;
        data["districtId"] = this.districtId;
        data["provinceId"] = this.provinceId;
        data["isActive"] = this.isActive;
        data["lat"] = this.lat;
        data["lng"] = this.lng;
        data["birthday"] = this.birthday ? this.birthday.toISOString() : <any>undefined;
        data["userId"] = this.userId;
        data["isKeyShop"] = this.isKeyShop;
        data["isAllowKeyShopRegister"] = this.isAllowKeyShopRegister;
        data["keyShopStatus"] = this.keyShopStatus;
        data["keyShopAuthCode"] = this.keyShopAuthCode;
        data["salesSupervisorStaffId"] = this.salesSupervisorStaffId;
        data["areaId"] = this.areaId;
        data["zoneId"] = this.zoneId;
        data["efficient"] = this.efficient;
        data["rsmStaffId"] = this.rsmStaffId;
        data["asmStaffId"] = this.asmStaffId;
        data["zoneName"] = this.zoneName;
        data["areaName"] = this.areaName;
        data["wardName"] = this.wardName;
        data["districtName"] = this.districtName;
        data["provinceName"] = this.provinceName;
        data["salesSupervisorStaffCode"] = this.salesSupervisorStaffCode;
        data["salesSupervisorStaffName"] = this.salesSupervisorStaffName;
        return data; 
    }

    clone(): CustomerByStaffListDto {
        const json = this.toJSON();
        let result = new CustomerByStaffListDto();
        result.init(json);
        return result;
    }
}

export interface ICustomerByStaffListDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    branchId?: number | undefined;
    contactName?: string | undefined;
    mobilePhone?: string | undefined;
    phone?: string | undefined;
    email?: string | undefined;
    channelCode?: string | undefined;
    channelName?: string | undefined;
    houseNumber?: string | undefined;
    street?: string | undefined;
    address?: string | undefined;
    wardId?: number | undefined;
    districtId?: number | undefined;
    provinceId?: number | undefined;
    isActive?: boolean;
    lat?: number;
    lng?: number;
    birthday?: Date | undefined;
    userId?: number | undefined;
    isKeyShop?: boolean;
    isAllowKeyShopRegister?: boolean;
    keyShopStatus?: number;
    keyShopAuthCode?: string | undefined;
    salesSupervisorStaffId?: number | undefined;
    areaId?: number | undefined;
    zoneId?: number | undefined;
    efficient?: number | undefined;
    rsmStaffId?: number | undefined;
    asmStaffId?: number | undefined;
    zoneName?: string | undefined;
    areaName?: string | undefined;
    wardName?: string | undefined;
    districtName?: string | undefined;
    provinceName?: string | undefined;
    salesSupervisorStaffCode?: string | undefined;
    salesSupervisorStaffName?: string | undefined;
}

export class CustomerByStaffListDtoPagingResult implements ICustomerByStaffListDtoPagingResult {
    items?: CustomerByStaffListDto[] | undefined;
    totalCount?: number;

    constructor(data?: ICustomerByStaffListDtoPagingResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CustomerByStaffListDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): CustomerByStaffListDtoPagingResult {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerByStaffListDtoPagingResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): CustomerByStaffListDtoPagingResult {
        const json = this.toJSON();
        let result = new CustomerByStaffListDtoPagingResult();
        result.init(json);
        return result;
    }
}

export interface ICustomerByStaffListDtoPagingResult {
    items?: CustomerByStaffListDto[] | undefined;
    totalCount?: number;
}

export class CustomerByStaffListDtoPagingResultApiResultObject implements ICustomerByStaffListDtoPagingResultApiResultObject {
    result?: CustomerByStaffListDtoPagingResult;
    success?: boolean;

    constructor(data?: ICustomerByStaffListDtoPagingResultApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? CustomerByStaffListDtoPagingResult.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): CustomerByStaffListDtoPagingResultApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerByStaffListDtoPagingResultApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data; 
    }

    clone(): CustomerByStaffListDtoPagingResultApiResultObject {
        const json = this.toJSON();
        let result = new CustomerByStaffListDtoPagingResultApiResultObject();
        result.init(json);
        return result;
    }
}

export interface ICustomerByStaffListDtoPagingResultApiResultObject {
    result?: CustomerByStaffListDtoPagingResult;
    success?: boolean;
}

export class CustomerCheckOtpCommand implements ICustomerCheckOtpCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: CustomerCheckOtpDto;

    constructor(data?: ICustomerCheckOtpCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? CustomerCheckOtpDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CustomerCheckOtpCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerCheckOtpCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CustomerCheckOtpCommand {
        const json = this.toJSON();
        let result = new CustomerCheckOtpCommand();
        result.init(json);
        return result;
    }
}

export interface ICustomerCheckOtpCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: CustomerCheckOtpDto;
}

export class CustomerCheckOtpDto implements ICustomerCheckOtpDto {
    mobilePhone?: string | undefined;
    otpCode?: string | undefined;

    constructor(data?: ICustomerCheckOtpDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.mobilePhone = _data["mobilePhone"];
            this.otpCode = _data["otpCode"];
        }
    }

    static fromJS(data: any): CustomerCheckOtpDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerCheckOtpDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mobilePhone"] = this.mobilePhone;
        data["otpCode"] = this.otpCode;
        return data; 
    }

    clone(): CustomerCheckOtpDto {
        const json = this.toJSON();
        let result = new CustomerCheckOtpDto();
        result.init(json);
        return result;
    }
}

export interface ICustomerCheckOtpDto {
    mobilePhone?: string | undefined;
    otpCode?: string | undefined;
}

export class CustomerDto implements ICustomerDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    branchId?: number | undefined;
    contactName?: string | undefined;
    mobilePhone?: string | undefined;
    phone?: string | undefined;
    email?: string | undefined;
    channelCode?: string | undefined;
    channelName?: string | undefined;
    houseNumber?: string | undefined;
    street?: string | undefined;
    address?: string | undefined;
    wardId?: number | undefined;
    districtId?: number | undefined;
    provinceId?: number | undefined;
    isActive?: boolean;
    lat?: number;
    lng?: number;
    birthday?: Date | undefined;
    userId?: number | undefined;
    isKeyShop?: boolean;
    isAllowKeyShopRegister?: boolean;
    keyShopStatus?: number;
    keyShopAuthCode?: string | undefined;
    salesSupervisorStaffId?: number | undefined;
    areaId?: number | undefined;
    zoneId?: number | undefined;
    efficient?: number | undefined;
    rsmStaffId?: number | undefined;
    asmStaffId?: number | undefined;

    constructor(data?: ICustomerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.branchId = _data["branchId"];
            this.contactName = _data["contactName"];
            this.mobilePhone = _data["mobilePhone"];
            this.phone = _data["phone"];
            this.email = _data["email"];
            this.channelCode = _data["channelCode"];
            this.channelName = _data["channelName"];
            this.houseNumber = _data["houseNumber"];
            this.street = _data["street"];
            this.address = _data["address"];
            this.wardId = _data["wardId"];
            this.districtId = _data["districtId"];
            this.provinceId = _data["provinceId"];
            this.isActive = _data["isActive"];
            this.lat = _data["lat"];
            this.lng = _data["lng"];
            this.birthday = _data["birthday"] ? new Date(_data["birthday"].toString()) : <any>undefined;
            this.userId = _data["userId"];
            this.isKeyShop = _data["isKeyShop"];
            this.isAllowKeyShopRegister = _data["isAllowKeyShopRegister"];
            this.keyShopStatus = _data["keyShopStatus"];
            this.keyShopAuthCode = _data["keyShopAuthCode"];
            this.salesSupervisorStaffId = _data["salesSupervisorStaffId"];
            this.areaId = _data["areaId"];
            this.zoneId = _data["zoneId"];
            this.efficient = _data["efficient"];
            this.rsmStaffId = _data["rsmStaffId"];
            this.asmStaffId = _data["asmStaffId"];
        }
    }

    static fromJS(data: any): CustomerDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["branchId"] = this.branchId;
        data["contactName"] = this.contactName;
        data["mobilePhone"] = this.mobilePhone;
        data["phone"] = this.phone;
        data["email"] = this.email;
        data["channelCode"] = this.channelCode;
        data["channelName"] = this.channelName;
        data["houseNumber"] = this.houseNumber;
        data["street"] = this.street;
        data["address"] = this.address;
        data["wardId"] = this.wardId;
        data["districtId"] = this.districtId;
        data["provinceId"] = this.provinceId;
        data["isActive"] = this.isActive;
        data["lat"] = this.lat;
        data["lng"] = this.lng;
        data["birthday"] = this.birthday ? this.birthday.toISOString() : <any>undefined;
        data["userId"] = this.userId;
        data["isKeyShop"] = this.isKeyShop;
        data["isAllowKeyShopRegister"] = this.isAllowKeyShopRegister;
        data["keyShopStatus"] = this.keyShopStatus;
        data["keyShopAuthCode"] = this.keyShopAuthCode;
        data["salesSupervisorStaffId"] = this.salesSupervisorStaffId;
        data["areaId"] = this.areaId;
        data["zoneId"] = this.zoneId;
        data["efficient"] = this.efficient;
        data["rsmStaffId"] = this.rsmStaffId;
        data["asmStaffId"] = this.asmStaffId;
        return data; 
    }

    clone(): CustomerDto {
        const json = this.toJSON();
        let result = new CustomerDto();
        result.init(json);
        return result;
    }
}

export interface ICustomerDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    branchId?: number | undefined;
    contactName?: string | undefined;
    mobilePhone?: string | undefined;
    phone?: string | undefined;
    email?: string | undefined;
    channelCode?: string | undefined;
    channelName?: string | undefined;
    houseNumber?: string | undefined;
    street?: string | undefined;
    address?: string | undefined;
    wardId?: number | undefined;
    districtId?: number | undefined;
    provinceId?: number | undefined;
    isActive?: boolean;
    lat?: number;
    lng?: number;
    birthday?: Date | undefined;
    userId?: number | undefined;
    isKeyShop?: boolean;
    isAllowKeyShopRegister?: boolean;
    keyShopStatus?: number;
    keyShopAuthCode?: string | undefined;
    salesSupervisorStaffId?: number | undefined;
    areaId?: number | undefined;
    zoneId?: number | undefined;
    efficient?: number | undefined;
    rsmStaffId?: number | undefined;
    asmStaffId?: number | undefined;
}

export class CustomerDtoApiResultObject implements ICustomerDtoApiResultObject {
    result?: CustomerDto;
    success?: boolean;

    constructor(data?: ICustomerDtoApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? CustomerDto.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): CustomerDtoApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerDtoApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data; 
    }

    clone(): CustomerDtoApiResultObject {
        const json = this.toJSON();
        let result = new CustomerDtoApiResultObject();
        result.init(json);
        return result;
    }
}

export interface ICustomerDtoApiResultObject {
    result?: CustomerDto;
    success?: boolean;
}

export class CustomerDtoPagingResult implements ICustomerDtoPagingResult {
    items?: CustomerDto[] | undefined;
    totalCount?: number;

    constructor(data?: ICustomerDtoPagingResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CustomerDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): CustomerDtoPagingResult {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerDtoPagingResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): CustomerDtoPagingResult {
        const json = this.toJSON();
        let result = new CustomerDtoPagingResult();
        result.init(json);
        return result;
    }
}

export interface ICustomerDtoPagingResult {
    items?: CustomerDto[] | undefined;
    totalCount?: number;
}

export class CustomerDtoPagingResultApiResultObject implements ICustomerDtoPagingResultApiResultObject {
    result?: CustomerDtoPagingResult;
    success?: boolean;

    constructor(data?: ICustomerDtoPagingResultApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? CustomerDtoPagingResult.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): CustomerDtoPagingResultApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerDtoPagingResultApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data; 
    }

    clone(): CustomerDtoPagingResultApiResultObject {
        const json = this.toJSON();
        let result = new CustomerDtoPagingResultApiResultObject();
        result.init(json);
        return result;
    }
}

export interface ICustomerDtoPagingResultApiResultObject {
    result?: CustomerDtoPagingResult;
    success?: boolean;
}

export class CustomerRecentSalesDto implements ICustomerRecentSalesDto {
    monthData?: MonthData[] | undefined;
    yearData?: YearData[] | undefined;

    constructor(data?: ICustomerRecentSalesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["monthData"])) {
                this.monthData = [] as any;
                for (let item of _data["monthData"])
                    this.monthData!.push(MonthData.fromJS(item));
            }
            if (Array.isArray(_data["yearData"])) {
                this.yearData = [] as any;
                for (let item of _data["yearData"])
                    this.yearData!.push(YearData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CustomerRecentSalesDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerRecentSalesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.monthData)) {
            data["monthData"] = [];
            for (let item of this.monthData)
                data["monthData"].push(item.toJSON());
        }
        if (Array.isArray(this.yearData)) {
            data["yearData"] = [];
            for (let item of this.yearData)
                data["yearData"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CustomerRecentSalesDto {
        const json = this.toJSON();
        let result = new CustomerRecentSalesDto();
        result.init(json);
        return result;
    }
}

export interface ICustomerRecentSalesDto {
    monthData?: MonthData[] | undefined;
    yearData?: YearData[] | undefined;
}

export class CustomerRecentSalesDtoApiResultObject implements ICustomerRecentSalesDtoApiResultObject {
    result?: CustomerRecentSalesDto;
    success?: boolean;

    constructor(data?: ICustomerRecentSalesDtoApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? CustomerRecentSalesDto.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): CustomerRecentSalesDtoApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerRecentSalesDtoApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data; 
    }

    clone(): CustomerRecentSalesDtoApiResultObject {
        const json = this.toJSON();
        let result = new CustomerRecentSalesDtoApiResultObject();
        result.init(json);
        return result;
    }
}

export interface ICustomerRecentSalesDtoApiResultObject {
    result?: CustomerRecentSalesDto;
    success?: boolean;
}

export class CustomerRefuseKeyShopCommand implements ICustomerRefuseKeyShopCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: number[] | undefined;

    constructor(data?: ICustomerRefuseKeyShopCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(item);
            }
        }
    }

    static fromJS(data: any): CustomerRefuseKeyShopCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerRefuseKeyShopCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item);
        }
        return data; 
    }

    clone(): CustomerRefuseKeyShopCommand {
        const json = this.toJSON();
        let result = new CustomerRefuseKeyShopCommand();
        result.init(json);
        return result;
    }
}

export interface ICustomerRefuseKeyShopCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: number[] | undefined;
}

export class CustomerRegisterKeyShopCommand implements ICustomerRegisterKeyShopCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: number[] | undefined;

    constructor(data?: ICustomerRegisterKeyShopCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(item);
            }
        }
    }

    static fromJS(data: any): CustomerRegisterKeyShopCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerRegisterKeyShopCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item);
        }
        return data; 
    }

    clone(): CustomerRegisterKeyShopCommand {
        const json = this.toJSON();
        let result = new CustomerRegisterKeyShopCommand();
        result.init(json);
        return result;
    }
}

export interface ICustomerRegisterKeyShopCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: number[] | undefined;
}

export class CustomerResetPasswordCommand implements ICustomerResetPasswordCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: CustomerResetPasswordDto;

    constructor(data?: ICustomerResetPasswordCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? CustomerResetPasswordDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CustomerResetPasswordCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerResetPasswordCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CustomerResetPasswordCommand {
        const json = this.toJSON();
        let result = new CustomerResetPasswordCommand();
        result.init(json);
        return result;
    }
}

export interface ICustomerResetPasswordCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: CustomerResetPasswordDto;
}

export class CustomerResetPasswordDto implements ICustomerResetPasswordDto {
    newPassword?: string | undefined;
    mobilePhone?: string | undefined;
    otpCode?: string | undefined;

    constructor(data?: ICustomerResetPasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.newPassword = _data["newPassword"];
            this.mobilePhone = _data["mobilePhone"];
            this.otpCode = _data["otpCode"];
        }
    }

    static fromJS(data: any): CustomerResetPasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerResetPasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["newPassword"] = this.newPassword;
        data["mobilePhone"] = this.mobilePhone;
        data["otpCode"] = this.otpCode;
        return data; 
    }

    clone(): CustomerResetPasswordDto {
        const json = this.toJSON();
        let result = new CustomerResetPasswordDto();
        result.init(json);
        return result;
    }
}

export interface ICustomerResetPasswordDto {
    newPassword?: string | undefined;
    mobilePhone?: string | undefined;
    otpCode?: string | undefined;
}

export class CustomerSalesItemCreateCommand implements ICustomerSalesItemCreateCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: CustomerSalesItemCreateDto;

    constructor(data?: ICustomerSalesItemCreateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? CustomerSalesItemCreateDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CustomerSalesItemCreateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerSalesItemCreateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CustomerSalesItemCreateCommand {
        const json = this.toJSON();
        let result = new CustomerSalesItemCreateCommand();
        result.init(json);
        return result;
    }
}

export interface ICustomerSalesItemCreateCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: CustomerSalesItemCreateDto;
}

export class CustomerSalesItemCreateDto implements ICustomerSalesItemCreateDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    qrCode?: string | undefined;

    constructor(data?: ICustomerSalesItemCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.qrCode = _data["qrCode"];
        }
    }

    static fromJS(data: any): CustomerSalesItemCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerSalesItemCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["qrCode"] = this.qrCode;
        return data; 
    }

    clone(): CustomerSalesItemCreateDto {
        const json = this.toJSON();
        let result = new CustomerSalesItemCreateDto();
        result.init(json);
        return result;
    }
}

export interface ICustomerSalesItemCreateDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    qrCode?: string | undefined;
}

export class CustomerValidateActivationKeyShopCommand implements ICustomerValidateActivationKeyShopCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: CustomerValidateActivationKeyShopDto;

    constructor(data?: ICustomerValidateActivationKeyShopCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? CustomerValidateActivationKeyShopDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CustomerValidateActivationKeyShopCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerValidateActivationKeyShopCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CustomerValidateActivationKeyShopCommand {
        const json = this.toJSON();
        let result = new CustomerValidateActivationKeyShopCommand();
        result.init(json);
        return result;
    }
}

export interface ICustomerValidateActivationKeyShopCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: CustomerValidateActivationKeyShopDto;
}

export class CustomerValidateActivationKeyShopDto implements ICustomerValidateActivationKeyShopDto {
    code?: string | undefined;
    name?: string | undefined;
    authCode?: string | undefined;
    mobilePhone?: string | undefined;
    birthday?: Date;

    constructor(data?: ICustomerValidateActivationKeyShopDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.name = _data["name"];
            this.authCode = _data["authCode"];
            this.mobilePhone = _data["mobilePhone"];
            this.birthday = _data["birthday"] ? new Date(_data["birthday"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CustomerValidateActivationKeyShopDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerValidateActivationKeyShopDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["authCode"] = this.authCode;
        data["mobilePhone"] = this.mobilePhone;
        data["birthday"] = this.birthday ? this.birthday.toISOString() : <any>undefined;
        return data; 
    }

    clone(): CustomerValidateActivationKeyShopDto {
        const json = this.toJSON();
        let result = new CustomerValidateActivationKeyShopDto();
        result.init(json);
        return result;
    }
}

export interface ICustomerValidateActivationKeyShopDto {
    code?: string | undefined;
    name?: string | undefined;
    authCode?: string | undefined;
    mobilePhone?: string | undefined;
    birthday?: Date;
}

export class CustomerValidateRecoveryPasswordCommand implements ICustomerValidateRecoveryPasswordCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: CustomerValidateRecoveryPasswordDto;

    constructor(data?: ICustomerValidateRecoveryPasswordCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? CustomerValidateRecoveryPasswordDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CustomerValidateRecoveryPasswordCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerValidateRecoveryPasswordCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CustomerValidateRecoveryPasswordCommand {
        const json = this.toJSON();
        let result = new CustomerValidateRecoveryPasswordCommand();
        result.init(json);
        return result;
    }
}

export interface ICustomerValidateRecoveryPasswordCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: CustomerValidateRecoveryPasswordDto;
}

export class CustomerValidateRecoveryPasswordDto implements ICustomerValidateRecoveryPasswordDto {
    mobilePhone?: string | undefined;

    constructor(data?: ICustomerValidateRecoveryPasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.mobilePhone = _data["mobilePhone"];
        }
    }

    static fromJS(data: any): CustomerValidateRecoveryPasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerValidateRecoveryPasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mobilePhone"] = this.mobilePhone;
        return data; 
    }

    clone(): CustomerValidateRecoveryPasswordDto {
        const json = this.toJSON();
        let result = new CustomerValidateRecoveryPasswordDto();
        result.init(json);
        return result;
    }
}

export interface ICustomerValidateRecoveryPasswordDto {
    mobilePhone?: string | undefined;
}

export class CycleDto implements ICycleDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    number?: string | undefined;
    year?: number;
    isActive?: boolean;
    fromDate?: Date;
    toDate?: Date;

    constructor(data?: ICycleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.number = _data["number"];
            this.year = _data["year"];
            this.isActive = _data["isActive"];
            this.fromDate = _data["fromDate"] ? new Date(_data["fromDate"].toString()) : <any>undefined;
            this.toDate = _data["toDate"] ? new Date(_data["toDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CycleDto {
        data = typeof data === 'object' ? data : {};
        let result = new CycleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["number"] = this.number;
        data["year"] = this.year;
        data["isActive"] = this.isActive;
        data["fromDate"] = this.fromDate ? this.fromDate.toISOString() : <any>undefined;
        data["toDate"] = this.toDate ? this.toDate.toISOString() : <any>undefined;
        return data; 
    }

    clone(): CycleDto {
        const json = this.toJSON();
        let result = new CycleDto();
        result.init(json);
        return result;
    }
}

export interface ICycleDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    number?: string | undefined;
    year?: number;
    isActive?: boolean;
    fromDate?: Date;
    toDate?: Date;
}

export class CycleDtoApiResultObject implements ICycleDtoApiResultObject {
    result?: CycleDto;
    success?: boolean;

    constructor(data?: ICycleDtoApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? CycleDto.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): CycleDtoApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new CycleDtoApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data; 
    }

    clone(): CycleDtoApiResultObject {
        const json = this.toJSON();
        let result = new CycleDtoApiResultObject();
        result.init(json);
        return result;
    }
}

export interface ICycleDtoApiResultObject {
    result?: CycleDto;
    success?: boolean;
}

export class CycleDtoPagingResult implements ICycleDtoPagingResult {
    items?: CycleDto[] | undefined;
    totalCount?: number;

    constructor(data?: ICycleDtoPagingResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CycleDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): CycleDtoPagingResult {
        data = typeof data === 'object' ? data : {};
        let result = new CycleDtoPagingResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): CycleDtoPagingResult {
        const json = this.toJSON();
        let result = new CycleDtoPagingResult();
        result.init(json);
        return result;
    }
}

export interface ICycleDtoPagingResult {
    items?: CycleDto[] | undefined;
    totalCount?: number;
}

export class CycleDtoPagingResultApiResultObject implements ICycleDtoPagingResultApiResultObject {
    result?: CycleDtoPagingResult;
    success?: boolean;

    constructor(data?: ICycleDtoPagingResultApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? CycleDtoPagingResult.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): CycleDtoPagingResultApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new CycleDtoPagingResultApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data; 
    }

    clone(): CycleDtoPagingResultApiResultObject {
        const json = this.toJSON();
        let result = new CycleDtoPagingResultApiResultObject();
        result.init(json);
        return result;
    }
}

export interface ICycleDtoPagingResultApiResultObject {
    result?: CycleDtoPagingResult;
    success?: boolean;
}

export class DistrictDto implements IDistrictDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    provinceId?: number;

    constructor(data?: IDistrictDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.provinceId = _data["provinceId"];
        }
    }

    static fromJS(data: any): DistrictDto {
        data = typeof data === 'object' ? data : {};
        let result = new DistrictDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["provinceId"] = this.provinceId;
        return data; 
    }

    clone(): DistrictDto {
        const json = this.toJSON();
        let result = new DistrictDto();
        result.init(json);
        return result;
    }
}

export interface IDistrictDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    provinceId?: number;
}

export class DistrictDtoApiResultObject implements IDistrictDtoApiResultObject {
    result?: DistrictDto;
    success?: boolean;

    constructor(data?: IDistrictDtoApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? DistrictDto.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): DistrictDtoApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new DistrictDtoApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data; 
    }

    clone(): DistrictDtoApiResultObject {
        const json = this.toJSON();
        let result = new DistrictDtoApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IDistrictDtoApiResultObject {
    result?: DistrictDto;
    success?: boolean;
}

export class DistrictListDto implements IDistrictListDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    provinceCode?: string | undefined;
    provinceName?: string | undefined;
    provinceId?: number;

    constructor(data?: IDistrictListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.provinceCode = _data["provinceCode"];
            this.provinceName = _data["provinceName"];
            this.provinceId = _data["provinceId"];
        }
    }

    static fromJS(data: any): DistrictListDto {
        data = typeof data === 'object' ? data : {};
        let result = new DistrictListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["provinceCode"] = this.provinceCode;
        data["provinceName"] = this.provinceName;
        data["provinceId"] = this.provinceId;
        return data; 
    }

    clone(): DistrictListDto {
        const json = this.toJSON();
        let result = new DistrictListDto();
        result.init(json);
        return result;
    }
}

export interface IDistrictListDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    provinceCode?: string | undefined;
    provinceName?: string | undefined;
    provinceId?: number;
}

export class DistrictListDtoPagingResult implements IDistrictListDtoPagingResult {
    items?: DistrictListDto[] | undefined;
    totalCount?: number;

    constructor(data?: IDistrictListDtoPagingResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(DistrictListDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): DistrictListDtoPagingResult {
        data = typeof data === 'object' ? data : {};
        let result = new DistrictListDtoPagingResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): DistrictListDtoPagingResult {
        const json = this.toJSON();
        let result = new DistrictListDtoPagingResult();
        result.init(json);
        return result;
    }
}

export interface IDistrictListDtoPagingResult {
    items?: DistrictListDto[] | undefined;
    totalCount?: number;
}

export class DistrictListDtoPagingResultApiResultObject implements IDistrictListDtoPagingResultApiResultObject {
    result?: DistrictListDtoPagingResult;
    success?: boolean;

    constructor(data?: IDistrictListDtoPagingResultApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? DistrictListDtoPagingResult.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): DistrictListDtoPagingResultApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new DistrictListDtoPagingResultApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data; 
    }

    clone(): DistrictListDtoPagingResultApiResultObject {
        const json = this.toJSON();
        let result = new DistrictListDtoPagingResultApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IDistrictListDtoPagingResultApiResultObject {
    result?: DistrictListDtoPagingResult;
    success?: boolean;
}

export class Int32ApiResultObject implements IInt32ApiResultObject {
    result?: number;
    success?: boolean;

    constructor(data?: IInt32ApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"];
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): Int32ApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new Int32ApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result;
        data["success"] = this.success;
        return data; 
    }

    clone(): Int32ApiResultObject {
        const json = this.toJSON();
        let result = new Int32ApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IInt32ApiResultObject {
    result?: number;
    success?: boolean;
}

export class InvestmentAccumulateDto implements IInvestmentAccumulateDto {
    holdingQuantity?: number;
    approvedQuantity?: number;
    requestQuantity?: number;

    constructor(data?: IInvestmentAccumulateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.holdingQuantity = _data["holdingQuantity"];
            this.approvedQuantity = _data["approvedQuantity"];
            this.requestQuantity = _data["requestQuantity"];
        }
    }

    static fromJS(data: any): InvestmentAccumulateDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvestmentAccumulateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["holdingQuantity"] = this.holdingQuantity;
        data["approvedQuantity"] = this.approvedQuantity;
        data["requestQuantity"] = this.requestQuantity;
        return data; 
    }

    clone(): InvestmentAccumulateDto {
        const json = this.toJSON();
        let result = new InvestmentAccumulateDto();
        result.init(json);
        return result;
    }
}

export interface IInvestmentAccumulateDto {
    holdingQuantity?: number;
    approvedQuantity?: number;
    requestQuantity?: number;
}

export class InvestmentBranchSettingDto implements IInvestmentBranchSettingDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    isSelected?: boolean;
    isEditablePoint?: boolean;
    branchId?: number;
    branchCode?: string | undefined;
    branchName?: string | undefined;
    zoneId?: number | undefined;
    zoneName?: string | undefined;
    areaId?: number | undefined;
    areaName?: string | undefined;

    constructor(data?: IInvestmentBranchSettingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isSelected = _data["isSelected"];
            this.isEditablePoint = _data["isEditablePoint"];
            this.branchId = _data["branchId"];
            this.branchCode = _data["branchCode"];
            this.branchName = _data["branchName"];
            this.zoneId = _data["zoneId"];
            this.zoneName = _data["zoneName"];
            this.areaId = _data["areaId"];
            this.areaName = _data["areaName"];
        }
    }

    static fromJS(data: any): InvestmentBranchSettingDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvestmentBranchSettingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isSelected"] = this.isSelected;
        data["isEditablePoint"] = this.isEditablePoint;
        data["branchId"] = this.branchId;
        data["branchCode"] = this.branchCode;
        data["branchName"] = this.branchName;
        data["zoneId"] = this.zoneId;
        data["zoneName"] = this.zoneName;
        data["areaId"] = this.areaId;
        data["areaName"] = this.areaName;
        return data; 
    }

    clone(): InvestmentBranchSettingDto {
        const json = this.toJSON();
        let result = new InvestmentBranchSettingDto();
        result.init(json);
        return result;
    }
}

export interface IInvestmentBranchSettingDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    isSelected?: boolean;
    isEditablePoint?: boolean;
    branchId?: number;
    branchCode?: string | undefined;
    branchName?: string | undefined;
    zoneId?: number | undefined;
    zoneName?: string | undefined;
    areaId?: number | undefined;
    areaName?: string | undefined;
}

export class InvestmentCustomerSettingDto implements IInvestmentCustomerSettingDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    enableCreateTicketFromShop?: boolean;
    maxInvestAmount?: number;
    amountPerPoint?: number;
    maxInvestmentQueryMonths?: number;
    defaultPointsForTicket?: number;
    isPointEditable?: boolean;
    beginIssueDaysAfterCurrent?: number;
    endIssueDaysBeforeOperation?: number;

    constructor(data?: IInvestmentCustomerSettingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.enableCreateTicketFromShop = _data["enableCreateTicketFromShop"];
            this.maxInvestAmount = _data["maxInvestAmount"];
            this.amountPerPoint = _data["amountPerPoint"];
            this.maxInvestmentQueryMonths = _data["maxInvestmentQueryMonths"];
            this.defaultPointsForTicket = _data["defaultPointsForTicket"];
            this.isPointEditable = _data["isPointEditable"];
            this.beginIssueDaysAfterCurrent = _data["beginIssueDaysAfterCurrent"];
            this.endIssueDaysBeforeOperation = _data["endIssueDaysBeforeOperation"];
        }
    }

    static fromJS(data: any): InvestmentCustomerSettingDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvestmentCustomerSettingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["enableCreateTicketFromShop"] = this.enableCreateTicketFromShop;
        data["maxInvestAmount"] = this.maxInvestAmount;
        data["amountPerPoint"] = this.amountPerPoint;
        data["maxInvestmentQueryMonths"] = this.maxInvestmentQueryMonths;
        data["defaultPointsForTicket"] = this.defaultPointsForTicket;
        data["isPointEditable"] = this.isPointEditable;
        data["beginIssueDaysAfterCurrent"] = this.beginIssueDaysAfterCurrent;
        data["endIssueDaysBeforeOperation"] = this.endIssueDaysBeforeOperation;
        return data; 
    }

    clone(): InvestmentCustomerSettingDto {
        const json = this.toJSON();
        let result = new InvestmentCustomerSettingDto();
        result.init(json);
        return result;
    }
}

export interface IInvestmentCustomerSettingDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    enableCreateTicketFromShop?: boolean;
    maxInvestAmount?: number;
    amountPerPoint?: number;
    maxInvestmentQueryMonths?: number;
    defaultPointsForTicket?: number;
    isPointEditable?: boolean;
    beginIssueDaysAfterCurrent?: number;
    endIssueDaysBeforeOperation?: number;
}

export class InvestmentCustomerSettingDtoApiResultObject implements IInvestmentCustomerSettingDtoApiResultObject {
    result?: InvestmentCustomerSettingDto;
    success?: boolean;

    constructor(data?: IInvestmentCustomerSettingDtoApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? InvestmentCustomerSettingDto.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): InvestmentCustomerSettingDtoApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new InvestmentCustomerSettingDtoApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data; 
    }

    clone(): InvestmentCustomerSettingDtoApiResultObject {
        const json = this.toJSON();
        let result = new InvestmentCustomerSettingDtoApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IInvestmentCustomerSettingDtoApiResultObject {
    result?: InvestmentCustomerSettingDto;
    success?: boolean;
}

export class InvestmentDto implements IInvestmentDto {
    ticket?: InvestmentAccumulateDto;
    posm?: InvestmentAccumulateDto;
    pg?: InvestmentAccumulateDto;
    goldHour?: InvestmentAccumulateDto;

    constructor(data?: IInvestmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ticket = _data["ticket"] ? InvestmentAccumulateDto.fromJS(_data["ticket"]) : <any>undefined;
            this.posm = _data["posm"] ? InvestmentAccumulateDto.fromJS(_data["posm"]) : <any>undefined;
            this.pg = _data["pg"] ? InvestmentAccumulateDto.fromJS(_data["pg"]) : <any>undefined;
            this.goldHour = _data["goldHour"] ? InvestmentAccumulateDto.fromJS(_data["goldHour"]) : <any>undefined;
        }
    }

    static fromJS(data: any): InvestmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvestmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ticket"] = this.ticket ? this.ticket.toJSON() : <any>undefined;
        data["posm"] = this.posm ? this.posm.toJSON() : <any>undefined;
        data["pg"] = this.pg ? this.pg.toJSON() : <any>undefined;
        data["goldHour"] = this.goldHour ? this.goldHour.toJSON() : <any>undefined;
        return data; 
    }

    clone(): InvestmentDto {
        const json = this.toJSON();
        let result = new InvestmentDto();
        result.init(json);
        return result;
    }
}

export interface IInvestmentDto {
    ticket?: InvestmentAccumulateDto;
    posm?: InvestmentAccumulateDto;
    pg?: InvestmentAccumulateDto;
    goldHour?: InvestmentAccumulateDto;
}

export class InvestmentDtoApiResultObject implements IInvestmentDtoApiResultObject {
    result?: InvestmentDto;
    success?: boolean;

    constructor(data?: IInvestmentDtoApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? InvestmentDto.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): InvestmentDtoApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new InvestmentDtoApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data; 
    }

    clone(): InvestmentDtoApiResultObject {
        const json = this.toJSON();
        let result = new InvestmentDtoApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IInvestmentDtoApiResultObject {
    result?: InvestmentDto;
    success?: boolean;
}

export class InvestmentSettingDto implements IInvestmentSettingDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    maxInvestAmount?: number;
    amountPerPoint?: number;
    maxInvestmentQueryMonths?: number;
    defaultPointsForTicket?: number;
    checkQrCodeBranch?: boolean;
    beginIssueDaysAfterCurrent?: number;
    endIssueDaysBeforeOperation?: number;
    investmentSettingBranchs?: InvestmentBranchSettingDto[] | undefined;

    constructor(data?: IInvestmentSettingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.maxInvestAmount = _data["maxInvestAmount"];
            this.amountPerPoint = _data["amountPerPoint"];
            this.maxInvestmentQueryMonths = _data["maxInvestmentQueryMonths"];
            this.defaultPointsForTicket = _data["defaultPointsForTicket"];
            this.checkQrCodeBranch = _data["checkQrCodeBranch"];
            this.beginIssueDaysAfterCurrent = _data["beginIssueDaysAfterCurrent"];
            this.endIssueDaysBeforeOperation = _data["endIssueDaysBeforeOperation"];
            if (Array.isArray(_data["investmentSettingBranchs"])) {
                this.investmentSettingBranchs = [] as any;
                for (let item of _data["investmentSettingBranchs"])
                    this.investmentSettingBranchs!.push(InvestmentBranchSettingDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): InvestmentSettingDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvestmentSettingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["maxInvestAmount"] = this.maxInvestAmount;
        data["amountPerPoint"] = this.amountPerPoint;
        data["maxInvestmentQueryMonths"] = this.maxInvestmentQueryMonths;
        data["defaultPointsForTicket"] = this.defaultPointsForTicket;
        data["checkQrCodeBranch"] = this.checkQrCodeBranch;
        data["beginIssueDaysAfterCurrent"] = this.beginIssueDaysAfterCurrent;
        data["endIssueDaysBeforeOperation"] = this.endIssueDaysBeforeOperation;
        if (Array.isArray(this.investmentSettingBranchs)) {
            data["investmentSettingBranchs"] = [];
            for (let item of this.investmentSettingBranchs)
                data["investmentSettingBranchs"].push(item.toJSON());
        }
        return data; 
    }

    clone(): InvestmentSettingDto {
        const json = this.toJSON();
        let result = new InvestmentSettingDto();
        result.init(json);
        return result;
    }
}

export interface IInvestmentSettingDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    maxInvestAmount?: number;
    amountPerPoint?: number;
    maxInvestmentQueryMonths?: number;
    defaultPointsForTicket?: number;
    checkQrCodeBranch?: boolean;
    beginIssueDaysAfterCurrent?: number;
    endIssueDaysBeforeOperation?: number;
    investmentSettingBranchs?: InvestmentBranchSettingDto[] | undefined;
}

export class InvestmentSettingDtoApiResultObject implements IInvestmentSettingDtoApiResultObject {
    result?: InvestmentSettingDto;
    success?: boolean;

    constructor(data?: IInvestmentSettingDtoApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? InvestmentSettingDto.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): InvestmentSettingDtoApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new InvestmentSettingDtoApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data; 
    }

    clone(): InvestmentSettingDtoApiResultObject {
        const json = this.toJSON();
        let result = new InvestmentSettingDtoApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IInvestmentSettingDtoApiResultObject {
    result?: InvestmentSettingDto;
    success?: boolean;
}

export class MaterialDto implements IMaterialDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    materialTypeId?: number;
    description?: string | undefined;
    value?: number;
    isActive?: boolean;
    isDesign?: boolean;

    constructor(data?: IMaterialDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.materialTypeId = _data["materialTypeId"];
            this.description = _data["description"];
            this.value = _data["value"];
            this.isActive = _data["isActive"];
            this.isDesign = _data["isDesign"];
        }
    }

    static fromJS(data: any): MaterialDto {
        data = typeof data === 'object' ? data : {};
        let result = new MaterialDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["materialTypeId"] = this.materialTypeId;
        data["description"] = this.description;
        data["value"] = this.value;
        data["isActive"] = this.isActive;
        data["isDesign"] = this.isDesign;
        return data; 
    }

    clone(): MaterialDto {
        const json = this.toJSON();
        let result = new MaterialDto();
        result.init(json);
        return result;
    }
}

export interface IMaterialDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    materialTypeId?: number;
    description?: string | undefined;
    value?: number;
    isActive?: boolean;
    isDesign?: boolean;
}

export class MaterialDtoApiResultObject implements IMaterialDtoApiResultObject {
    result?: MaterialDto;
    success?: boolean;

    constructor(data?: IMaterialDtoApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? MaterialDto.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): MaterialDtoApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new MaterialDtoApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data; 
    }

    clone(): MaterialDtoApiResultObject {
        const json = this.toJSON();
        let result = new MaterialDtoApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IMaterialDtoApiResultObject {
    result?: MaterialDto;
    success?: boolean;
}

export class MaterialListItemDto implements IMaterialListItemDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    materialTypeId?: number;
    description?: string | undefined;
    value?: number;
    isActive?: boolean;
    isDesign?: boolean;
    materialTypeName?: string | undefined;

    constructor(data?: IMaterialListItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.materialTypeId = _data["materialTypeId"];
            this.description = _data["description"];
            this.value = _data["value"];
            this.isActive = _data["isActive"];
            this.isDesign = _data["isDesign"];
            this.materialTypeName = _data["materialTypeName"];
        }
    }

    static fromJS(data: any): MaterialListItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new MaterialListItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["materialTypeId"] = this.materialTypeId;
        data["description"] = this.description;
        data["value"] = this.value;
        data["isActive"] = this.isActive;
        data["isDesign"] = this.isDesign;
        data["materialTypeName"] = this.materialTypeName;
        return data; 
    }

    clone(): MaterialListItemDto {
        const json = this.toJSON();
        let result = new MaterialListItemDto();
        result.init(json);
        return result;
    }
}

export interface IMaterialListItemDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    materialTypeId?: number;
    description?: string | undefined;
    value?: number;
    isActive?: boolean;
    isDesign?: boolean;
    materialTypeName?: string | undefined;
}

export class MaterialListItemDtoPagingResult implements IMaterialListItemDtoPagingResult {
    items?: MaterialListItemDto[] | undefined;
    totalCount?: number;

    constructor(data?: IMaterialListItemDtoPagingResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(MaterialListItemDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): MaterialListItemDtoPagingResult {
        data = typeof data === 'object' ? data : {};
        let result = new MaterialListItemDtoPagingResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): MaterialListItemDtoPagingResult {
        const json = this.toJSON();
        let result = new MaterialListItemDtoPagingResult();
        result.init(json);
        return result;
    }
}

export interface IMaterialListItemDtoPagingResult {
    items?: MaterialListItemDto[] | undefined;
    totalCount?: number;
}

export class MaterialListItemDtoPagingResultApiResultObject implements IMaterialListItemDtoPagingResultApiResultObject {
    result?: MaterialListItemDtoPagingResult;
    success?: boolean;

    constructor(data?: IMaterialListItemDtoPagingResultApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? MaterialListItemDtoPagingResult.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): MaterialListItemDtoPagingResultApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new MaterialListItemDtoPagingResultApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data; 
    }

    clone(): MaterialListItemDtoPagingResultApiResultObject {
        const json = this.toJSON();
        let result = new MaterialListItemDtoPagingResultApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IMaterialListItemDtoPagingResultApiResultObject {
    result?: MaterialListItemDtoPagingResult;
    success?: boolean;
}

export class MaterialTypeDto implements IMaterialTypeDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    isActive?: boolean;

    constructor(data?: IMaterialTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): MaterialTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new MaterialTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): MaterialTypeDto {
        const json = this.toJSON();
        let result = new MaterialTypeDto();
        result.init(json);
        return result;
    }
}

export interface IMaterialTypeDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    isActive?: boolean;
}

export class MaterialTypeDtoApiResultObject implements IMaterialTypeDtoApiResultObject {
    result?: MaterialTypeDto;
    success?: boolean;

    constructor(data?: IMaterialTypeDtoApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? MaterialTypeDto.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): MaterialTypeDtoApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new MaterialTypeDtoApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data; 
    }

    clone(): MaterialTypeDtoApiResultObject {
        const json = this.toJSON();
        let result = new MaterialTypeDtoApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IMaterialTypeDtoApiResultObject {
    result?: MaterialTypeDto;
    success?: boolean;
}

export class MaterialTypeDtoPagingResult implements IMaterialTypeDtoPagingResult {
    items?: MaterialTypeDto[] | undefined;
    totalCount?: number;

    constructor(data?: IMaterialTypeDtoPagingResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(MaterialTypeDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): MaterialTypeDtoPagingResult {
        data = typeof data === 'object' ? data : {};
        let result = new MaterialTypeDtoPagingResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): MaterialTypeDtoPagingResult {
        const json = this.toJSON();
        let result = new MaterialTypeDtoPagingResult();
        result.init(json);
        return result;
    }
}

export interface IMaterialTypeDtoPagingResult {
    items?: MaterialTypeDto[] | undefined;
    totalCount?: number;
}

export class MaterialTypeDtoPagingResultApiResultObject implements IMaterialTypeDtoPagingResultApiResultObject {
    result?: MaterialTypeDtoPagingResult;
    success?: boolean;

    constructor(data?: IMaterialTypeDtoPagingResultApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? MaterialTypeDtoPagingResult.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): MaterialTypeDtoPagingResultApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new MaterialTypeDtoPagingResultApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data; 
    }

    clone(): MaterialTypeDtoPagingResultApiResultObject {
        const json = this.toJSON();
        let result = new MaterialTypeDtoPagingResultApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IMaterialTypeDtoPagingResultApiResultObject {
    result?: MaterialTypeDtoPagingResult;
    success?: boolean;
}

export class MaterialUpsertCommand implements IMaterialUpsertCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: UpsertMaterialDto;
    readonly handleType?: string | undefined;

    constructor(data?: IMaterialUpsertCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? UpsertMaterialDto.fromJS(_data["data"]) : <any>undefined;
            (<any>this).handleType = _data["handleType"];
        }
    }

    static fromJS(data: any): MaterialUpsertCommand {
        data = typeof data === 'object' ? data : {};
        let result = new MaterialUpsertCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["handleType"] = this.handleType;
        return data; 
    }

    clone(): MaterialUpsertCommand {
        const json = this.toJSON();
        let result = new MaterialUpsertCommand();
        result.init(json);
        return result;
    }
}

export interface IMaterialUpsertCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: UpsertMaterialDto;
    handleType?: string | undefined;
}

export class MonthData implements IMonthData {
    year?: number;
    month?: number;
    amount?: number;

    constructor(data?: IMonthData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.year = _data["year"];
            this.month = _data["month"];
            this.amount = _data["amount"];
        }
    }

    static fromJS(data: any): MonthData {
        data = typeof data === 'object' ? data : {};
        let result = new MonthData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["year"] = this.year;
        data["month"] = this.month;
        data["amount"] = this.amount;
        return data; 
    }

    clone(): MonthData {
        const json = this.toJSON();
        let result = new MonthData();
        result.init(json);
        return result;
    }
}

export interface IMonthData {
    year?: number;
    month?: number;
    amount?: number;
}

export class NotificationBranchDto implements INotificationBranchDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    isSelected?: boolean;
    branchId?: number;
    areaName?: string | undefined;
    branchCode?: string | undefined;
    branchName?: string | undefined;
    zoneName?: string | undefined;
    zoneId?: number | undefined;
    areaId?: number | undefined;

    constructor(data?: INotificationBranchDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isSelected = _data["isSelected"];
            this.branchId = _data["branchId"];
            this.areaName = _data["areaName"];
            this.branchCode = _data["branchCode"];
            this.branchName = _data["branchName"];
            this.zoneName = _data["zoneName"];
            this.zoneId = _data["zoneId"];
            this.areaId = _data["areaId"];
        }
    }

    static fromJS(data: any): NotificationBranchDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationBranchDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isSelected"] = this.isSelected;
        data["branchId"] = this.branchId;
        data["areaName"] = this.areaName;
        data["branchCode"] = this.branchCode;
        data["branchName"] = this.branchName;
        data["zoneName"] = this.zoneName;
        data["zoneId"] = this.zoneId;
        data["areaId"] = this.areaId;
        return data; 
    }

    clone(): NotificationBranchDto {
        const json = this.toJSON();
        let result = new NotificationBranchDto();
        result.init(json);
        return result;
    }
}

export interface INotificationBranchDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    isSelected?: boolean;
    branchId?: number;
    areaName?: string | undefined;
    branchCode?: string | undefined;
    branchName?: string | undefined;
    zoneName?: string | undefined;
    zoneId?: number | undefined;
    areaId?: number | undefined;
}

export class NotificationBranchUpsertDto implements INotificationBranchUpsertDto {
    id?: number;
    branchId?: number;

    constructor(data?: INotificationBranchUpsertDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.branchId = _data["branchId"];
        }
    }

    static fromJS(data: any): NotificationBranchUpsertDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationBranchUpsertDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["branchId"] = this.branchId;
        return data; 
    }

    clone(): NotificationBranchUpsertDto {
        const json = this.toJSON();
        let result = new NotificationBranchUpsertDto();
        result.init(json);
        return result;
    }
}

export interface INotificationBranchUpsertDto {
    id?: number;
    branchId?: number;
}

export class NotificationBranchUpsertDtoCrudListDto implements INotificationBranchUpsertDtoCrudListDto {
    upsertedItems?: NotificationBranchUpsertDto[] | undefined;
    deletedItems?: NotificationBranchUpsertDto[] | undefined;

    constructor(data?: INotificationBranchUpsertDtoCrudListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["upsertedItems"])) {
                this.upsertedItems = [] as any;
                for (let item of _data["upsertedItems"])
                    this.upsertedItems!.push(NotificationBranchUpsertDto.fromJS(item));
            }
            if (Array.isArray(_data["deletedItems"])) {
                this.deletedItems = [] as any;
                for (let item of _data["deletedItems"])
                    this.deletedItems!.push(NotificationBranchUpsertDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): NotificationBranchUpsertDtoCrudListDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationBranchUpsertDtoCrudListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.upsertedItems)) {
            data["upsertedItems"] = [];
            for (let item of this.upsertedItems)
                data["upsertedItems"].push(item.toJSON());
        }
        if (Array.isArray(this.deletedItems)) {
            data["deletedItems"] = [];
            for (let item of this.deletedItems)
                data["deletedItems"].push(item.toJSON());
        }
        return data; 
    }

    clone(): NotificationBranchUpsertDtoCrudListDto {
        const json = this.toJSON();
        let result = new NotificationBranchUpsertDtoCrudListDto();
        result.init(json);
        return result;
    }
}

export interface INotificationBranchUpsertDtoCrudListDto {
    upsertedItems?: NotificationBranchUpsertDto[] | undefined;
    deletedItems?: NotificationBranchUpsertDto[] | undefined;
}

export class NotificationDto implements INotificationDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    description?: string | undefined;
    shortContent?: string | undefined;
    content?: string | undefined;
    status?: number;
    objectType?: number;
    notificationBranches?: NotificationBranchDto[] | undefined;

    constructor(data?: INotificationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.description = _data["description"];
            this.shortContent = _data["shortContent"];
            this.content = _data["content"];
            this.status = _data["status"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["notificationBranches"])) {
                this.notificationBranches = [] as any;
                for (let item of _data["notificationBranches"])
                    this.notificationBranches!.push(NotificationBranchDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): NotificationDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["description"] = this.description;
        data["shortContent"] = this.shortContent;
        data["content"] = this.content;
        data["status"] = this.status;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.notificationBranches)) {
            data["notificationBranches"] = [];
            for (let item of this.notificationBranches)
                data["notificationBranches"].push(item.toJSON());
        }
        return data; 
    }

    clone(): NotificationDto {
        const json = this.toJSON();
        let result = new NotificationDto();
        result.init(json);
        return result;
    }
}

export interface INotificationDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    description?: string | undefined;
    shortContent?: string | undefined;
    content?: string | undefined;
    status?: number;
    objectType?: number;
    notificationBranches?: NotificationBranchDto[] | undefined;
}

export class NotificationDtoApiResultObject implements INotificationDtoApiResultObject {
    result?: NotificationDto;
    success?: boolean;

    constructor(data?: INotificationDtoApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? NotificationDto.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): NotificationDtoApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationDtoApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data; 
    }

    clone(): NotificationDtoApiResultObject {
        const json = this.toJSON();
        let result = new NotificationDtoApiResultObject();
        result.init(json);
        return result;
    }
}

export interface INotificationDtoApiResultObject {
    result?: NotificationDto;
    success?: boolean;
}

export class NotificationListDto implements INotificationListDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    description?: string | undefined;
    shortContent?: string | undefined;
    content?: string | undefined;
    status?: number;
    objectType?: number;

    constructor(data?: INotificationListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.description = _data["description"];
            this.shortContent = _data["shortContent"];
            this.content = _data["content"];
            this.status = _data["status"];
            this.objectType = _data["objectType"];
        }
    }

    static fromJS(data: any): NotificationListDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["description"] = this.description;
        data["shortContent"] = this.shortContent;
        data["content"] = this.content;
        data["status"] = this.status;
        data["objectType"] = this.objectType;
        return data; 
    }

    clone(): NotificationListDto {
        const json = this.toJSON();
        let result = new NotificationListDto();
        result.init(json);
        return result;
    }
}

export interface INotificationListDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    description?: string | undefined;
    shortContent?: string | undefined;
    content?: string | undefined;
    status?: number;
    objectType?: number;
}

export class NotificationListDtoPagingResult implements INotificationListDtoPagingResult {
    items?: NotificationListDto[] | undefined;
    totalCount?: number;

    constructor(data?: INotificationListDtoPagingResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(NotificationListDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): NotificationListDtoPagingResult {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationListDtoPagingResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): NotificationListDtoPagingResult {
        const json = this.toJSON();
        let result = new NotificationListDtoPagingResult();
        result.init(json);
        return result;
    }
}

export interface INotificationListDtoPagingResult {
    items?: NotificationListDto[] | undefined;
    totalCount?: number;
}

export class NotificationListDtoPagingResultApiResultObject implements INotificationListDtoPagingResultApiResultObject {
    result?: NotificationListDtoPagingResult;
    success?: boolean;

    constructor(data?: INotificationListDtoPagingResultApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? NotificationListDtoPagingResult.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): NotificationListDtoPagingResultApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationListDtoPagingResultApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data; 
    }

    clone(): NotificationListDtoPagingResultApiResultObject {
        const json = this.toJSON();
        let result = new NotificationListDtoPagingResultApiResultObject();
        result.init(json);
        return result;
    }
}

export interface INotificationListDtoPagingResultApiResultObject {
    result?: NotificationListDtoPagingResult;
    success?: boolean;
}

export class NotificationUpsertCommand implements INotificationUpsertCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: NotificationUpsertDto;
    readonly handleType?: string | undefined;

    constructor(data?: INotificationUpsertCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? NotificationUpsertDto.fromJS(_data["data"]) : <any>undefined;
            (<any>this).handleType = _data["handleType"];
        }
    }

    static fromJS(data: any): NotificationUpsertCommand {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationUpsertCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["handleType"] = this.handleType;
        return data; 
    }

    clone(): NotificationUpsertCommand {
        const json = this.toJSON();
        let result = new NotificationUpsertCommand();
        result.init(json);
        return result;
    }
}

export interface INotificationUpsertCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: NotificationUpsertDto;
    handleType?: string | undefined;
}

export class NotificationUpsertDto implements INotificationUpsertDto {
    id?: number;
    description?: string | undefined;
    content?: string | undefined;
    shortContent?: string | undefined;
    objectType?: number;
    notificationBranchChanges?: NotificationBranchUpsertDtoCrudListDto;

    constructor(data?: INotificationUpsertDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.description = _data["description"];
            this.content = _data["content"];
            this.shortContent = _data["shortContent"];
            this.objectType = _data["objectType"];
            this.notificationBranchChanges = _data["notificationBranchChanges"] ? NotificationBranchUpsertDtoCrudListDto.fromJS(_data["notificationBranchChanges"]) : <any>undefined;
        }
    }

    static fromJS(data: any): NotificationUpsertDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationUpsertDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["description"] = this.description;
        data["content"] = this.content;
        data["shortContent"] = this.shortContent;
        data["objectType"] = this.objectType;
        data["notificationBranchChanges"] = this.notificationBranchChanges ? this.notificationBranchChanges.toJSON() : <any>undefined;
        return data; 
    }

    clone(): NotificationUpsertDto {
        const json = this.toJSON();
        let result = new NotificationUpsertDto();
        result.init(json);
        return result;
    }
}

export interface INotificationUpsertDto {
    id?: number;
    description?: string | undefined;
    content?: string | undefined;
    shortContent?: string | undefined;
    objectType?: number;
    notificationBranchChanges?: NotificationBranchUpsertDtoCrudListDto;
}

export class ObjectApiResultObject implements IObjectApiResultObject {
    result?: any | undefined;
    success?: boolean;

    constructor(data?: IObjectApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"];
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): ObjectApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new ObjectApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result;
        data["success"] = this.success;
        return data; 
    }

    clone(): ObjectApiResultObject {
        const json = this.toJSON();
        let result = new ObjectApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IObjectApiResultObject {
    result?: any | undefined;
    success?: boolean;
}

export class OrderCreateCommand implements IOrderCreateCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: OrderCreateDto;

    constructor(data?: IOrderCreateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? OrderCreateDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): OrderCreateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new OrderCreateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data; 
    }

    clone(): OrderCreateCommand {
        const json = this.toJSON();
        let result = new OrderCreateCommand();
        result.init(json);
        return result;
    }
}

export interface IOrderCreateCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: OrderCreateDto;
}

export class OrderCreateDto implements IOrderCreateDto {
    consumerPhone?: string | undefined;
    consumerName?: string | undefined;
    orderDetails?: OrderDetailCreateDto[] | undefined;

    constructor(data?: IOrderCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.consumerPhone = _data["consumerPhone"];
            this.consumerName = _data["consumerName"];
            if (Array.isArray(_data["orderDetails"])) {
                this.orderDetails = [] as any;
                for (let item of _data["orderDetails"])
                    this.orderDetails!.push(OrderDetailCreateDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OrderCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["consumerPhone"] = this.consumerPhone;
        data["consumerName"] = this.consumerName;
        if (Array.isArray(this.orderDetails)) {
            data["orderDetails"] = [];
            for (let item of this.orderDetails)
                data["orderDetails"].push(item.toJSON());
        }
        return data; 
    }

    clone(): OrderCreateDto {
        const json = this.toJSON();
        let result = new OrderCreateDto();
        result.init(json);
        return result;
    }
}

export interface IOrderCreateDto {
    consumerPhone?: string | undefined;
    consumerName?: string | undefined;
    orderDetails?: OrderDetailCreateDto[] | undefined;
}

export class OrderDetailCreateDto implements IOrderDetailCreateDto {
    productCode?: string | undefined;
    qrCode?: string | undefined;
    spoonCode?: string | undefined;

    constructor(data?: IOrderDetailCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productCode = _data["productCode"];
            this.qrCode = _data["qrCode"];
            this.spoonCode = _data["spoonCode"];
        }
    }

    static fromJS(data: any): OrderDetailCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderDetailCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productCode"] = this.productCode;
        data["qrCode"] = this.qrCode;
        data["spoonCode"] = this.spoonCode;
        return data; 
    }

    clone(): OrderDetailCreateDto {
        const json = this.toJSON();
        let result = new OrderDetailCreateDto();
        result.init(json);
        return result;
    }
}

export interface IOrderDetailCreateDto {
    productCode?: string | undefined;
    qrCode?: string | undefined;
    spoonCode?: string | undefined;
}

export class OrderDetailDto implements IOrderDetailDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    productId?: number;
    productCode?: string | undefined;
    qrCode?: string | undefined;
    spoonCode?: string | undefined;
    productName?: string | undefined;
    unitName?: string | undefined;
    quantity?: number;
    unitPrice?: number;
    lineAmount?: number;
    api?: string | undefined;
    points?: number;
    availablePoints?: number;
    usedPoints?: number;
    usedForTicket?: boolean;

    constructor(data?: IOrderDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.productId = _data["productId"];
            this.productCode = _data["productCode"];
            this.qrCode = _data["qrCode"];
            this.spoonCode = _data["spoonCode"];
            this.productName = _data["productName"];
            this.unitName = _data["unitName"];
            this.quantity = _data["quantity"];
            this.unitPrice = _data["unitPrice"];
            this.lineAmount = _data["lineAmount"];
            this.api = _data["api"];
            this.points = _data["points"];
            this.availablePoints = _data["availablePoints"];
            this.usedPoints = _data["usedPoints"];
            this.usedForTicket = _data["usedForTicket"];
        }
    }

    static fromJS(data: any): OrderDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["productId"] = this.productId;
        data["productCode"] = this.productCode;
        data["qrCode"] = this.qrCode;
        data["spoonCode"] = this.spoonCode;
        data["productName"] = this.productName;
        data["unitName"] = this.unitName;
        data["quantity"] = this.quantity;
        data["unitPrice"] = this.unitPrice;
        data["lineAmount"] = this.lineAmount;
        data["api"] = this.api;
        data["points"] = this.points;
        data["availablePoints"] = this.availablePoints;
        data["usedPoints"] = this.usedPoints;
        data["usedForTicket"] = this.usedForTicket;
        return data; 
    }

    clone(): OrderDetailDto {
        const json = this.toJSON();
        let result = new OrderDetailDto();
        result.init(json);
        return result;
    }
}

export interface IOrderDetailDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    productId?: number;
    productCode?: string | undefined;
    qrCode?: string | undefined;
    spoonCode?: string | undefined;
    productName?: string | undefined;
    unitName?: string | undefined;
    quantity?: number;
    unitPrice?: number;
    lineAmount?: number;
    api?: string | undefined;
    points?: number;
    availablePoints?: number;
    usedPoints?: number;
    usedForTicket?: boolean;
}

export class OrderDetailDtoPagingResult implements IOrderDetailDtoPagingResult {
    items?: OrderDetailDto[] | undefined;
    totalCount?: number;

    constructor(data?: IOrderDetailDtoPagingResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(OrderDetailDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): OrderDetailDtoPagingResult {
        data = typeof data === 'object' ? data : {};
        let result = new OrderDetailDtoPagingResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): OrderDetailDtoPagingResult {
        const json = this.toJSON();
        let result = new OrderDetailDtoPagingResult();
        result.init(json);
        return result;
    }
}

export interface IOrderDetailDtoPagingResult {
    items?: OrderDetailDto[] | undefined;
    totalCount?: number;
}

export class OrderDetailDtoPagingResultApiResultObject implements IOrderDetailDtoPagingResultApiResultObject {
    result?: OrderDetailDtoPagingResult;
    success?: boolean;

    constructor(data?: IOrderDetailDtoPagingResultApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? OrderDetailDtoPagingResult.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): OrderDetailDtoPagingResultApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new OrderDetailDtoPagingResultApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data; 
    }

    clone(): OrderDetailDtoPagingResultApiResultObject {
        const json = this.toJSON();
        let result = new OrderDetailDtoPagingResultApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IOrderDetailDtoPagingResultApiResultObject {
    result?: OrderDetailDtoPagingResult;
    success?: boolean;
}

export class OrderDto implements IOrderDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    orderNumber?: string | undefined;
    ticketInvestmentId?: number | undefined;
    customerId?: number;
    branchId?: number;
    orderDate?: Date;
    consumerPhone?: string | undefined;
    consumerName?: string | undefined;
    totalQuantity?: number;
    totalAmount?: number;
    totalPoints?: number;
    totalAvailablePoints?: number;
    totalUsedPoints?: number;
    orderDetails?: OrderDetailDto[] | undefined;
    tickets?: OrderTicketDto[] | undefined;

    constructor(data?: IOrderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.orderNumber = _data["orderNumber"];
            this.ticketInvestmentId = _data["ticketInvestmentId"];
            this.customerId = _data["customerId"];
            this.branchId = _data["branchId"];
            this.orderDate = _data["orderDate"] ? new Date(_data["orderDate"].toString()) : <any>undefined;
            this.consumerPhone = _data["consumerPhone"];
            this.consumerName = _data["consumerName"];
            this.totalQuantity = _data["totalQuantity"];
            this.totalAmount = _data["totalAmount"];
            this.totalPoints = _data["totalPoints"];
            this.totalAvailablePoints = _data["totalAvailablePoints"];
            this.totalUsedPoints = _data["totalUsedPoints"];
            if (Array.isArray(_data["orderDetails"])) {
                this.orderDetails = [] as any;
                for (let item of _data["orderDetails"])
                    this.orderDetails!.push(OrderDetailDto.fromJS(item));
            }
            if (Array.isArray(_data["tickets"])) {
                this.tickets = [] as any;
                for (let item of _data["tickets"])
                    this.tickets!.push(OrderTicketDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["orderNumber"] = this.orderNumber;
        data["ticketInvestmentId"] = this.ticketInvestmentId;
        data["customerId"] = this.customerId;
        data["branchId"] = this.branchId;
        data["orderDate"] = this.orderDate ? this.orderDate.toISOString() : <any>undefined;
        data["consumerPhone"] = this.consumerPhone;
        data["consumerName"] = this.consumerName;
        data["totalQuantity"] = this.totalQuantity;
        data["totalAmount"] = this.totalAmount;
        data["totalPoints"] = this.totalPoints;
        data["totalAvailablePoints"] = this.totalAvailablePoints;
        data["totalUsedPoints"] = this.totalUsedPoints;
        if (Array.isArray(this.orderDetails)) {
            data["orderDetails"] = [];
            for (let item of this.orderDetails)
                data["orderDetails"].push(item.toJSON());
        }
        if (Array.isArray(this.tickets)) {
            data["tickets"] = [];
            for (let item of this.tickets)
                data["tickets"].push(item.toJSON());
        }
        return data; 
    }

    clone(): OrderDto {
        const json = this.toJSON();
        let result = new OrderDto();
        result.init(json);
        return result;
    }
}

export interface IOrderDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    orderNumber?: string | undefined;
    ticketInvestmentId?: number | undefined;
    customerId?: number;
    branchId?: number;
    orderDate?: Date;
    consumerPhone?: string | undefined;
    consumerName?: string | undefined;
    totalQuantity?: number;
    totalAmount?: number;
    totalPoints?: number;
    totalAvailablePoints?: number;
    totalUsedPoints?: number;
    orderDetails?: OrderDetailDto[] | undefined;
    tickets?: OrderTicketDto[] | undefined;
}

export class OrderDtoApiResultObject implements IOrderDtoApiResultObject {
    result?: OrderDto;
    success?: boolean;

    constructor(data?: IOrderDtoApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? OrderDto.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): OrderDtoApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new OrderDtoApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data; 
    }

    clone(): OrderDtoApiResultObject {
        const json = this.toJSON();
        let result = new OrderDtoApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IOrderDtoApiResultObject {
    result?: OrderDto;
    success?: boolean;
}

export class OrderListItemDto implements IOrderListItemDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    orderNumber?: string | undefined;
    ticketInvestmentId?: number | undefined;
    ticketInvestmentCode?: string | undefined;
    customerId?: number;
    customerCode?: string | undefined;
    customerName?: string | undefined;
    ticketCodes?: string | undefined;
    branchId?: number;
    orderDate?: Date;
    consumerPhone?: string | undefined;
    consumerName?: string | undefined;
    totalQuantity?: number;
    totalAmount?: number;
    totalPoints?: number;
    totalAvailablePoints?: number;
    totalUsedPoints?: number;

    constructor(data?: IOrderListItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.orderNumber = _data["orderNumber"];
            this.ticketInvestmentId = _data["ticketInvestmentId"];
            this.ticketInvestmentCode = _data["ticketInvestmentCode"];
            this.customerId = _data["customerId"];
            this.customerCode = _data["customerCode"];
            this.customerName = _data["customerName"];
            this.ticketCodes = _data["ticketCodes"];
            this.branchId = _data["branchId"];
            this.orderDate = _data["orderDate"] ? new Date(_data["orderDate"].toString()) : <any>undefined;
            this.consumerPhone = _data["consumerPhone"];
            this.consumerName = _data["consumerName"];
            this.totalQuantity = _data["totalQuantity"];
            this.totalAmount = _data["totalAmount"];
            this.totalPoints = _data["totalPoints"];
            this.totalAvailablePoints = _data["totalAvailablePoints"];
            this.totalUsedPoints = _data["totalUsedPoints"];
        }
    }

    static fromJS(data: any): OrderListItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderListItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["orderNumber"] = this.orderNumber;
        data["ticketInvestmentId"] = this.ticketInvestmentId;
        data["ticketInvestmentCode"] = this.ticketInvestmentCode;
        data["customerId"] = this.customerId;
        data["customerCode"] = this.customerCode;
        data["customerName"] = this.customerName;
        data["ticketCodes"] = this.ticketCodes;
        data["branchId"] = this.branchId;
        data["orderDate"] = this.orderDate ? this.orderDate.toISOString() : <any>undefined;
        data["consumerPhone"] = this.consumerPhone;
        data["consumerName"] = this.consumerName;
        data["totalQuantity"] = this.totalQuantity;
        data["totalAmount"] = this.totalAmount;
        data["totalPoints"] = this.totalPoints;
        data["totalAvailablePoints"] = this.totalAvailablePoints;
        data["totalUsedPoints"] = this.totalUsedPoints;
        return data; 
    }

    clone(): OrderListItemDto {
        const json = this.toJSON();
        let result = new OrderListItemDto();
        result.init(json);
        return result;
    }
}

export interface IOrderListItemDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    orderNumber?: string | undefined;
    ticketInvestmentId?: number | undefined;
    ticketInvestmentCode?: string | undefined;
    customerId?: number;
    customerCode?: string | undefined;
    customerName?: string | undefined;
    ticketCodes?: string | undefined;
    branchId?: number;
    orderDate?: Date;
    consumerPhone?: string | undefined;
    consumerName?: string | undefined;
    totalQuantity?: number;
    totalAmount?: number;
    totalPoints?: number;
    totalAvailablePoints?: number;
    totalUsedPoints?: number;
}

export class OrderListItemDtoListApiResultObject implements IOrderListItemDtoListApiResultObject {
    result?: OrderListItemDto[] | undefined;
    success?: boolean;

    constructor(data?: IOrderListItemDtoListApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(OrderListItemDto.fromJS(item));
            }
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): OrderListItemDtoListApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new OrderListItemDtoListApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["success"] = this.success;
        return data; 
    }

    clone(): OrderListItemDtoListApiResultObject {
        const json = this.toJSON();
        let result = new OrderListItemDtoListApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IOrderListItemDtoListApiResultObject {
    result?: OrderListItemDto[] | undefined;
    success?: boolean;
}

export class OrderListItemDtoPagingResult implements IOrderListItemDtoPagingResult {
    items?: OrderListItemDto[] | undefined;
    totalCount?: number;

    constructor(data?: IOrderListItemDtoPagingResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(OrderListItemDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): OrderListItemDtoPagingResult {
        data = typeof data === 'object' ? data : {};
        let result = new OrderListItemDtoPagingResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): OrderListItemDtoPagingResult {
        const json = this.toJSON();
        let result = new OrderListItemDtoPagingResult();
        result.init(json);
        return result;
    }
}

export interface IOrderListItemDtoPagingResult {
    items?: OrderListItemDto[] | undefined;
    totalCount?: number;
}

export class OrderListItemDtoPagingResultApiResultObject implements IOrderListItemDtoPagingResultApiResultObject {
    result?: OrderListItemDtoPagingResult;
    success?: boolean;

    constructor(data?: IOrderListItemDtoPagingResultApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? OrderListItemDtoPagingResult.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): OrderListItemDtoPagingResultApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new OrderListItemDtoPagingResultApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data; 
    }

    clone(): OrderListItemDtoPagingResultApiResultObject {
        const json = this.toJSON();
        let result = new OrderListItemDtoPagingResultApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IOrderListItemDtoPagingResultApiResultObject {
    result?: OrderListItemDtoPagingResult;
    success?: boolean;
}

export class OrderTicketDto implements IOrderTicketDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    ticketCode?: string | undefined;
    ticketId?: number;

    constructor(data?: IOrderTicketDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.ticketCode = _data["ticketCode"];
            this.ticketId = _data["ticketId"];
        }
    }

    static fromJS(data: any): OrderTicketDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderTicketDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["ticketCode"] = this.ticketCode;
        data["ticketId"] = this.ticketId;
        return data; 
    }

    clone(): OrderTicketDto {
        const json = this.toJSON();
        let result = new OrderTicketDto();
        result.init(json);
        return result;
    }
}

export interface IOrderTicketDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    ticketCode?: string | undefined;
    ticketId?: number;
}

export class OrderUpdateSpoonCodeCommand implements IOrderUpdateSpoonCodeCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    phone?: string | undefined;
    name?: string | undefined;
    qrCode?: string | undefined;
    spoonCode?: string | undefined;

    constructor(data?: IOrderUpdateSpoonCodeCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.phone = _data["phone"];
            this.name = _data["name"];
            this.qrCode = _data["qrCode"];
            this.spoonCode = _data["spoonCode"];
        }
    }

    static fromJS(data: any): OrderUpdateSpoonCodeCommand {
        data = typeof data === 'object' ? data : {};
        let result = new OrderUpdateSpoonCodeCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["phone"] = this.phone;
        data["name"] = this.name;
        data["qrCode"] = this.qrCode;
        data["spoonCode"] = this.spoonCode;
        return data; 
    }

    clone(): OrderUpdateSpoonCodeCommand {
        const json = this.toJSON();
        let result = new OrderUpdateSpoonCodeCommand();
        result.init(json);
        return result;
    }
}

export interface IOrderUpdateSpoonCodeCommand {
    commandId?: string;
    occuredDate?: Date;
    phone?: string | undefined;
    name?: string | undefined;
    qrCode?: string | undefined;
    spoonCode?: string | undefined;
}

export class OrderValidateSpoonCodeCommand implements IOrderValidateSpoonCodeCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    spoonCode?: string | undefined;

    constructor(data?: IOrderValidateSpoonCodeCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.spoonCode = _data["spoonCode"];
        }
    }

    static fromJS(data: any): OrderValidateSpoonCodeCommand {
        data = typeof data === 'object' ? data : {};
        let result = new OrderValidateSpoonCodeCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["spoonCode"] = this.spoonCode;
        return data; 
    }

    clone(): OrderValidateSpoonCodeCommand {
        const json = this.toJSON();
        let result = new OrderValidateSpoonCodeCommand();
        result.init(json);
        return result;
    }
}

export interface IOrderValidateSpoonCodeCommand {
    commandId?: string;
    occuredDate?: Date;
    spoonCode?: string | undefined;
}

export class PermissionDto implements IPermissionDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    parentId?: number | undefined;
    isActive?: boolean;

    constructor(data?: IPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.parentId = _data["parentId"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): PermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["description"] = this.description;
        data["parentId"] = this.parentId;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): PermissionDto {
        const json = this.toJSON();
        let result = new PermissionDto();
        result.init(json);
        return result;
    }
}

export interface IPermissionDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    parentId?: number | undefined;
    isActive?: boolean;
}

export class PermissionDtoApiResultObject implements IPermissionDtoApiResultObject {
    result?: PermissionDto;
    success?: boolean;

    constructor(data?: IPermissionDtoApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? PermissionDto.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): PermissionDtoApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDtoApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data; 
    }

    clone(): PermissionDtoApiResultObject {
        const json = this.toJSON();
        let result = new PermissionDtoApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IPermissionDtoApiResultObject {
    result?: PermissionDto;
    success?: boolean;
}

export class PermissionDtoPagingResult implements IPermissionDtoPagingResult {
    items?: PermissionDto[] | undefined;
    totalCount?: number;

    constructor(data?: IPermissionDtoPagingResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PermissionDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PermissionDtoPagingResult {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDtoPagingResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): PermissionDtoPagingResult {
        const json = this.toJSON();
        let result = new PermissionDtoPagingResult();
        result.init(json);
        return result;
    }
}

export interface IPermissionDtoPagingResult {
    items?: PermissionDto[] | undefined;
    totalCount?: number;
}

export class PermissionDtoPagingResultApiResultObject implements IPermissionDtoPagingResultApiResultObject {
    result?: PermissionDtoPagingResult;
    success?: boolean;

    constructor(data?: IPermissionDtoPagingResultApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? PermissionDtoPagingResult.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): PermissionDtoPagingResultApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDtoPagingResultApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data; 
    }

    clone(): PermissionDtoPagingResultApiResultObject {
        const json = this.toJSON();
        let result = new PermissionDtoPagingResultApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IPermissionDtoPagingResultApiResultObject {
    result?: PermissionDtoPagingResult;
    success?: boolean;
}

export class ProductBaseDto implements IProductBaseDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    isActive?: boolean;
    unit?: string | undefined;
    caseUnit?: string | undefined;
    packSize?: number;
    productClassId?: number | undefined;
    subProductClassId?: number | undefined;
    brandId?: number | undefined;
    updateDate?: Date;
    point?: number;

    constructor(data?: IProductBaseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.isActive = _data["isActive"];
            this.unit = _data["unit"];
            this.caseUnit = _data["caseUnit"];
            this.packSize = _data["packSize"];
            this.productClassId = _data["productClassId"];
            this.subProductClassId = _data["subProductClassId"];
            this.brandId = _data["brandId"];
            this.updateDate = _data["updateDate"] ? new Date(_data["updateDate"].toString()) : <any>undefined;
            this.point = _data["point"];
        }
    }

    static fromJS(data: any): ProductBaseDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductBaseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["description"] = this.description;
        data["isActive"] = this.isActive;
        data["unit"] = this.unit;
        data["caseUnit"] = this.caseUnit;
        data["packSize"] = this.packSize;
        data["productClassId"] = this.productClassId;
        data["subProductClassId"] = this.subProductClassId;
        data["brandId"] = this.brandId;
        data["updateDate"] = this.updateDate ? this.updateDate.toISOString() : <any>undefined;
        data["point"] = this.point;
        return data; 
    }

    clone(): ProductBaseDto {
        const json = this.toJSON();
        let result = new ProductBaseDto();
        result.init(json);
        return result;
    }
}

export interface IProductBaseDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    isActive?: boolean;
    unit?: string | undefined;
    caseUnit?: string | undefined;
    packSize?: number;
    productClassId?: number | undefined;
    subProductClassId?: number | undefined;
    brandId?: number | undefined;
    updateDate?: Date;
    point?: number;
}

export class ProductBaseDtoApiResultObject implements IProductBaseDtoApiResultObject {
    result?: ProductBaseDto;
    success?: boolean;

    constructor(data?: IProductBaseDtoApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? ProductBaseDto.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): ProductBaseDtoApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new ProductBaseDtoApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data; 
    }

    clone(): ProductBaseDtoApiResultObject {
        const json = this.toJSON();
        let result = new ProductBaseDtoApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IProductBaseDtoApiResultObject {
    result?: ProductBaseDto;
    success?: boolean;
}

export class ProductClassDto implements IProductClassDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    rewardCode?: string | undefined;
    isActive?: boolean;

    constructor(data?: IProductClassDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.rewardCode = _data["rewardCode"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): ProductClassDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductClassDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["rewardCode"] = this.rewardCode;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): ProductClassDto {
        const json = this.toJSON();
        let result = new ProductClassDto();
        result.init(json);
        return result;
    }
}

export interface IProductClassDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    rewardCode?: string | undefined;
    isActive?: boolean;
}

export class ProductClassDtoApiResultObject implements IProductClassDtoApiResultObject {
    result?: ProductClassDto;
    success?: boolean;

    constructor(data?: IProductClassDtoApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? ProductClassDto.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): ProductClassDtoApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new ProductClassDtoApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data; 
    }

    clone(): ProductClassDtoApiResultObject {
        const json = this.toJSON();
        let result = new ProductClassDtoApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IProductClassDtoApiResultObject {
    result?: ProductClassDto;
    success?: boolean;
}

export class ProductClassDtoPagingResult implements IProductClassDtoPagingResult {
    items?: ProductClassDto[] | undefined;
    totalCount?: number;

    constructor(data?: IProductClassDtoPagingResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProductClassDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ProductClassDtoPagingResult {
        data = typeof data === 'object' ? data : {};
        let result = new ProductClassDtoPagingResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): ProductClassDtoPagingResult {
        const json = this.toJSON();
        let result = new ProductClassDtoPagingResult();
        result.init(json);
        return result;
    }
}

export interface IProductClassDtoPagingResult {
    items?: ProductClassDto[] | undefined;
    totalCount?: number;
}

export class ProductClassDtoPagingResultApiResultObject implements IProductClassDtoPagingResultApiResultObject {
    result?: ProductClassDtoPagingResult;
    success?: boolean;

    constructor(data?: IProductClassDtoPagingResultApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? ProductClassDtoPagingResult.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): ProductClassDtoPagingResultApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new ProductClassDtoPagingResultApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data; 
    }

    clone(): ProductClassDtoPagingResultApiResultObject {
        const json = this.toJSON();
        let result = new ProductClassDtoPagingResultApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IProductClassDtoPagingResultApiResultObject {
    result?: ProductClassDtoPagingResult;
    success?: boolean;
}

export class ProductInfoDto implements IProductInfoDto {
    readonly qrCode?: string | undefined;
    readonly productCode?: string | undefined;
    readonly name?: string | undefined;
    readonly unit?: string | undefined;
    readonly quantity?: number;
    readonly point?: number;

    constructor(data?: IProductInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).qrCode = _data["qrCode"];
            (<any>this).productCode = _data["productCode"];
            (<any>this).name = _data["name"];
            (<any>this).unit = _data["unit"];
            (<any>this).quantity = _data["quantity"];
            (<any>this).point = _data["point"];
        }
    }

    static fromJS(data: any): ProductInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["qrCode"] = this.qrCode;
        data["productCode"] = this.productCode;
        data["name"] = this.name;
        data["unit"] = this.unit;
        data["quantity"] = this.quantity;
        data["point"] = this.point;
        return data; 
    }

    clone(): ProductInfoDto {
        const json = this.toJSON();
        let result = new ProductInfoDto();
        result.init(json);
        return result;
    }
}

export interface IProductInfoDto {
    qrCode?: string | undefined;
    productCode?: string | undefined;
    name?: string | undefined;
    unit?: string | undefined;
    quantity?: number;
    point?: number;
}

export class ProductInfoDtoApiResultObject implements IProductInfoDtoApiResultObject {
    result?: ProductInfoDto;
    success?: boolean;

    constructor(data?: IProductInfoDtoApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? ProductInfoDto.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): ProductInfoDtoApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new ProductInfoDtoApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data; 
    }

    clone(): ProductInfoDtoApiResultObject {
        const json = this.toJSON();
        let result = new ProductInfoDtoApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IProductInfoDtoApiResultObject {
    result?: ProductInfoDto;
    success?: boolean;
}

export class ProductItemDto implements IProductItemDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    isActive?: boolean;
    unit?: string | undefined;
    caseUnit?: string | undefined;
    packSize?: number;
    productClassId?: number | undefined;
    subProductClassId?: number | undefined;
    brandId?: number | undefined;
    updateDate?: Date;
    point?: number;
    brandName?: string | undefined;
    productClassName?: string | undefined;
    subProductClassName?: string | undefined;
    status?: string | undefined;

    constructor(data?: IProductItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.isActive = _data["isActive"];
            this.unit = _data["unit"];
            this.caseUnit = _data["caseUnit"];
            this.packSize = _data["packSize"];
            this.productClassId = _data["productClassId"];
            this.subProductClassId = _data["subProductClassId"];
            this.brandId = _data["brandId"];
            this.updateDate = _data["updateDate"] ? new Date(_data["updateDate"].toString()) : <any>undefined;
            this.point = _data["point"];
            this.brandName = _data["brandName"];
            this.productClassName = _data["productClassName"];
            this.subProductClassName = _data["subProductClassName"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): ProductItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["description"] = this.description;
        data["isActive"] = this.isActive;
        data["unit"] = this.unit;
        data["caseUnit"] = this.caseUnit;
        data["packSize"] = this.packSize;
        data["productClassId"] = this.productClassId;
        data["subProductClassId"] = this.subProductClassId;
        data["brandId"] = this.brandId;
        data["updateDate"] = this.updateDate ? this.updateDate.toISOString() : <any>undefined;
        data["point"] = this.point;
        data["brandName"] = this.brandName;
        data["productClassName"] = this.productClassName;
        data["subProductClassName"] = this.subProductClassName;
        data["status"] = this.status;
        return data; 
    }

    clone(): ProductItemDto {
        const json = this.toJSON();
        let result = new ProductItemDto();
        result.init(json);
        return result;
    }
}

export interface IProductItemDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    isActive?: boolean;
    unit?: string | undefined;
    caseUnit?: string | undefined;
    packSize?: number;
    productClassId?: number | undefined;
    subProductClassId?: number | undefined;
    brandId?: number | undefined;
    updateDate?: Date;
    point?: number;
    brandName?: string | undefined;
    productClassName?: string | undefined;
    subProductClassName?: string | undefined;
    status?: string | undefined;
}

export class ProductItemDtoApiResultObject implements IProductItemDtoApiResultObject {
    result?: ProductItemDto;
    success?: boolean;

    constructor(data?: IProductItemDtoApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? ProductItemDto.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): ProductItemDtoApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new ProductItemDtoApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data; 
    }

    clone(): ProductItemDtoApiResultObject {
        const json = this.toJSON();
        let result = new ProductItemDtoApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IProductItemDtoApiResultObject {
    result?: ProductItemDto;
    success?: boolean;
}

export class ProductListItemDto implements IProductListItemDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    isActive?: boolean;
    unit?: string | undefined;
    caseUnit?: string | undefined;
    packSize?: number;
    productClassId?: number | undefined;
    subProductClassId?: number | undefined;
    brandId?: number | undefined;
    updateDate?: Date;
    point?: number;
    brandName?: string | undefined;
    productClassName?: string | undefined;
    productClassCode?: string | undefined;
    subProductClassName?: string | undefined;

    constructor(data?: IProductListItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.isActive = _data["isActive"];
            this.unit = _data["unit"];
            this.caseUnit = _data["caseUnit"];
            this.packSize = _data["packSize"];
            this.productClassId = _data["productClassId"];
            this.subProductClassId = _data["subProductClassId"];
            this.brandId = _data["brandId"];
            this.updateDate = _data["updateDate"] ? new Date(_data["updateDate"].toString()) : <any>undefined;
            this.point = _data["point"];
            this.brandName = _data["brandName"];
            this.productClassName = _data["productClassName"];
            this.productClassCode = _data["productClassCode"];
            this.subProductClassName = _data["subProductClassName"];
        }
    }

    static fromJS(data: any): ProductListItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductListItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["description"] = this.description;
        data["isActive"] = this.isActive;
        data["unit"] = this.unit;
        data["caseUnit"] = this.caseUnit;
        data["packSize"] = this.packSize;
        data["productClassId"] = this.productClassId;
        data["subProductClassId"] = this.subProductClassId;
        data["brandId"] = this.brandId;
        data["updateDate"] = this.updateDate ? this.updateDate.toISOString() : <any>undefined;
        data["point"] = this.point;
        data["brandName"] = this.brandName;
        data["productClassName"] = this.productClassName;
        data["productClassCode"] = this.productClassCode;
        data["subProductClassName"] = this.subProductClassName;
        return data; 
    }

    clone(): ProductListItemDto {
        const json = this.toJSON();
        let result = new ProductListItemDto();
        result.init(json);
        return result;
    }
}

export interface IProductListItemDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    isActive?: boolean;
    unit?: string | undefined;
    caseUnit?: string | undefined;
    packSize?: number;
    productClassId?: number | undefined;
    subProductClassId?: number | undefined;
    brandId?: number | undefined;
    updateDate?: Date;
    point?: number;
    brandName?: string | undefined;
    productClassName?: string | undefined;
    productClassCode?: string | undefined;
    subProductClassName?: string | undefined;
}

export class ProductListItemDtoPagingResult implements IProductListItemDtoPagingResult {
    items?: ProductListItemDto[] | undefined;
    totalCount?: number;

    constructor(data?: IProductListItemDtoPagingResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProductListItemDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ProductListItemDtoPagingResult {
        data = typeof data === 'object' ? data : {};
        let result = new ProductListItemDtoPagingResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): ProductListItemDtoPagingResult {
        const json = this.toJSON();
        let result = new ProductListItemDtoPagingResult();
        result.init(json);
        return result;
    }
}

export interface IProductListItemDtoPagingResult {
    items?: ProductListItemDto[] | undefined;
    totalCount?: number;
}

export class ProductListItemDtoPagingResultApiResultObject implements IProductListItemDtoPagingResultApiResultObject {
    result?: ProductListItemDtoPagingResult;
    success?: boolean;

    constructor(data?: IProductListItemDtoPagingResultApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? ProductListItemDtoPagingResult.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): ProductListItemDtoPagingResultApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new ProductListItemDtoPagingResultApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data; 
    }

    clone(): ProductListItemDtoPagingResultApiResultObject {
        const json = this.toJSON();
        let result = new ProductListItemDtoPagingResultApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IProductListItemDtoPagingResultApiResultObject {
    result?: ProductListItemDtoPagingResult;
    success?: boolean;
}

export class ProductPointDto implements IProductPointDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    productId?: number;
    productCode?: string | undefined;
    productName?: string | undefined;
    unit?: string | undefined;
    productClassId?: number | undefined;
    productClassName?: string | undefined;
    subProductClassName?: string | undefined;
    points?: number;
    fromDate?: Date;
    toDate?: Date;
    isActive?: boolean;

    constructor(data?: IProductPointDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.productId = _data["productId"];
            this.productCode = _data["productCode"];
            this.productName = _data["productName"];
            this.unit = _data["unit"];
            this.productClassId = _data["productClassId"];
            this.productClassName = _data["productClassName"];
            this.subProductClassName = _data["subProductClassName"];
            this.points = _data["points"];
            this.fromDate = _data["fromDate"] ? new Date(_data["fromDate"].toString()) : <any>undefined;
            this.toDate = _data["toDate"] ? new Date(_data["toDate"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): ProductPointDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductPointDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["productId"] = this.productId;
        data["productCode"] = this.productCode;
        data["productName"] = this.productName;
        data["unit"] = this.unit;
        data["productClassId"] = this.productClassId;
        data["productClassName"] = this.productClassName;
        data["subProductClassName"] = this.subProductClassName;
        data["points"] = this.points;
        data["fromDate"] = this.fromDate ? this.fromDate.toISOString() : <any>undefined;
        data["toDate"] = this.toDate ? this.toDate.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): ProductPointDto {
        const json = this.toJSON();
        let result = new ProductPointDto();
        result.init(json);
        return result;
    }
}

export interface IProductPointDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    productId?: number;
    productCode?: string | undefined;
    productName?: string | undefined;
    unit?: string | undefined;
    productClassId?: number | undefined;
    productClassName?: string | undefined;
    subProductClassName?: string | undefined;
    points?: number;
    fromDate?: Date;
    toDate?: Date;
    isActive?: boolean;
}

export class ProductPointDtoApiResultObject implements IProductPointDtoApiResultObject {
    result?: ProductPointDto;
    success?: boolean;

    constructor(data?: IProductPointDtoApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? ProductPointDto.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): ProductPointDtoApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new ProductPointDtoApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data; 
    }

    clone(): ProductPointDtoApiResultObject {
        const json = this.toJSON();
        let result = new ProductPointDtoApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IProductPointDtoApiResultObject {
    result?: ProductPointDto;
    success?: boolean;
}

export class ProductPointListItemDto implements IProductPointListItemDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    productId?: number;
    productCode?: string | undefined;
    productName?: string | undefined;
    unit?: string | undefined;
    productClassId?: number | undefined;
    productClassName?: string | undefined;
    subProductClassName?: string | undefined;
    points?: number;
    fromDate?: Date;
    toDate?: Date;
    isActive?: boolean;

    constructor(data?: IProductPointListItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.productId = _data["productId"];
            this.productCode = _data["productCode"];
            this.productName = _data["productName"];
            this.unit = _data["unit"];
            this.productClassId = _data["productClassId"];
            this.productClassName = _data["productClassName"];
            this.subProductClassName = _data["subProductClassName"];
            this.points = _data["points"];
            this.fromDate = _data["fromDate"] ? new Date(_data["fromDate"].toString()) : <any>undefined;
            this.toDate = _data["toDate"] ? new Date(_data["toDate"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): ProductPointListItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductPointListItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["productId"] = this.productId;
        data["productCode"] = this.productCode;
        data["productName"] = this.productName;
        data["unit"] = this.unit;
        data["productClassId"] = this.productClassId;
        data["productClassName"] = this.productClassName;
        data["subProductClassName"] = this.subProductClassName;
        data["points"] = this.points;
        data["fromDate"] = this.fromDate ? this.fromDate.toISOString() : <any>undefined;
        data["toDate"] = this.toDate ? this.toDate.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): ProductPointListItemDto {
        const json = this.toJSON();
        let result = new ProductPointListItemDto();
        result.init(json);
        return result;
    }
}

export interface IProductPointListItemDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    productId?: number;
    productCode?: string | undefined;
    productName?: string | undefined;
    unit?: string | undefined;
    productClassId?: number | undefined;
    productClassName?: string | undefined;
    subProductClassName?: string | undefined;
    points?: number;
    fromDate?: Date;
    toDate?: Date;
    isActive?: boolean;
}

export class ProductPointListItemDtoPagingResult implements IProductPointListItemDtoPagingResult {
    items?: ProductPointListItemDto[] | undefined;
    totalCount?: number;

    constructor(data?: IProductPointListItemDtoPagingResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProductPointListItemDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ProductPointListItemDtoPagingResult {
        data = typeof data === 'object' ? data : {};
        let result = new ProductPointListItemDtoPagingResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): ProductPointListItemDtoPagingResult {
        const json = this.toJSON();
        let result = new ProductPointListItemDtoPagingResult();
        result.init(json);
        return result;
    }
}

export interface IProductPointListItemDtoPagingResult {
    items?: ProductPointListItemDto[] | undefined;
    totalCount?: number;
}

export class ProductPointListItemDtoPagingResultApiResultObject implements IProductPointListItemDtoPagingResultApiResultObject {
    result?: ProductPointListItemDtoPagingResult;
    success?: boolean;

    constructor(data?: IProductPointListItemDtoPagingResultApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? ProductPointListItemDtoPagingResult.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): ProductPointListItemDtoPagingResultApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new ProductPointListItemDtoPagingResultApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data; 
    }

    clone(): ProductPointListItemDtoPagingResultApiResultObject {
        const json = this.toJSON();
        let result = new ProductPointListItemDtoPagingResultApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IProductPointListItemDtoPagingResultApiResultObject {
    result?: ProductPointListItemDtoPagingResult;
    success?: boolean;
}

export class ProductPointUpsertCommand implements IProductPointUpsertCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: ProductPointUpsertDto;
    readonly handleType?: string | undefined;

    constructor(data?: IProductPointUpsertCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? ProductPointUpsertDto.fromJS(_data["data"]) : <any>undefined;
            (<any>this).handleType = _data["handleType"];
        }
    }

    static fromJS(data: any): ProductPointUpsertCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ProductPointUpsertCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["handleType"] = this.handleType;
        return data; 
    }

    clone(): ProductPointUpsertCommand {
        const json = this.toJSON();
        let result = new ProductPointUpsertCommand();
        result.init(json);
        return result;
    }
}

export interface IProductPointUpsertCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: ProductPointUpsertDto;
    handleType?: string | undefined;
}

export class ProductPointUpsertDto implements IProductPointUpsertDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    productId?: number;
    productCode?: string | undefined;
    productName?: string | undefined;
    unit?: string | undefined;
    productClassId?: number | undefined;
    productClassName?: string | undefined;
    subProductClassName?: string | undefined;
    points?: number;
    fromDate?: Date;
    toDate?: Date;
    isActive?: boolean;

    constructor(data?: IProductPointUpsertDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.productId = _data["productId"];
            this.productCode = _data["productCode"];
            this.productName = _data["productName"];
            this.unit = _data["unit"];
            this.productClassId = _data["productClassId"];
            this.productClassName = _data["productClassName"];
            this.subProductClassName = _data["subProductClassName"];
            this.points = _data["points"];
            this.fromDate = _data["fromDate"] ? new Date(_data["fromDate"].toString()) : <any>undefined;
            this.toDate = _data["toDate"] ? new Date(_data["toDate"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): ProductPointUpsertDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductPointUpsertDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["productId"] = this.productId;
        data["productCode"] = this.productCode;
        data["productName"] = this.productName;
        data["unit"] = this.unit;
        data["productClassId"] = this.productClassId;
        data["productClassName"] = this.productClassName;
        data["subProductClassName"] = this.subProductClassName;
        data["points"] = this.points;
        data["fromDate"] = this.fromDate ? this.fromDate.toISOString() : <any>undefined;
        data["toDate"] = this.toDate ? this.toDate.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): ProductPointUpsertDto {
        const json = this.toJSON();
        let result = new ProductPointUpsertDto();
        result.init(json);
        return result;
    }
}

export interface IProductPointUpsertDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    productId?: number;
    productCode?: string | undefined;
    productName?: string | undefined;
    unit?: string | undefined;
    productClassId?: number | undefined;
    productClassName?: string | undefined;
    subProductClassName?: string | undefined;
    points?: number;
    fromDate?: Date;
    toDate?: Date;
    isActive?: boolean;
}

export class ProductUnitDto implements IProductUnitDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    isActive?: boolean;

    constructor(data?: IProductUnitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): ProductUnitDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductUnitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): ProductUnitDto {
        const json = this.toJSON();
        let result = new ProductUnitDto();
        result.init(json);
        return result;
    }
}

export interface IProductUnitDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    isActive?: boolean;
}

export class ProductUnitDtoApiResultObject implements IProductUnitDtoApiResultObject {
    result?: ProductUnitDto;
    success?: boolean;

    constructor(data?: IProductUnitDtoApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? ProductUnitDto.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): ProductUnitDtoApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new ProductUnitDtoApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data; 
    }

    clone(): ProductUnitDtoApiResultObject {
        const json = this.toJSON();
        let result = new ProductUnitDtoApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IProductUnitDtoApiResultObject {
    result?: ProductUnitDto;
    success?: boolean;
}

export class ProductUnitDtoPagingResult implements IProductUnitDtoPagingResult {
    items?: ProductUnitDto[] | undefined;
    totalCount?: number;

    constructor(data?: IProductUnitDtoPagingResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProductUnitDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ProductUnitDtoPagingResult {
        data = typeof data === 'object' ? data : {};
        let result = new ProductUnitDtoPagingResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): ProductUnitDtoPagingResult {
        const json = this.toJSON();
        let result = new ProductUnitDtoPagingResult();
        result.init(json);
        return result;
    }
}

export interface IProductUnitDtoPagingResult {
    items?: ProductUnitDto[] | undefined;
    totalCount?: number;
}

export class ProductUnitDtoPagingResultApiResultObject implements IProductUnitDtoPagingResultApiResultObject {
    result?: ProductUnitDtoPagingResult;
    success?: boolean;

    constructor(data?: IProductUnitDtoPagingResultApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? ProductUnitDtoPagingResult.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): ProductUnitDtoPagingResultApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new ProductUnitDtoPagingResultApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data; 
    }

    clone(): ProductUnitDtoPagingResultApiResultObject {
        const json = this.toJSON();
        let result = new ProductUnitDtoPagingResultApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IProductUnitDtoPagingResultApiResultObject {
    result?: ProductUnitDtoPagingResult;
    success?: boolean;
}

export class ProvinceDto implements IProvinceDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;

    constructor(data?: IProvinceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ProvinceDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProvinceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["name"] = this.name;
        return data; 
    }

    clone(): ProvinceDto {
        const json = this.toJSON();
        let result = new ProvinceDto();
        result.init(json);
        return result;
    }
}

export interface IProvinceDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
}

export class ProvinceDtoApiResultObject implements IProvinceDtoApiResultObject {
    result?: ProvinceDto;
    success?: boolean;

    constructor(data?: IProvinceDtoApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? ProvinceDto.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): ProvinceDtoApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new ProvinceDtoApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data; 
    }

    clone(): ProvinceDtoApiResultObject {
        const json = this.toJSON();
        let result = new ProvinceDtoApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IProvinceDtoApiResultObject {
    result?: ProvinceDto;
    success?: boolean;
}

export class ProvinceDtoPagingResult implements IProvinceDtoPagingResult {
    items?: ProvinceDto[] | undefined;
    totalCount?: number;

    constructor(data?: IProvinceDtoPagingResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProvinceDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ProvinceDtoPagingResult {
        data = typeof data === 'object' ? data : {};
        let result = new ProvinceDtoPagingResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): ProvinceDtoPagingResult {
        const json = this.toJSON();
        let result = new ProvinceDtoPagingResult();
        result.init(json);
        return result;
    }
}

export interface IProvinceDtoPagingResult {
    items?: ProvinceDto[] | undefined;
    totalCount?: number;
}

export class ProvinceDtoPagingResultApiResultObject implements IProvinceDtoPagingResultApiResultObject {
    result?: ProvinceDtoPagingResult;
    success?: boolean;

    constructor(data?: IProvinceDtoPagingResultApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? ProvinceDtoPagingResult.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): ProvinceDtoPagingResultApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new ProvinceDtoPagingResultApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data; 
    }

    clone(): ProvinceDtoPagingResultApiResultObject {
        const json = this.toJSON();
        let result = new ProvinceDtoPagingResultApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IProvinceDtoPagingResultApiResultObject {
    result?: ProvinceDtoPagingResult;
    success?: boolean;
}

export class ResetPasswordCommand implements IResetPasswordCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    password?: string | undefined;
    token?: string | undefined;

    constructor(data?: IResetPasswordCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.password = _data["password"];
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): ResetPasswordCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["password"] = this.password;
        data["token"] = this.token;
        return data; 
    }

    clone(): ResetPasswordCommand {
        const json = this.toJSON();
        let result = new ResetPasswordCommand();
        result.init(json);
        return result;
    }
}

export interface IResetPasswordCommand {
    commandId?: string;
    occuredDate?: Date;
    password?: string | undefined;
    token?: string | undefined;
}

export class RewardBranchDto implements IRewardBranchDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    isSelected?: boolean;
    branchId?: number;
    areaName?: string | undefined;
    branchCode?: string | undefined;
    branchName?: string | undefined;
    zoneName?: string | undefined;
    zoneId?: number | undefined;
    areaId?: number | undefined;

    constructor(data?: IRewardBranchDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isSelected = _data["isSelected"];
            this.branchId = _data["branchId"];
            this.areaName = _data["areaName"];
            this.branchCode = _data["branchCode"];
            this.branchName = _data["branchName"];
            this.zoneName = _data["zoneName"];
            this.zoneId = _data["zoneId"];
            this.areaId = _data["areaId"];
        }
    }

    static fromJS(data: any): RewardBranchDto {
        data = typeof data === 'object' ? data : {};
        let result = new RewardBranchDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isSelected"] = this.isSelected;
        data["branchId"] = this.branchId;
        data["areaName"] = this.areaName;
        data["branchCode"] = this.branchCode;
        data["branchName"] = this.branchName;
        data["zoneName"] = this.zoneName;
        data["zoneId"] = this.zoneId;
        data["areaId"] = this.areaId;
        return data; 
    }

    clone(): RewardBranchDto {
        const json = this.toJSON();
        let result = new RewardBranchDto();
        result.init(json);
        return result;
    }
}

export interface IRewardBranchDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    isSelected?: boolean;
    branchId?: number;
    areaName?: string | undefined;
    branchCode?: string | undefined;
    branchName?: string | undefined;
    zoneName?: string | undefined;
    zoneId?: number | undefined;
    areaId?: number | undefined;
}

export class RewardBranchUpSertDto implements IRewardBranchUpSertDto {
    id?: number;
    branchId?: number;

    constructor(data?: IRewardBranchUpSertDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.branchId = _data["branchId"];
        }
    }

    static fromJS(data: any): RewardBranchUpSertDto {
        data = typeof data === 'object' ? data : {};
        let result = new RewardBranchUpSertDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["branchId"] = this.branchId;
        return data; 
    }

    clone(): RewardBranchUpSertDto {
        const json = this.toJSON();
        let result = new RewardBranchUpSertDto();
        result.init(json);
        return result;
    }
}

export interface IRewardBranchUpSertDto {
    id?: number;
    branchId?: number;
}

export class RewardBranchUpSertDtoCrudListDto implements IRewardBranchUpSertDtoCrudListDto {
    upsertedItems?: RewardBranchUpSertDto[] | undefined;
    deletedItems?: RewardBranchUpSertDto[] | undefined;

    constructor(data?: IRewardBranchUpSertDtoCrudListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["upsertedItems"])) {
                this.upsertedItems = [] as any;
                for (let item of _data["upsertedItems"])
                    this.upsertedItems!.push(RewardBranchUpSertDto.fromJS(item));
            }
            if (Array.isArray(_data["deletedItems"])) {
                this.deletedItems = [] as any;
                for (let item of _data["deletedItems"])
                    this.deletedItems!.push(RewardBranchUpSertDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RewardBranchUpSertDtoCrudListDto {
        data = typeof data === 'object' ? data : {};
        let result = new RewardBranchUpSertDtoCrudListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.upsertedItems)) {
            data["upsertedItems"] = [];
            for (let item of this.upsertedItems)
                data["upsertedItems"].push(item.toJSON());
        }
        if (Array.isArray(this.deletedItems)) {
            data["deletedItems"] = [];
            for (let item of this.deletedItems)
                data["deletedItems"].push(item.toJSON());
        }
        return data; 
    }

    clone(): RewardBranchUpSertDtoCrudListDto {
        const json = this.toJSON();
        let result = new RewardBranchUpSertDtoCrudListDto();
        result.init(json);
        return result;
    }
}

export interface IRewardBranchUpSertDtoCrudListDto {
    upsertedItems?: RewardBranchUpSertDto[] | undefined;
    deletedItems?: RewardBranchUpSertDto[] | undefined;
}

export class RewardItemDto implements IRewardItemDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    documentLink?: string | undefined;
    productUnitId?: number | undefined;
    productUnitCode?: string | undefined;
    productUnitName?: string | undefined;
    price?: number;
    quantity?: number;
    productId?: number | undefined;
    productCode?: string | undefined;
    productName?: string | undefined;

    constructor(data?: IRewardItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.documentLink = _data["documentLink"];
            this.productUnitId = _data["productUnitId"];
            this.productUnitCode = _data["productUnitCode"];
            this.productUnitName = _data["productUnitName"];
            this.price = _data["price"];
            this.quantity = _data["quantity"];
            this.productId = _data["productId"];
            this.productCode = _data["productCode"];
            this.productName = _data["productName"];
        }
    }

    static fromJS(data: any): RewardItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new RewardItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["documentLink"] = this.documentLink;
        data["productUnitId"] = this.productUnitId;
        data["productUnitCode"] = this.productUnitCode;
        data["productUnitName"] = this.productUnitName;
        data["price"] = this.price;
        data["quantity"] = this.quantity;
        data["productId"] = this.productId;
        data["productCode"] = this.productCode;
        data["productName"] = this.productName;
        return data; 
    }

    clone(): RewardItemDto {
        const json = this.toJSON();
        let result = new RewardItemDto();
        result.init(json);
        return result;
    }
}

export interface IRewardItemDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    documentLink?: string | undefined;
    productUnitId?: number | undefined;
    productUnitCode?: string | undefined;
    productUnitName?: string | undefined;
    price?: number;
    quantity?: number;
    productId?: number | undefined;
    productCode?: string | undefined;
    productName?: string | undefined;
}

export class RewardItemUpsertDto implements IRewardItemUpsertDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    documentLink?: string | undefined;
    productUnitId?: number | undefined;
    price?: number;
    quantity?: number;
    productId?: number | undefined;

    constructor(data?: IRewardItemUpsertDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.documentLink = _data["documentLink"];
            this.productUnitId = _data["productUnitId"];
            this.price = _data["price"];
            this.quantity = _data["quantity"];
            this.productId = _data["productId"];
        }
    }

    static fromJS(data: any): RewardItemUpsertDto {
        data = typeof data === 'object' ? data : {};
        let result = new RewardItemUpsertDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["documentLink"] = this.documentLink;
        data["productUnitId"] = this.productUnitId;
        data["price"] = this.price;
        data["quantity"] = this.quantity;
        data["productId"] = this.productId;
        return data; 
    }

    clone(): RewardItemUpsertDto {
        const json = this.toJSON();
        let result = new RewardItemUpsertDto();
        result.init(json);
        return result;
    }
}

export interface IRewardItemUpsertDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    documentLink?: string | undefined;
    productUnitId?: number | undefined;
    price?: number;
    quantity?: number;
    productId?: number | undefined;
}

export class RewardItemUpsertDtoCrudListDto implements IRewardItemUpsertDtoCrudListDto {
    upsertedItems?: RewardItemUpsertDto[] | undefined;
    deletedItems?: RewardItemUpsertDto[] | undefined;

    constructor(data?: IRewardItemUpsertDtoCrudListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["upsertedItems"])) {
                this.upsertedItems = [] as any;
                for (let item of _data["upsertedItems"])
                    this.upsertedItems!.push(RewardItemUpsertDto.fromJS(item));
            }
            if (Array.isArray(_data["deletedItems"])) {
                this.deletedItems = [] as any;
                for (let item of _data["deletedItems"])
                    this.deletedItems!.push(RewardItemUpsertDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RewardItemUpsertDtoCrudListDto {
        data = typeof data === 'object' ? data : {};
        let result = new RewardItemUpsertDtoCrudListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.upsertedItems)) {
            data["upsertedItems"] = [];
            for (let item of this.upsertedItems)
                data["upsertedItems"].push(item.toJSON());
        }
        if (Array.isArray(this.deletedItems)) {
            data["deletedItems"] = [];
            for (let item of this.deletedItems)
                data["deletedItems"].push(item.toJSON());
        }
        return data; 
    }

    clone(): RewardItemUpsertDtoCrudListDto {
        const json = this.toJSON();
        let result = new RewardItemUpsertDtoCrudListDto();
        result.init(json);
        return result;
    }
}

export interface IRewardItemUpsertDtoCrudListDto {
    upsertedItems?: RewardItemUpsertDto[] | undefined;
    deletedItems?: RewardItemUpsertDto[] | undefined;
}

export class RewardPackageDto implements IRewardPackageDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    isActive?: boolean;
    type?: number;
    fromDate?: Date;
    toDate?: Date;
    totalAmount?: number;
    totalTickets?: number;
    rewardItems?: RewardItemDto[] | undefined;
    rewardBranches?: RewardBranchDto[] | undefined;

    constructor(data?: IRewardPackageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
            this.type = _data["type"];
            this.fromDate = _data["fromDate"] ? new Date(_data["fromDate"].toString()) : <any>undefined;
            this.toDate = _data["toDate"] ? new Date(_data["toDate"].toString()) : <any>undefined;
            this.totalAmount = _data["totalAmount"];
            this.totalTickets = _data["totalTickets"];
            if (Array.isArray(_data["rewardItems"])) {
                this.rewardItems = [] as any;
                for (let item of _data["rewardItems"])
                    this.rewardItems!.push(RewardItemDto.fromJS(item));
            }
            if (Array.isArray(_data["rewardBranches"])) {
                this.rewardBranches = [] as any;
                for (let item of _data["rewardBranches"])
                    this.rewardBranches!.push(RewardBranchDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RewardPackageDto {
        data = typeof data === 'object' ? data : {};
        let result = new RewardPackageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        data["type"] = this.type;
        data["fromDate"] = this.fromDate ? this.fromDate.toISOString() : <any>undefined;
        data["toDate"] = this.toDate ? this.toDate.toISOString() : <any>undefined;
        data["totalAmount"] = this.totalAmount;
        data["totalTickets"] = this.totalTickets;
        if (Array.isArray(this.rewardItems)) {
            data["rewardItems"] = [];
            for (let item of this.rewardItems)
                data["rewardItems"].push(item.toJSON());
        }
        if (Array.isArray(this.rewardBranches)) {
            data["rewardBranches"] = [];
            for (let item of this.rewardBranches)
                data["rewardBranches"].push(item.toJSON());
        }
        return data; 
    }

    clone(): RewardPackageDto {
        const json = this.toJSON();
        let result = new RewardPackageDto();
        result.init(json);
        return result;
    }
}

export interface IRewardPackageDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    isActive?: boolean;
    type?: number;
    fromDate?: Date;
    toDate?: Date;
    totalAmount?: number;
    totalTickets?: number;
    rewardItems?: RewardItemDto[] | undefined;
    rewardBranches?: RewardBranchDto[] | undefined;
}

export class RewardPackageDtoApiResultObject implements IRewardPackageDtoApiResultObject {
    result?: RewardPackageDto;
    success?: boolean;

    constructor(data?: IRewardPackageDtoApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? RewardPackageDto.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): RewardPackageDtoApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new RewardPackageDtoApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data; 
    }

    clone(): RewardPackageDtoApiResultObject {
        const json = this.toJSON();
        let result = new RewardPackageDtoApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IRewardPackageDtoApiResultObject {
    result?: RewardPackageDto;
    success?: boolean;
}

export class RewardPackageListDto implements IRewardPackageListDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    isActive?: boolean;
    type?: number;
    fromDate?: Date;
    toDate?: Date;
    totalAmount?: number;
    totalTickets?: number;

    constructor(data?: IRewardPackageListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
            this.type = _data["type"];
            this.fromDate = _data["fromDate"] ? new Date(_data["fromDate"].toString()) : <any>undefined;
            this.toDate = _data["toDate"] ? new Date(_data["toDate"].toString()) : <any>undefined;
            this.totalAmount = _data["totalAmount"];
            this.totalTickets = _data["totalTickets"];
        }
    }

    static fromJS(data: any): RewardPackageListDto {
        data = typeof data === 'object' ? data : {};
        let result = new RewardPackageListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        data["type"] = this.type;
        data["fromDate"] = this.fromDate ? this.fromDate.toISOString() : <any>undefined;
        data["toDate"] = this.toDate ? this.toDate.toISOString() : <any>undefined;
        data["totalAmount"] = this.totalAmount;
        data["totalTickets"] = this.totalTickets;
        return data; 
    }

    clone(): RewardPackageListDto {
        const json = this.toJSON();
        let result = new RewardPackageListDto();
        result.init(json);
        return result;
    }
}

export interface IRewardPackageListDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    isActive?: boolean;
    type?: number;
    fromDate?: Date;
    toDate?: Date;
    totalAmount?: number;
    totalTickets?: number;
}

export class RewardPackageListDtoPagingResult implements IRewardPackageListDtoPagingResult {
    items?: RewardPackageListDto[] | undefined;
    totalCount?: number;

    constructor(data?: IRewardPackageListDtoPagingResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(RewardPackageListDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): RewardPackageListDtoPagingResult {
        data = typeof data === 'object' ? data : {};
        let result = new RewardPackageListDtoPagingResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): RewardPackageListDtoPagingResult {
        const json = this.toJSON();
        let result = new RewardPackageListDtoPagingResult();
        result.init(json);
        return result;
    }
}

export interface IRewardPackageListDtoPagingResult {
    items?: RewardPackageListDto[] | undefined;
    totalCount?: number;
}

export class RewardPackageListDtoPagingResultApiResultObject implements IRewardPackageListDtoPagingResultApiResultObject {
    result?: RewardPackageListDtoPagingResult;
    success?: boolean;

    constructor(data?: IRewardPackageListDtoPagingResultApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? RewardPackageListDtoPagingResult.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): RewardPackageListDtoPagingResultApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new RewardPackageListDtoPagingResultApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data; 
    }

    clone(): RewardPackageListDtoPagingResultApiResultObject {
        const json = this.toJSON();
        let result = new RewardPackageListDtoPagingResultApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IRewardPackageListDtoPagingResultApiResultObject {
    result?: RewardPackageListDtoPagingResult;
    success?: boolean;
}

export class RewardPackageUpsertCommand implements IRewardPackageUpsertCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: RewardPackageUpsertDto;
    readonly handleType?: string | undefined;

    constructor(data?: IRewardPackageUpsertCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? RewardPackageUpsertDto.fromJS(_data["data"]) : <any>undefined;
            (<any>this).handleType = _data["handleType"];
        }
    }

    static fromJS(data: any): RewardPackageUpsertCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RewardPackageUpsertCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["handleType"] = this.handleType;
        return data; 
    }

    clone(): RewardPackageUpsertCommand {
        const json = this.toJSON();
        let result = new RewardPackageUpsertCommand();
        result.init(json);
        return result;
    }
}

export interface IRewardPackageUpsertCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: RewardPackageUpsertDto;
    handleType?: string | undefined;
}

export class RewardPackageUpsertDto implements IRewardPackageUpsertDto {
    id?: number;
    code?: string | undefined;
    name?: string | undefined;
    isActive?: boolean;
    type?: number;
    fromDate?: Date;
    toDate?: Date;
    rewardItemChanges?: RewardItemUpsertDtoCrudListDto;
    rewardBranchChanges?: RewardBranchUpSertDtoCrudListDto;

    constructor(data?: IRewardPackageUpsertDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
            this.type = _data["type"];
            this.fromDate = _data["fromDate"] ? new Date(_data["fromDate"].toString()) : <any>undefined;
            this.toDate = _data["toDate"] ? new Date(_data["toDate"].toString()) : <any>undefined;
            this.rewardItemChanges = _data["rewardItemChanges"] ? RewardItemUpsertDtoCrudListDto.fromJS(_data["rewardItemChanges"]) : <any>undefined;
            this.rewardBranchChanges = _data["rewardBranchChanges"] ? RewardBranchUpSertDtoCrudListDto.fromJS(_data["rewardBranchChanges"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RewardPackageUpsertDto {
        data = typeof data === 'object' ? data : {};
        let result = new RewardPackageUpsertDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        data["type"] = this.type;
        data["fromDate"] = this.fromDate ? this.fromDate.toISOString() : <any>undefined;
        data["toDate"] = this.toDate ? this.toDate.toISOString() : <any>undefined;
        data["rewardItemChanges"] = this.rewardItemChanges ? this.rewardItemChanges.toJSON() : <any>undefined;
        data["rewardBranchChanges"] = this.rewardBranchChanges ? this.rewardBranchChanges.toJSON() : <any>undefined;
        return data; 
    }

    clone(): RewardPackageUpsertDto {
        const json = this.toJSON();
        let result = new RewardPackageUpsertDto();
        result.init(json);
        return result;
    }
}

export interface IRewardPackageUpsertDto {
    id?: number;
    code?: string | undefined;
    name?: string | undefined;
    isActive?: boolean;
    type?: number;
    fromDate?: Date;
    toDate?: Date;
    rewardItemChanges?: RewardItemUpsertDtoCrudListDto;
    rewardBranchChanges?: RewardBranchUpSertDtoCrudListDto;
}

export class RoleDto implements IRoleDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    roleName?: string | undefined;
    displayName?: string | undefined;
    description?: string | undefined;
    isActive?: boolean;
    permissions?: RolePermissionDto[] | undefined;

    constructor(data?: IRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.roleName = _data["roleName"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(RolePermissionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["roleName"] = this.roleName;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        return data; 
    }

    clone(): RoleDto {
        const json = this.toJSON();
        let result = new RoleDto();
        result.init(json);
        return result;
    }
}

export interface IRoleDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    roleName?: string | undefined;
    displayName?: string | undefined;
    description?: string | undefined;
    isActive?: boolean;
    permissions?: RolePermissionDto[] | undefined;
}

export class RoleDtoApiResultObject implements IRoleDtoApiResultObject {
    result?: RoleDto;
    success?: boolean;

    constructor(data?: IRoleDtoApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? RoleDto.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): RoleDtoApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDtoApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data; 
    }

    clone(): RoleDtoApiResultObject {
        const json = this.toJSON();
        let result = new RoleDtoApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IRoleDtoApiResultObject {
    result?: RoleDto;
    success?: boolean;
}

export class RoleListItemDto implements IRoleListItemDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    roleName?: string | undefined;
    displayName?: string | undefined;
    description?: string | undefined;
    isActive?: boolean;

    constructor(data?: IRoleListItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.roleName = _data["roleName"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): RoleListItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleListItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["roleName"] = this.roleName;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): RoleListItemDto {
        const json = this.toJSON();
        let result = new RoleListItemDto();
        result.init(json);
        return result;
    }
}

export interface IRoleListItemDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    roleName?: string | undefined;
    displayName?: string | undefined;
    description?: string | undefined;
    isActive?: boolean;
}

export class RoleListItemDtoPagingResult implements IRoleListItemDtoPagingResult {
    items?: RoleListItemDto[] | undefined;
    totalCount?: number;

    constructor(data?: IRoleListItemDtoPagingResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(RoleListItemDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): RoleListItemDtoPagingResult {
        data = typeof data === 'object' ? data : {};
        let result = new RoleListItemDtoPagingResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): RoleListItemDtoPagingResult {
        const json = this.toJSON();
        let result = new RoleListItemDtoPagingResult();
        result.init(json);
        return result;
    }
}

export interface IRoleListItemDtoPagingResult {
    items?: RoleListItemDto[] | undefined;
    totalCount?: number;
}

export class RoleListItemDtoPagingResultApiResultObject implements IRoleListItemDtoPagingResultApiResultObject {
    result?: RoleListItemDtoPagingResult;
    success?: boolean;

    constructor(data?: IRoleListItemDtoPagingResultApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? RoleListItemDtoPagingResult.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): RoleListItemDtoPagingResultApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new RoleListItemDtoPagingResultApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data; 
    }

    clone(): RoleListItemDtoPagingResultApiResultObject {
        const json = this.toJSON();
        let result = new RoleListItemDtoPagingResultApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IRoleListItemDtoPagingResultApiResultObject {
    result?: RoleListItemDtoPagingResult;
    success?: boolean;
}

export class RolePermissionDto implements IRolePermissionDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    permissionId?: number;
    permissionCode?: string | undefined;
    permissionName?: string | undefined;
    description?: string | undefined;

    constructor(data?: IRolePermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.permissionId = _data["permissionId"];
            this.permissionCode = _data["permissionCode"];
            this.permissionName = _data["permissionName"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): RolePermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new RolePermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["permissionId"] = this.permissionId;
        data["permissionCode"] = this.permissionCode;
        data["permissionName"] = this.permissionName;
        data["description"] = this.description;
        return data; 
    }

    clone(): RolePermissionDto {
        const json = this.toJSON();
        let result = new RolePermissionDto();
        result.init(json);
        return result;
    }
}

export interface IRolePermissionDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    permissionId?: number;
    permissionCode?: string | undefined;
    permissionName?: string | undefined;
    description?: string | undefined;
}

export class RolePermissionDtoCrudListDto implements IRolePermissionDtoCrudListDto {
    upsertedItems?: RolePermissionDto[] | undefined;
    deletedItems?: RolePermissionDto[] | undefined;

    constructor(data?: IRolePermissionDtoCrudListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["upsertedItems"])) {
                this.upsertedItems = [] as any;
                for (let item of _data["upsertedItems"])
                    this.upsertedItems!.push(RolePermissionDto.fromJS(item));
            }
            if (Array.isArray(_data["deletedItems"])) {
                this.deletedItems = [] as any;
                for (let item of _data["deletedItems"])
                    this.deletedItems!.push(RolePermissionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RolePermissionDtoCrudListDto {
        data = typeof data === 'object' ? data : {};
        let result = new RolePermissionDtoCrudListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.upsertedItems)) {
            data["upsertedItems"] = [];
            for (let item of this.upsertedItems)
                data["upsertedItems"].push(item.toJSON());
        }
        if (Array.isArray(this.deletedItems)) {
            data["deletedItems"] = [];
            for (let item of this.deletedItems)
                data["deletedItems"].push(item.toJSON());
        }
        return data; 
    }

    clone(): RolePermissionDtoCrudListDto {
        const json = this.toJSON();
        let result = new RolePermissionDtoCrudListDto();
        result.init(json);
        return result;
    }
}

export interface IRolePermissionDtoCrudListDto {
    upsertedItems?: RolePermissionDto[] | undefined;
    deletedItems?: RolePermissionDto[] | undefined;
}

export class SendEmailResetPasswordCommand implements ISendEmailResetPasswordCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    username?: string | undefined;
    email?: string | undefined;
    returnUrl?: string | undefined;

    constructor(data?: ISendEmailResetPasswordCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.username = _data["username"];
            this.email = _data["email"];
            this.returnUrl = _data["returnUrl"];
        }
    }

    static fromJS(data: any): SendEmailResetPasswordCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SendEmailResetPasswordCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["username"] = this.username;
        data["email"] = this.email;
        data["returnUrl"] = this.returnUrl;
        return data; 
    }

    clone(): SendEmailResetPasswordCommand {
        const json = this.toJSON();
        let result = new SendEmailResetPasswordCommand();
        result.init(json);
        return result;
    }
}

export interface ISendEmailResetPasswordCommand {
    commandId?: string;
    occuredDate?: Date;
    username?: string | undefined;
    email?: string | undefined;
    returnUrl?: string | undefined;
}

export class StaffDto implements IStaffDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    salesOrgId?: number;
    staffTypeCode?: string | undefined;
    staffTypeName?: string | undefined;
    updateDate?: Date;
    mobilePhone?: string | undefined;
    birthday?: Date;
    email?: string | undefined;
    userId?: number;
    areaId?: number | undefined;
    zoneId?: number | undefined;

    constructor(data?: IStaffDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.salesOrgId = _data["salesOrgId"];
            this.staffTypeCode = _data["staffTypeCode"];
            this.staffTypeName = _data["staffTypeName"];
            this.updateDate = _data["updateDate"] ? new Date(_data["updateDate"].toString()) : <any>undefined;
            this.mobilePhone = _data["mobilePhone"];
            this.birthday = _data["birthday"] ? new Date(_data["birthday"].toString()) : <any>undefined;
            this.email = _data["email"];
            this.userId = _data["userId"];
            this.areaId = _data["areaId"];
            this.zoneId = _data["zoneId"];
        }
    }

    static fromJS(data: any): StaffDto {
        data = typeof data === 'object' ? data : {};
        let result = new StaffDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["salesOrgId"] = this.salesOrgId;
        data["staffTypeCode"] = this.staffTypeCode;
        data["staffTypeName"] = this.staffTypeName;
        data["updateDate"] = this.updateDate ? this.updateDate.toISOString() : <any>undefined;
        data["mobilePhone"] = this.mobilePhone;
        data["birthday"] = this.birthday ? this.birthday.toISOString() : <any>undefined;
        data["email"] = this.email;
        data["userId"] = this.userId;
        data["areaId"] = this.areaId;
        data["zoneId"] = this.zoneId;
        return data; 
    }

    clone(): StaffDto {
        const json = this.toJSON();
        let result = new StaffDto();
        result.init(json);
        return result;
    }
}

export interface IStaffDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    salesOrgId?: number;
    staffTypeCode?: string | undefined;
    staffTypeName?: string | undefined;
    updateDate?: Date;
    mobilePhone?: string | undefined;
    birthday?: Date;
    email?: string | undefined;
    userId?: number;
    areaId?: number | undefined;
    zoneId?: number | undefined;
}

export class StaffDtoApiResultObject implements IStaffDtoApiResultObject {
    result?: StaffDto;
    success?: boolean;

    constructor(data?: IStaffDtoApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? StaffDto.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): StaffDtoApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new StaffDtoApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data; 
    }

    clone(): StaffDtoApiResultObject {
        const json = this.toJSON();
        let result = new StaffDtoApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IStaffDtoApiResultObject {
    result?: StaffDto;
    success?: boolean;
}

export class StaffListDto implements IStaffListDto {
    id?: number;
    code?: string | undefined;
    name?: string | undefined;
    staffTypeCode?: string | undefined;
    staffTypeName?: string | undefined;
    updateDate?: Date;
    mobilePhone?: string | undefined;
    birthday?: Date | undefined;
    email?: string | undefined;

    constructor(data?: IStaffListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.staffTypeCode = _data["staffTypeCode"];
            this.staffTypeName = _data["staffTypeName"];
            this.updateDate = _data["updateDate"] ? new Date(_data["updateDate"].toString()) : <any>undefined;
            this.mobilePhone = _data["mobilePhone"];
            this.birthday = _data["birthday"] ? new Date(_data["birthday"].toString()) : <any>undefined;
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): StaffListDto {
        data = typeof data === 'object' ? data : {};
        let result = new StaffListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["name"] = this.name;
        data["staffTypeCode"] = this.staffTypeCode;
        data["staffTypeName"] = this.staffTypeName;
        data["updateDate"] = this.updateDate ? this.updateDate.toISOString() : <any>undefined;
        data["mobilePhone"] = this.mobilePhone;
        data["birthday"] = this.birthday ? this.birthday.toISOString() : <any>undefined;
        data["email"] = this.email;
        return data; 
    }

    clone(): StaffListDto {
        const json = this.toJSON();
        let result = new StaffListDto();
        result.init(json);
        return result;
    }
}

export interface IStaffListDto {
    id?: number;
    code?: string | undefined;
    name?: string | undefined;
    staffTypeCode?: string | undefined;
    staffTypeName?: string | undefined;
    updateDate?: Date;
    mobilePhone?: string | undefined;
    birthday?: Date | undefined;
    email?: string | undefined;
}

export class StaffListDtoApiResultObject implements IStaffListDtoApiResultObject {
    result?: StaffListDto;
    success?: boolean;

    constructor(data?: IStaffListDtoApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? StaffListDto.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): StaffListDtoApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new StaffListDtoApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data; 
    }

    clone(): StaffListDtoApiResultObject {
        const json = this.toJSON();
        let result = new StaffListDtoApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IStaffListDtoApiResultObject {
    result?: StaffListDto;
    success?: boolean;
}

export class StaffListDtoPagingResult implements IStaffListDtoPagingResult {
    items?: StaffListDto[] | undefined;
    totalCount?: number;

    constructor(data?: IStaffListDtoPagingResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(StaffListDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): StaffListDtoPagingResult {
        data = typeof data === 'object' ? data : {};
        let result = new StaffListDtoPagingResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): StaffListDtoPagingResult {
        const json = this.toJSON();
        let result = new StaffListDtoPagingResult();
        result.init(json);
        return result;
    }
}

export interface IStaffListDtoPagingResult {
    items?: StaffListDto[] | undefined;
    totalCount?: number;
}

export class StaffListDtoPagingResultApiResultObject implements IStaffListDtoPagingResultApiResultObject {
    result?: StaffListDtoPagingResult;
    success?: boolean;

    constructor(data?: IStaffListDtoPagingResultApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? StaffListDtoPagingResult.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): StaffListDtoPagingResultApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new StaffListDtoPagingResultApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data; 
    }

    clone(): StaffListDtoPagingResultApiResultObject {
        const json = this.toJSON();
        let result = new StaffListDtoPagingResultApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IStaffListDtoPagingResultApiResultObject {
    result?: StaffListDtoPagingResult;
    success?: boolean;
}

export class StaffUpdateCreditPointCommand implements IStaffUpdateCreditPointCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: StaffUpdateCreditPointDto;

    constructor(data?: IStaffUpdateCreditPointCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? StaffUpdateCreditPointDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): StaffUpdateCreditPointCommand {
        data = typeof data === 'object' ? data : {};
        let result = new StaffUpdateCreditPointCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data; 
    }

    clone(): StaffUpdateCreditPointCommand {
        const json = this.toJSON();
        let result = new StaffUpdateCreditPointCommand();
        result.init(json);
        return result;
    }
}

export interface IStaffUpdateCreditPointCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: StaffUpdateCreditPointDto;
}

export class StaffUpdateCreditPointDto implements IStaffUpdateCreditPointDto {
    staffId?: number;
    creditPoint?: number;

    constructor(data?: IStaffUpdateCreditPointDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.staffId = _data["staffId"];
            this.creditPoint = _data["creditPoint"];
        }
    }

    static fromJS(data: any): StaffUpdateCreditPointDto {
        data = typeof data === 'object' ? data : {};
        let result = new StaffUpdateCreditPointDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["staffId"] = this.staffId;
        data["creditPoint"] = this.creditPoint;
        return data; 
    }

    clone(): StaffUpdateCreditPointDto {
        const json = this.toJSON();
        let result = new StaffUpdateCreditPointDto();
        result.init(json);
        return result;
    }
}

export interface IStaffUpdateCreditPointDto {
    staffId?: number;
    creditPoint?: number;
}

export class Stream implements IStream {
    readonly canRead?: boolean;
    readonly canSeek?: boolean;
    readonly canTimeout?: boolean;
    readonly canWrite?: boolean;
    readonly length?: number;
    position?: number;
    readTimeout?: number;
    writeTimeout?: number;

    constructor(data?: IStream) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).canRead = _data["canRead"];
            (<any>this).canSeek = _data["canSeek"];
            (<any>this).canTimeout = _data["canTimeout"];
            (<any>this).canWrite = _data["canWrite"];
            (<any>this).length = _data["length"];
            this.position = _data["position"];
            this.readTimeout = _data["readTimeout"];
            this.writeTimeout = _data["writeTimeout"];
        }
    }

    static fromJS(data: any): Stream {
        data = typeof data === 'object' ? data : {};
        let result = new Stream();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canRead"] = this.canRead;
        data["canSeek"] = this.canSeek;
        data["canTimeout"] = this.canTimeout;
        data["canWrite"] = this.canWrite;
        data["length"] = this.length;
        data["position"] = this.position;
        data["readTimeout"] = this.readTimeout;
        data["writeTimeout"] = this.writeTimeout;
        return data; 
    }

    clone(): Stream {
        const json = this.toJSON();
        let result = new Stream();
        result.init(json);
        return result;
    }
}

export interface IStream {
    canRead?: boolean;
    canSeek?: boolean;
    canTimeout?: boolean;
    canWrite?: boolean;
    length?: number;
    position?: number;
    readTimeout?: number;
    writeTimeout?: number;
}

export class StringApiResultObject implements IStringApiResultObject {
    result?: string | undefined;
    success?: boolean;

    constructor(data?: IStringApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"];
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): StringApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new StringApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result;
        data["success"] = this.success;
        return data; 
    }

    clone(): StringApiResultObject {
        const json = this.toJSON();
        let result = new StringApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IStringApiResultObject {
    result?: string | undefined;
    success?: boolean;
}

export class SubProductClassDto implements ISubProductClassDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    isActive?: boolean;

    constructor(data?: ISubProductClassDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): SubProductClassDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubProductClassDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): SubProductClassDto {
        const json = this.toJSON();
        let result = new SubProductClassDto();
        result.init(json);
        return result;
    }
}

export interface ISubProductClassDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    isActive?: boolean;
}

export class SubProductClassDtoApiResultObject implements ISubProductClassDtoApiResultObject {
    result?: SubProductClassDto;
    success?: boolean;

    constructor(data?: ISubProductClassDtoApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? SubProductClassDto.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): SubProductClassDtoApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new SubProductClassDtoApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data; 
    }

    clone(): SubProductClassDtoApiResultObject {
        const json = this.toJSON();
        let result = new SubProductClassDtoApiResultObject();
        result.init(json);
        return result;
    }
}

export interface ISubProductClassDtoApiResultObject {
    result?: SubProductClassDto;
    success?: boolean;
}

export class SubProductClassDtoPagingResult implements ISubProductClassDtoPagingResult {
    items?: SubProductClassDto[] | undefined;
    totalCount?: number;

    constructor(data?: ISubProductClassDtoPagingResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SubProductClassDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): SubProductClassDtoPagingResult {
        data = typeof data === 'object' ? data : {};
        let result = new SubProductClassDtoPagingResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): SubProductClassDtoPagingResult {
        const json = this.toJSON();
        let result = new SubProductClassDtoPagingResult();
        result.init(json);
        return result;
    }
}

export interface ISubProductClassDtoPagingResult {
    items?: SubProductClassDto[] | undefined;
    totalCount?: number;
}

export class SubProductClassDtoPagingResultApiResultObject implements ISubProductClassDtoPagingResultApiResultObject {
    result?: SubProductClassDtoPagingResult;
    success?: boolean;

    constructor(data?: ISubProductClassDtoPagingResultApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? SubProductClassDtoPagingResult.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): SubProductClassDtoPagingResultApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new SubProductClassDtoPagingResultApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data; 
    }

    clone(): SubProductClassDtoPagingResultApiResultObject {
        const json = this.toJSON();
        let result = new SubProductClassDtoPagingResultApiResultObject();
        result.init(json);
        return result;
    }
}

export interface ISubProductClassDtoPagingResultApiResultObject {
    result?: SubProductClassDtoPagingResult;
    success?: boolean;
}

export class SubProductClassUpsertCommand implements ISubProductClassUpsertCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: SubProductClassUpsertDto;
    readonly handleType?: string | undefined;

    constructor(data?: ISubProductClassUpsertCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? SubProductClassUpsertDto.fromJS(_data["data"]) : <any>undefined;
            (<any>this).handleType = _data["handleType"];
        }
    }

    static fromJS(data: any): SubProductClassUpsertCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SubProductClassUpsertCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["handleType"] = this.handleType;
        return data; 
    }

    clone(): SubProductClassUpsertCommand {
        const json = this.toJSON();
        let result = new SubProductClassUpsertCommand();
        result.init(json);
        return result;
    }
}

export interface ISubProductClassUpsertCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: SubProductClassUpsertDto;
    handleType?: string | undefined;
}

export class SubProductClassUpsertDto implements ISubProductClassUpsertDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    isActive?: boolean;

    constructor(data?: ISubProductClassUpsertDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): SubProductClassUpsertDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubProductClassUpsertDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): SubProductClassUpsertDto {
        const json = this.toJSON();
        let result = new SubProductClassUpsertDto();
        result.init(json);
        return result;
    }
}

export interface ISubProductClassUpsertDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    isActive?: boolean;
}

export class TicketAcceptanceDto implements ITicketAcceptanceDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    acceptanceDate?: Date;
    photo1?: string | undefined;
    photo2?: string | undefined;
    photo3?: string | undefined;
    photo4?: string | undefined;
    photo5?: string | undefined;
    note?: string | undefined;
    updateUserId?: number | undefined;
    updateUserName?: string | undefined;

    constructor(data?: ITicketAcceptanceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.acceptanceDate = _data["acceptanceDate"] ? new Date(_data["acceptanceDate"].toString()) : <any>undefined;
            this.photo1 = _data["photo1"];
            this.photo2 = _data["photo2"];
            this.photo3 = _data["photo3"];
            this.photo4 = _data["photo4"];
            this.photo5 = _data["photo5"];
            this.note = _data["note"];
            this.updateUserId = _data["updateUserId"];
            this.updateUserName = _data["updateUserName"];
        }
    }

    static fromJS(data: any): TicketAcceptanceDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketAcceptanceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["acceptanceDate"] = this.acceptanceDate ? this.acceptanceDate.toISOString() : <any>undefined;
        data["photo1"] = this.photo1;
        data["photo2"] = this.photo2;
        data["photo3"] = this.photo3;
        data["photo4"] = this.photo4;
        data["photo5"] = this.photo5;
        data["note"] = this.note;
        data["updateUserId"] = this.updateUserId;
        data["updateUserName"] = this.updateUserName;
        return data; 
    }

    clone(): TicketAcceptanceDto {
        const json = this.toJSON();
        let result = new TicketAcceptanceDto();
        result.init(json);
        return result;
    }
}

export interface ITicketAcceptanceDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    acceptanceDate?: Date;
    photo1?: string | undefined;
    photo2?: string | undefined;
    photo3?: string | undefined;
    photo4?: string | undefined;
    photo5?: string | undefined;
    note?: string | undefined;
    updateUserId?: number | undefined;
    updateUserName?: string | undefined;
}

export class TicketConsumerRewardDetailDto implements ITicketConsumerRewardDetailDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    ticketId?: number;
    ticketCode?: string | undefined;
    consumerName?: string | undefined;
    consumerPhone?: string | undefined;
    note?: string | undefined;

    constructor(data?: ITicketConsumerRewardDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.ticketId = _data["ticketId"];
            this.ticketCode = _data["ticketCode"];
            this.consumerName = _data["consumerName"];
            this.consumerPhone = _data["consumerPhone"];
            this.note = _data["note"];
        }
    }

    static fromJS(data: any): TicketConsumerRewardDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketConsumerRewardDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["ticketId"] = this.ticketId;
        data["ticketCode"] = this.ticketCode;
        data["consumerName"] = this.consumerName;
        data["consumerPhone"] = this.consumerPhone;
        data["note"] = this.note;
        return data; 
    }

    clone(): TicketConsumerRewardDetailDto {
        const json = this.toJSON();
        let result = new TicketConsumerRewardDetailDto();
        result.init(json);
        return result;
    }
}

export interface ITicketConsumerRewardDetailDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    ticketId?: number;
    ticketCode?: string | undefined;
    consumerName?: string | undefined;
    consumerPhone?: string | undefined;
    note?: string | undefined;
}

export class TicketConsumerRewardDto implements ITicketConsumerRewardDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    photo1?: string | undefined;
    photo2?: string | undefined;
    photo3?: string | undefined;
    photo4?: string | undefined;
    photo5?: string | undefined;
    rewardItemId?: number;
    rewardItemCode?: string | undefined;
    rewardItemName?: string | undefined;
    quantity?: number;
    rewardQuantity?: number;
    details?: TicketConsumerRewardDetailDto[] | undefined;

    constructor(data?: ITicketConsumerRewardDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.photo1 = _data["photo1"];
            this.photo2 = _data["photo2"];
            this.photo3 = _data["photo3"];
            this.photo4 = _data["photo4"];
            this.photo5 = _data["photo5"];
            this.rewardItemId = _data["rewardItemId"];
            this.rewardItemCode = _data["rewardItemCode"];
            this.rewardItemName = _data["rewardItemName"];
            this.quantity = _data["quantity"];
            this.rewardQuantity = _data["rewardQuantity"];
            if (Array.isArray(_data["details"])) {
                this.details = [] as any;
                for (let item of _data["details"])
                    this.details!.push(TicketConsumerRewardDetailDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TicketConsumerRewardDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketConsumerRewardDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["photo1"] = this.photo1;
        data["photo2"] = this.photo2;
        data["photo3"] = this.photo3;
        data["photo4"] = this.photo4;
        data["photo5"] = this.photo5;
        data["rewardItemId"] = this.rewardItemId;
        data["rewardItemCode"] = this.rewardItemCode;
        data["rewardItemName"] = this.rewardItemName;
        data["quantity"] = this.quantity;
        data["rewardQuantity"] = this.rewardQuantity;
        if (Array.isArray(this.details)) {
            data["details"] = [];
            for (let item of this.details)
                data["details"].push(item.toJSON());
        }
        return data; 
    }

    clone(): TicketConsumerRewardDto {
        const json = this.toJSON();
        let result = new TicketConsumerRewardDto();
        result.init(json);
        return result;
    }
}

export interface ITicketConsumerRewardDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    photo1?: string | undefined;
    photo2?: string | undefined;
    photo3?: string | undefined;
    photo4?: string | undefined;
    photo5?: string | undefined;
    rewardItemId?: number;
    rewardItemCode?: string | undefined;
    rewardItemName?: string | undefined;
    quantity?: number;
    rewardQuantity?: number;
    details?: TicketConsumerRewardDetailDto[] | undefined;
}

export class TicketConsumerRewardDtoApiResultObject implements ITicketConsumerRewardDtoApiResultObject {
    result?: TicketConsumerRewardDto;
    success?: boolean;

    constructor(data?: ITicketConsumerRewardDtoApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? TicketConsumerRewardDto.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): TicketConsumerRewardDtoApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new TicketConsumerRewardDtoApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data; 
    }

    clone(): TicketConsumerRewardDtoApiResultObject {
        const json = this.toJSON();
        let result = new TicketConsumerRewardDtoApiResultObject();
        result.init(json);
        return result;
    }
}

export interface ITicketConsumerRewardDtoApiResultObject {
    result?: TicketConsumerRewardDto;
    success?: boolean;
}

export class TicketDto implements ITicketDto {
    id?: number;
    code?: string | undefined;
    consumerPhone?: string | undefined;
    consumerName?: string | undefined;
    issueDate?: Date | undefined;
    printDate?: Date | undefined;
    printCount?: number;
    lastPrintUserId?: number | undefined;
    ticketInvestmentId?: number;
    lastPrintUserName?: string | undefined;

    constructor(data?: ITicketDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.consumerPhone = _data["consumerPhone"];
            this.consumerName = _data["consumerName"];
            this.issueDate = _data["issueDate"] ? new Date(_data["issueDate"].toString()) : <any>undefined;
            this.printDate = _data["printDate"] ? new Date(_data["printDate"].toString()) : <any>undefined;
            this.printCount = _data["printCount"];
            this.lastPrintUserId = _data["lastPrintUserId"];
            this.ticketInvestmentId = _data["ticketInvestmentId"];
            this.lastPrintUserName = _data["lastPrintUserName"];
        }
    }

    static fromJS(data: any): TicketDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["consumerPhone"] = this.consumerPhone;
        data["consumerName"] = this.consumerName;
        data["issueDate"] = this.issueDate ? this.issueDate.toISOString() : <any>undefined;
        data["printDate"] = this.printDate ? this.printDate.toISOString() : <any>undefined;
        data["printCount"] = this.printCount;
        data["lastPrintUserId"] = this.lastPrintUserId;
        data["ticketInvestmentId"] = this.ticketInvestmentId;
        data["lastPrintUserName"] = this.lastPrintUserName;
        return data; 
    }

    clone(): TicketDto {
        const json = this.toJSON();
        let result = new TicketDto();
        result.init(json);
        return result;
    }
}

export interface ITicketDto {
    id?: number;
    code?: string | undefined;
    consumerPhone?: string | undefined;
    consumerName?: string | undefined;
    issueDate?: Date | undefined;
    printDate?: Date | undefined;
    printCount?: number;
    lastPrintUserId?: number | undefined;
    ticketInvestmentId?: number;
    lastPrintUserName?: string | undefined;
}

export class TicketDtoApiResultObject implements ITicketDtoApiResultObject {
    result?: TicketDto;
    success?: boolean;

    constructor(data?: ITicketDtoApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? TicketDto.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): TicketDtoApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new TicketDtoApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data; 
    }

    clone(): TicketDtoApiResultObject {
        const json = this.toJSON();
        let result = new TicketDtoApiResultObject();
        result.init(json);
        return result;
    }
}

export interface ITicketDtoApiResultObject {
    result?: TicketDto;
    success?: boolean;
}

export class TicketDtoPagingResult implements ITicketDtoPagingResult {
    items?: TicketDto[] | undefined;
    totalCount?: number;

    constructor(data?: ITicketDtoPagingResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TicketDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): TicketDtoPagingResult {
        data = typeof data === 'object' ? data : {};
        let result = new TicketDtoPagingResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): TicketDtoPagingResult {
        const json = this.toJSON();
        let result = new TicketDtoPagingResult();
        result.init(json);
        return result;
    }
}

export interface ITicketDtoPagingResult {
    items?: TicketDto[] | undefined;
    totalCount?: number;
}

export class TicketDtoPagingResultApiResultObject implements ITicketDtoPagingResultApiResultObject {
    result?: TicketDtoPagingResult;
    success?: boolean;

    constructor(data?: ITicketDtoPagingResultApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? TicketDtoPagingResult.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): TicketDtoPagingResultApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new TicketDtoPagingResultApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data; 
    }

    clone(): TicketDtoPagingResultApiResultObject {
        const json = this.toJSON();
        let result = new TicketDtoPagingResultApiResultObject();
        result.init(json);
        return result;
    }
}

export interface ITicketDtoPagingResultApiResultObject {
    result?: TicketDtoPagingResult;
    success?: boolean;
}

export class TicketFinalSettlementDto implements ITicketFinalSettlementDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    date?: Date;
    note?: string | undefined;
    decideUserId?: number | undefined;
    decideUserName?: string | undefined;
    updateUserId?: number | undefined;
    updateUserName?: string | undefined;

    constructor(data?: ITicketFinalSettlementDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.note = _data["note"];
            this.decideUserId = _data["decideUserId"];
            this.decideUserName = _data["decideUserName"];
            this.updateUserId = _data["updateUserId"];
            this.updateUserName = _data["updateUserName"];
        }
    }

    static fromJS(data: any): TicketFinalSettlementDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketFinalSettlementDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["note"] = this.note;
        data["decideUserId"] = this.decideUserId;
        data["decideUserName"] = this.decideUserName;
        data["updateUserId"] = this.updateUserId;
        data["updateUserName"] = this.updateUserName;
        return data; 
    }

    clone(): TicketFinalSettlementDto {
        const json = this.toJSON();
        let result = new TicketFinalSettlementDto();
        result.init(json);
        return result;
    }
}

export interface ITicketFinalSettlementDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    date?: Date;
    note?: string | undefined;
    decideUserId?: number | undefined;
    decideUserName?: string | undefined;
    updateUserId?: number | undefined;
    updateUserName?: string | undefined;
}

export class TicketGetByConsumerDto implements ITicketGetByConsumerDto {
    ticketCode?: string | undefined;
    operationDate?: Date | undefined;
    endDate?: Date | undefined;
    shopCode?: string | undefined;
    shopName?: string | undefined;
    shopAddress?: string | undefined;

    constructor(data?: ITicketGetByConsumerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ticketCode = _data["ticketCode"];
            this.operationDate = _data["operationDate"] ? new Date(_data["operationDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.shopCode = _data["shopCode"];
            this.shopName = _data["shopName"];
            this.shopAddress = _data["shopAddress"];
        }
    }

    static fromJS(data: any): TicketGetByConsumerDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketGetByConsumerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ticketCode"] = this.ticketCode;
        data["operationDate"] = this.operationDate ? this.operationDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["shopCode"] = this.shopCode;
        data["shopName"] = this.shopName;
        data["shopAddress"] = this.shopAddress;
        return data; 
    }

    clone(): TicketGetByConsumerDto {
        const json = this.toJSON();
        let result = new TicketGetByConsumerDto();
        result.init(json);
        return result;
    }
}

export interface ITicketGetByConsumerDto {
    ticketCode?: string | undefined;
    operationDate?: Date | undefined;
    endDate?: Date | undefined;
    shopCode?: string | undefined;
    shopName?: string | undefined;
    shopAddress?: string | undefined;
}

export class TicketGetByConsumerDtoListApiResultObject implements ITicketGetByConsumerDtoListApiResultObject {
    result?: TicketGetByConsumerDto[] | undefined;
    success?: boolean;

    constructor(data?: ITicketGetByConsumerDtoListApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(TicketGetByConsumerDto.fromJS(item));
            }
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): TicketGetByConsumerDtoListApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new TicketGetByConsumerDtoListApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["success"] = this.success;
        return data; 
    }

    clone(): TicketGetByConsumerDtoListApiResultObject {
        const json = this.toJSON();
        let result = new TicketGetByConsumerDtoListApiResultObject();
        result.init(json);
        return result;
    }
}

export interface ITicketGetByConsumerDtoListApiResultObject {
    result?: TicketGetByConsumerDto[] | undefined;
    success?: boolean;
}

export class TicketInvestmentCompanyRemarkCommand implements ITicketInvestmentCompanyRemarkCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: TicketInvestmentRemarkDto;
    handleType?: string | undefined;

    constructor(data?: ITicketInvestmentCompanyRemarkCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? TicketInvestmentRemarkDto.fromJS(_data["data"]) : <any>undefined;
            this.handleType = _data["handleType"];
        }
    }

    static fromJS(data: any): TicketInvestmentCompanyRemarkCommand {
        data = typeof data === 'object' ? data : {};
        let result = new TicketInvestmentCompanyRemarkCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["handleType"] = this.handleType;
        return data; 
    }

    clone(): TicketInvestmentCompanyRemarkCommand {
        const json = this.toJSON();
        let result = new TicketInvestmentCompanyRemarkCommand();
        result.init(json);
        return result;
    }
}

export interface ITicketInvestmentCompanyRemarkCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: TicketInvestmentRemarkDto;
    handleType?: string | undefined;
}

export class TicketInvestmentCustomerDevelopmentRemarkCommand implements ITicketInvestmentCustomerDevelopmentRemarkCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: TicketInvestmentRemarkDto;
    handleType?: string | undefined;

    constructor(data?: ITicketInvestmentCustomerDevelopmentRemarkCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? TicketInvestmentRemarkDto.fromJS(_data["data"]) : <any>undefined;
            this.handleType = _data["handleType"];
        }
    }

    static fromJS(data: any): TicketInvestmentCustomerDevelopmentRemarkCommand {
        data = typeof data === 'object' ? data : {};
        let result = new TicketInvestmentCustomerDevelopmentRemarkCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["handleType"] = this.handleType;
        return data; 
    }

    clone(): TicketInvestmentCustomerDevelopmentRemarkCommand {
        const json = this.toJSON();
        let result = new TicketInvestmentCustomerDevelopmentRemarkCommand();
        result.init(json);
        return result;
    }
}

export interface ITicketInvestmentCustomerDevelopmentRemarkCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: TicketInvestmentRemarkDto;
    handleType?: string | undefined;
}

export class TicketInvestmentDto implements ITicketInvestmentDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    customerId?: number;
    customerName?: string | undefined;
    efficient?: number | undefined;
    mobilePhone?: string | undefined;
    address?: string | undefined;
    registerStaffId?: number;
    stockQuantity?: number;
    rewardPackageId?: number;
    budgetId?: number;
    cycleId?: number;
    ticketQuantity?: number;
    pointsForTicket?: number;
    salesPlanAmount?: number;
    commitmentAmount?: number;
    rewardAmount?: number;
    materialAmount?: number;
    investmentAmount?: number;
    buyBeginDate?: Date;
    buyEndDate?: Date;
    issueTicketBeginDate?: Date;
    issueTicketEndDate?: Date;
    status?: number;
    operationDate?: Date;
    registerNote?: string | undefined;
    surveyPhoto1?: string | undefined;
    surveyPhoto2?: string | undefined;
    surveyPhoto3?: string | undefined;
    surveyPhoto4?: string | undefined;
    surveyPhoto5?: string | undefined;
    printTicketQuantity?: number;
    smsTicketQuantity?: number;
    actualSalesAmount?: number;
    materials?: TicketMaterialDto[] | undefined;
    rewardItems?: TicketRewardItemDto[] | undefined;
    salesCommitments?: TicketSalesCommitmentDto[] | undefined;
    consumerRewards?: TicketConsumerRewardDto[] | undefined;
    progresses?: TicketProgressDto[] | undefined;
    acceptance?: TicketAcceptanceDto;
    operation?: TicketOperationDto;
    finalSettlement?: TicketFinalSettlementDto;

    constructor(data?: ITicketInvestmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.customerId = _data["customerId"];
            this.customerName = _data["customerName"];
            this.efficient = _data["efficient"];
            this.mobilePhone = _data["mobilePhone"];
            this.address = _data["address"];
            this.registerStaffId = _data["registerStaffId"];
            this.stockQuantity = _data["stockQuantity"];
            this.rewardPackageId = _data["rewardPackageId"];
            this.budgetId = _data["budgetId"];
            this.cycleId = _data["cycleId"];
            this.ticketQuantity = _data["ticketQuantity"];
            this.pointsForTicket = _data["pointsForTicket"];
            this.salesPlanAmount = _data["salesPlanAmount"];
            this.commitmentAmount = _data["commitmentAmount"];
            this.rewardAmount = _data["rewardAmount"];
            this.materialAmount = _data["materialAmount"];
            this.investmentAmount = _data["investmentAmount"];
            this.buyBeginDate = _data["buyBeginDate"] ? new Date(_data["buyBeginDate"].toString()) : <any>undefined;
            this.buyEndDate = _data["buyEndDate"] ? new Date(_data["buyEndDate"].toString()) : <any>undefined;
            this.issueTicketBeginDate = _data["issueTicketBeginDate"] ? new Date(_data["issueTicketBeginDate"].toString()) : <any>undefined;
            this.issueTicketEndDate = _data["issueTicketEndDate"] ? new Date(_data["issueTicketEndDate"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.operationDate = _data["operationDate"] ? new Date(_data["operationDate"].toString()) : <any>undefined;
            this.registerNote = _data["registerNote"];
            this.surveyPhoto1 = _data["surveyPhoto1"];
            this.surveyPhoto2 = _data["surveyPhoto2"];
            this.surveyPhoto3 = _data["surveyPhoto3"];
            this.surveyPhoto4 = _data["surveyPhoto4"];
            this.surveyPhoto5 = _data["surveyPhoto5"];
            this.printTicketQuantity = _data["printTicketQuantity"];
            this.smsTicketQuantity = _data["smsTicketQuantity"];
            this.actualSalesAmount = _data["actualSalesAmount"];
            if (Array.isArray(_data["materials"])) {
                this.materials = [] as any;
                for (let item of _data["materials"])
                    this.materials!.push(TicketMaterialDto.fromJS(item));
            }
            if (Array.isArray(_data["rewardItems"])) {
                this.rewardItems = [] as any;
                for (let item of _data["rewardItems"])
                    this.rewardItems!.push(TicketRewardItemDto.fromJS(item));
            }
            if (Array.isArray(_data["salesCommitments"])) {
                this.salesCommitments = [] as any;
                for (let item of _data["salesCommitments"])
                    this.salesCommitments!.push(TicketSalesCommitmentDto.fromJS(item));
            }
            if (Array.isArray(_data["consumerRewards"])) {
                this.consumerRewards = [] as any;
                for (let item of _data["consumerRewards"])
                    this.consumerRewards!.push(TicketConsumerRewardDto.fromJS(item));
            }
            if (Array.isArray(_data["progresses"])) {
                this.progresses = [] as any;
                for (let item of _data["progresses"])
                    this.progresses!.push(TicketProgressDto.fromJS(item));
            }
            this.acceptance = _data["acceptance"] ? TicketAcceptanceDto.fromJS(_data["acceptance"]) : <any>undefined;
            this.operation = _data["operation"] ? TicketOperationDto.fromJS(_data["operation"]) : <any>undefined;
            this.finalSettlement = _data["finalSettlement"] ? TicketFinalSettlementDto.fromJS(_data["finalSettlement"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TicketInvestmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketInvestmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["customerId"] = this.customerId;
        data["customerName"] = this.customerName;
        data["efficient"] = this.efficient;
        data["mobilePhone"] = this.mobilePhone;
        data["address"] = this.address;
        data["registerStaffId"] = this.registerStaffId;
        data["stockQuantity"] = this.stockQuantity;
        data["rewardPackageId"] = this.rewardPackageId;
        data["budgetId"] = this.budgetId;
        data["cycleId"] = this.cycleId;
        data["ticketQuantity"] = this.ticketQuantity;
        data["pointsForTicket"] = this.pointsForTicket;
        data["salesPlanAmount"] = this.salesPlanAmount;
        data["commitmentAmount"] = this.commitmentAmount;
        data["rewardAmount"] = this.rewardAmount;
        data["materialAmount"] = this.materialAmount;
        data["investmentAmount"] = this.investmentAmount;
        data["buyBeginDate"] = this.buyBeginDate ? this.buyBeginDate.toISOString() : <any>undefined;
        data["buyEndDate"] = this.buyEndDate ? this.buyEndDate.toISOString() : <any>undefined;
        data["issueTicketBeginDate"] = this.issueTicketBeginDate ? this.issueTicketBeginDate.toISOString() : <any>undefined;
        data["issueTicketEndDate"] = this.issueTicketEndDate ? this.issueTicketEndDate.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["operationDate"] = this.operationDate ? this.operationDate.toISOString() : <any>undefined;
        data["registerNote"] = this.registerNote;
        data["surveyPhoto1"] = this.surveyPhoto1;
        data["surveyPhoto2"] = this.surveyPhoto2;
        data["surveyPhoto3"] = this.surveyPhoto3;
        data["surveyPhoto4"] = this.surveyPhoto4;
        data["surveyPhoto5"] = this.surveyPhoto5;
        data["printTicketQuantity"] = this.printTicketQuantity;
        data["smsTicketQuantity"] = this.smsTicketQuantity;
        data["actualSalesAmount"] = this.actualSalesAmount;
        if (Array.isArray(this.materials)) {
            data["materials"] = [];
            for (let item of this.materials)
                data["materials"].push(item.toJSON());
        }
        if (Array.isArray(this.rewardItems)) {
            data["rewardItems"] = [];
            for (let item of this.rewardItems)
                data["rewardItems"].push(item.toJSON());
        }
        if (Array.isArray(this.salesCommitments)) {
            data["salesCommitments"] = [];
            for (let item of this.salesCommitments)
                data["salesCommitments"].push(item.toJSON());
        }
        if (Array.isArray(this.consumerRewards)) {
            data["consumerRewards"] = [];
            for (let item of this.consumerRewards)
                data["consumerRewards"].push(item.toJSON());
        }
        if (Array.isArray(this.progresses)) {
            data["progresses"] = [];
            for (let item of this.progresses)
                data["progresses"].push(item.toJSON());
        }
        data["acceptance"] = this.acceptance ? this.acceptance.toJSON() : <any>undefined;
        data["operation"] = this.operation ? this.operation.toJSON() : <any>undefined;
        data["finalSettlement"] = this.finalSettlement ? this.finalSettlement.toJSON() : <any>undefined;
        return data; 
    }

    clone(): TicketInvestmentDto {
        const json = this.toJSON();
        let result = new TicketInvestmentDto();
        result.init(json);
        return result;
    }
}

export interface ITicketInvestmentDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    customerId?: number;
    customerName?: string | undefined;
    efficient?: number | undefined;
    mobilePhone?: string | undefined;
    address?: string | undefined;
    registerStaffId?: number;
    stockQuantity?: number;
    rewardPackageId?: number;
    budgetId?: number;
    cycleId?: number;
    ticketQuantity?: number;
    pointsForTicket?: number;
    salesPlanAmount?: number;
    commitmentAmount?: number;
    rewardAmount?: number;
    materialAmount?: number;
    investmentAmount?: number;
    buyBeginDate?: Date;
    buyEndDate?: Date;
    issueTicketBeginDate?: Date;
    issueTicketEndDate?: Date;
    status?: number;
    operationDate?: Date;
    registerNote?: string | undefined;
    surveyPhoto1?: string | undefined;
    surveyPhoto2?: string | undefined;
    surveyPhoto3?: string | undefined;
    surveyPhoto4?: string | undefined;
    surveyPhoto5?: string | undefined;
    printTicketQuantity?: number;
    smsTicketQuantity?: number;
    actualSalesAmount?: number;
    materials?: TicketMaterialDto[] | undefined;
    rewardItems?: TicketRewardItemDto[] | undefined;
    salesCommitments?: TicketSalesCommitmentDto[] | undefined;
    consumerRewards?: TicketConsumerRewardDto[] | undefined;
    progresses?: TicketProgressDto[] | undefined;
    acceptance?: TicketAcceptanceDto;
    operation?: TicketOperationDto;
    finalSettlement?: TicketFinalSettlementDto;
}

export class TicketInvestmentDtoApiResultObject implements ITicketInvestmentDtoApiResultObject {
    result?: TicketInvestmentDto;
    success?: boolean;

    constructor(data?: ITicketInvestmentDtoApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? TicketInvestmentDto.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): TicketInvestmentDtoApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new TicketInvestmentDtoApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data; 
    }

    clone(): TicketInvestmentDtoApiResultObject {
        const json = this.toJSON();
        let result = new TicketInvestmentDtoApiResultObject();
        result.init(json);
        return result;
    }
}

export interface ITicketInvestmentDtoApiResultObject {
    result?: TicketInvestmentDto;
    success?: boolean;
}

export class TicketInvestmentHistoryDto implements ITicketInvestmentHistoryDto {
    id?: number;
    userId?: number;
    userCode?: string | undefined;
    userName?: string | undefined;
    status?: number;
    data?: string | undefined;
    creationTime?: Date;

    constructor(data?: ITicketInvestmentHistoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.userCode = _data["userCode"];
            this.userName = _data["userName"];
            this.status = _data["status"];
            this.data = _data["data"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): TicketInvestmentHistoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketInvestmentHistoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["userCode"] = this.userCode;
        data["userName"] = this.userName;
        data["status"] = this.status;
        data["data"] = this.data;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data; 
    }

    clone(): TicketInvestmentHistoryDto {
        const json = this.toJSON();
        let result = new TicketInvestmentHistoryDto();
        result.init(json);
        return result;
    }
}

export interface ITicketInvestmentHistoryDto {
    id?: number;
    userId?: number;
    userCode?: string | undefined;
    userName?: string | undefined;
    status?: number;
    data?: string | undefined;
    creationTime?: Date;
}

export class TicketInvestmentHistoryDtoListApiResultObject implements ITicketInvestmentHistoryDtoListApiResultObject {
    result?: TicketInvestmentHistoryDto[] | undefined;
    success?: boolean;

    constructor(data?: ITicketInvestmentHistoryDtoListApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(TicketInvestmentHistoryDto.fromJS(item));
            }
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): TicketInvestmentHistoryDtoListApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new TicketInvestmentHistoryDtoListApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["success"] = this.success;
        return data; 
    }

    clone(): TicketInvestmentHistoryDtoListApiResultObject {
        const json = this.toJSON();
        let result = new TicketInvestmentHistoryDtoListApiResultObject();
        result.init(json);
        return result;
    }
}

export interface ITicketInvestmentHistoryDtoListApiResultObject {
    result?: TicketInvestmentHistoryDto[] | undefined;
    success?: boolean;
}

export class TicketInvestmentListItemDto implements ITicketInvestmentListItemDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    cycleId?: number;
    customerId?: number;
    customerCode?: string | undefined;
    customerName?: string | undefined;
    email?: string | undefined;
    mobilePhone?: string | undefined;
    address?: string | undefined;
    registerStaffId?: number;
    registerStaffName?: string | undefined;
    stockQuantity?: number;
    rewardPackageId?: number;
    rewardPackageName?: string | undefined;
    ticketQuantity?: number;
    pointsForTicket?: number;
    salesPlanAmount?: number;
    commitmentAmount?: number;
    rewardAmount?: number;
    materialAmount?: number;
    investmentAmount?: number;
    buyBeginDate?: Date;
    buyEndDate?: Date;
    issueTicketBeginDate?: Date;
    issueTicketEndDate?: Date;
    status?: number;
    operationDate?: Date;
    remarkOfCompany?: number | undefined;
    zoneName?: string | undefined;
    areaName?: string | undefined;

    constructor(data?: ITicketInvestmentListItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.cycleId = _data["cycleId"];
            this.customerId = _data["customerId"];
            this.customerCode = _data["customerCode"];
            this.customerName = _data["customerName"];
            this.email = _data["email"];
            this.mobilePhone = _data["mobilePhone"];
            this.address = _data["address"];
            this.registerStaffId = _data["registerStaffId"];
            this.registerStaffName = _data["registerStaffName"];
            this.stockQuantity = _data["stockQuantity"];
            this.rewardPackageId = _data["rewardPackageId"];
            this.rewardPackageName = _data["rewardPackageName"];
            this.ticketQuantity = _data["ticketQuantity"];
            this.pointsForTicket = _data["pointsForTicket"];
            this.salesPlanAmount = _data["salesPlanAmount"];
            this.commitmentAmount = _data["commitmentAmount"];
            this.rewardAmount = _data["rewardAmount"];
            this.materialAmount = _data["materialAmount"];
            this.investmentAmount = _data["investmentAmount"];
            this.buyBeginDate = _data["buyBeginDate"] ? new Date(_data["buyBeginDate"].toString()) : <any>undefined;
            this.buyEndDate = _data["buyEndDate"] ? new Date(_data["buyEndDate"].toString()) : <any>undefined;
            this.issueTicketBeginDate = _data["issueTicketBeginDate"] ? new Date(_data["issueTicketBeginDate"].toString()) : <any>undefined;
            this.issueTicketEndDate = _data["issueTicketEndDate"] ? new Date(_data["issueTicketEndDate"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.operationDate = _data["operationDate"] ? new Date(_data["operationDate"].toString()) : <any>undefined;
            this.remarkOfCompany = _data["remarkOfCompany"];
            this.zoneName = _data["zoneName"];
            this.areaName = _data["areaName"];
        }
    }

    static fromJS(data: any): TicketInvestmentListItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketInvestmentListItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["cycleId"] = this.cycleId;
        data["customerId"] = this.customerId;
        data["customerCode"] = this.customerCode;
        data["customerName"] = this.customerName;
        data["email"] = this.email;
        data["mobilePhone"] = this.mobilePhone;
        data["address"] = this.address;
        data["registerStaffId"] = this.registerStaffId;
        data["registerStaffName"] = this.registerStaffName;
        data["stockQuantity"] = this.stockQuantity;
        data["rewardPackageId"] = this.rewardPackageId;
        data["rewardPackageName"] = this.rewardPackageName;
        data["ticketQuantity"] = this.ticketQuantity;
        data["pointsForTicket"] = this.pointsForTicket;
        data["salesPlanAmount"] = this.salesPlanAmount;
        data["commitmentAmount"] = this.commitmentAmount;
        data["rewardAmount"] = this.rewardAmount;
        data["materialAmount"] = this.materialAmount;
        data["investmentAmount"] = this.investmentAmount;
        data["buyBeginDate"] = this.buyBeginDate ? this.buyBeginDate.toISOString() : <any>undefined;
        data["buyEndDate"] = this.buyEndDate ? this.buyEndDate.toISOString() : <any>undefined;
        data["issueTicketBeginDate"] = this.issueTicketBeginDate ? this.issueTicketBeginDate.toISOString() : <any>undefined;
        data["issueTicketEndDate"] = this.issueTicketEndDate ? this.issueTicketEndDate.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["operationDate"] = this.operationDate ? this.operationDate.toISOString() : <any>undefined;
        data["remarkOfCompany"] = this.remarkOfCompany;
        data["zoneName"] = this.zoneName;
        data["areaName"] = this.areaName;
        return data; 
    }

    clone(): TicketInvestmentListItemDto {
        const json = this.toJSON();
        let result = new TicketInvestmentListItemDto();
        result.init(json);
        return result;
    }
}

export interface ITicketInvestmentListItemDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    cycleId?: number;
    customerId?: number;
    customerCode?: string | undefined;
    customerName?: string | undefined;
    email?: string | undefined;
    mobilePhone?: string | undefined;
    address?: string | undefined;
    registerStaffId?: number;
    registerStaffName?: string | undefined;
    stockQuantity?: number;
    rewardPackageId?: number;
    rewardPackageName?: string | undefined;
    ticketQuantity?: number;
    pointsForTicket?: number;
    salesPlanAmount?: number;
    commitmentAmount?: number;
    rewardAmount?: number;
    materialAmount?: number;
    investmentAmount?: number;
    buyBeginDate?: Date;
    buyEndDate?: Date;
    issueTicketBeginDate?: Date;
    issueTicketEndDate?: Date;
    status?: number;
    operationDate?: Date;
    remarkOfCompany?: number | undefined;
    zoneName?: string | undefined;
    areaName?: string | undefined;
}

export class TicketInvestmentListItemDtoPagingResult implements ITicketInvestmentListItemDtoPagingResult {
    items?: TicketInvestmentListItemDto[] | undefined;
    totalCount?: number;

    constructor(data?: ITicketInvestmentListItemDtoPagingResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TicketInvestmentListItemDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): TicketInvestmentListItemDtoPagingResult {
        data = typeof data === 'object' ? data : {};
        let result = new TicketInvestmentListItemDtoPagingResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): TicketInvestmentListItemDtoPagingResult {
        const json = this.toJSON();
        let result = new TicketInvestmentListItemDtoPagingResult();
        result.init(json);
        return result;
    }
}

export interface ITicketInvestmentListItemDtoPagingResult {
    items?: TicketInvestmentListItemDto[] | undefined;
    totalCount?: number;
}

export class TicketInvestmentListItemDtoPagingResultApiResultObject implements ITicketInvestmentListItemDtoPagingResultApiResultObject {
    result?: TicketInvestmentListItemDtoPagingResult;
    success?: boolean;

    constructor(data?: ITicketInvestmentListItemDtoPagingResultApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? TicketInvestmentListItemDtoPagingResult.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): TicketInvestmentListItemDtoPagingResultApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new TicketInvestmentListItemDtoPagingResultApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data; 
    }

    clone(): TicketInvestmentListItemDtoPagingResultApiResultObject {
        const json = this.toJSON();
        let result = new TicketInvestmentListItemDtoPagingResultApiResultObject();
        result.init(json);
        return result;
    }
}

export interface ITicketInvestmentListItemDtoPagingResultApiResultObject {
    result?: TicketInvestmentListItemDtoPagingResult;
    success?: boolean;
}

export class TicketInvestmentOperateCommand implements ITicketInvestmentOperateCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: TicketInvestmentOperateDto;
    handleType?: string | undefined;

    constructor(data?: ITicketInvestmentOperateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? TicketInvestmentOperateDto.fromJS(_data["data"]) : <any>undefined;
            this.handleType = _data["handleType"];
        }
    }

    static fromJS(data: any): TicketInvestmentOperateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new TicketInvestmentOperateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["handleType"] = this.handleType;
        return data; 
    }

    clone(): TicketInvestmentOperateCommand {
        const json = this.toJSON();
        let result = new TicketInvestmentOperateCommand();
        result.init(json);
        return result;
    }
}

export interface ITicketInvestmentOperateCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: TicketInvestmentOperateDto;
    handleType?: string | undefined;
}

export class TicketInvestmentOperateDto implements ITicketInvestmentOperateDto {
    id?: number;
    operationDate?: Date;
    note?: string | undefined;
    stockQuantity?: number;
    photo1?: string | undefined;
    photo2?: string | undefined;
    photo3?: string | undefined;
    photo4?: string | undefined;
    photo5?: string | undefined;

    constructor(data?: ITicketInvestmentOperateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.operationDate = _data["operationDate"] ? new Date(_data["operationDate"].toString()) : <any>undefined;
            this.note = _data["note"];
            this.stockQuantity = _data["stockQuantity"];
            this.photo1 = _data["photo1"];
            this.photo2 = _data["photo2"];
            this.photo3 = _data["photo3"];
            this.photo4 = _data["photo4"];
            this.photo5 = _data["photo5"];
        }
    }

    static fromJS(data: any): TicketInvestmentOperateDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketInvestmentOperateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["operationDate"] = this.operationDate ? this.operationDate.toISOString() : <any>undefined;
        data["note"] = this.note;
        data["stockQuantity"] = this.stockQuantity;
        data["photo1"] = this.photo1;
        data["photo2"] = this.photo2;
        data["photo3"] = this.photo3;
        data["photo4"] = this.photo4;
        data["photo5"] = this.photo5;
        return data; 
    }

    clone(): TicketInvestmentOperateDto {
        const json = this.toJSON();
        let result = new TicketInvestmentOperateDto();
        result.init(json);
        return result;
    }
}

export interface ITicketInvestmentOperateDto {
    id?: number;
    operationDate?: Date;
    note?: string | undefined;
    stockQuantity?: number;
    photo1?: string | undefined;
    photo2?: string | undefined;
    photo3?: string | undefined;
    photo4?: string | undefined;
    photo5?: string | undefined;
}

export class TicketInvestmentRegisterCommand implements ITicketInvestmentRegisterCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: TicketInvestmentRegisterDto;

    constructor(data?: ITicketInvestmentRegisterCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? TicketInvestmentRegisterDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TicketInvestmentRegisterCommand {
        data = typeof data === 'object' ? data : {};
        let result = new TicketInvestmentRegisterCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data; 
    }

    clone(): TicketInvestmentRegisterCommand {
        const json = this.toJSON();
        let result = new TicketInvestmentRegisterCommand();
        result.init(json);
        return result;
    }
}

export interface ITicketInvestmentRegisterCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: TicketInvestmentRegisterDto;
}

export class TicketInvestmentRegisterDto implements ITicketInvestmentRegisterDto {
    customerId?: number;
    stockQuantity?: number;
    rewardPackageId?: number;
    pointsForTicket?: number;
    buyBeginDate?: Date;
    buyEndDate?: Date;
    issueTicketBeginDate?: Date;
    operationDate?: Date;
    registerNote?: string | undefined;
    surveyPhoto1?: string | undefined;
    surveyPhoto2?: string | undefined;
    surveyPhoto3?: string | undefined;
    surveyPhoto4?: string | undefined;
    surveyPhoto5?: string | undefined;
    salesCommitments?: TicketInvestmentRegisterSalesCommitmentDto[] | undefined;
    materials?: TicketInvestmentRegisterMaterialDto[] | undefined;

    constructor(data?: ITicketInvestmentRegisterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.customerId = _data["customerId"];
            this.stockQuantity = _data["stockQuantity"];
            this.rewardPackageId = _data["rewardPackageId"];
            this.pointsForTicket = _data["pointsForTicket"];
            this.buyBeginDate = _data["buyBeginDate"] ? new Date(_data["buyBeginDate"].toString()) : <any>undefined;
            this.buyEndDate = _data["buyEndDate"] ? new Date(_data["buyEndDate"].toString()) : <any>undefined;
            this.issueTicketBeginDate = _data["issueTicketBeginDate"] ? new Date(_data["issueTicketBeginDate"].toString()) : <any>undefined;
            this.operationDate = _data["operationDate"] ? new Date(_data["operationDate"].toString()) : <any>undefined;
            this.registerNote = _data["registerNote"];
            this.surveyPhoto1 = _data["surveyPhoto1"];
            this.surveyPhoto2 = _data["surveyPhoto2"];
            this.surveyPhoto3 = _data["surveyPhoto3"];
            this.surveyPhoto4 = _data["surveyPhoto4"];
            this.surveyPhoto5 = _data["surveyPhoto5"];
            if (Array.isArray(_data["salesCommitments"])) {
                this.salesCommitments = [] as any;
                for (let item of _data["salesCommitments"])
                    this.salesCommitments!.push(TicketInvestmentRegisterSalesCommitmentDto.fromJS(item));
            }
            if (Array.isArray(_data["materials"])) {
                this.materials = [] as any;
                for (let item of _data["materials"])
                    this.materials!.push(TicketInvestmentRegisterMaterialDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TicketInvestmentRegisterDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketInvestmentRegisterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerId"] = this.customerId;
        data["stockQuantity"] = this.stockQuantity;
        data["rewardPackageId"] = this.rewardPackageId;
        data["pointsForTicket"] = this.pointsForTicket;
        data["buyBeginDate"] = this.buyBeginDate ? this.buyBeginDate.toISOString() : <any>undefined;
        data["buyEndDate"] = this.buyEndDate ? this.buyEndDate.toISOString() : <any>undefined;
        data["issueTicketBeginDate"] = this.issueTicketBeginDate ? this.issueTicketBeginDate.toISOString() : <any>undefined;
        data["operationDate"] = this.operationDate ? this.operationDate.toISOString() : <any>undefined;
        data["registerNote"] = this.registerNote;
        data["surveyPhoto1"] = this.surveyPhoto1;
        data["surveyPhoto2"] = this.surveyPhoto2;
        data["surveyPhoto3"] = this.surveyPhoto3;
        data["surveyPhoto4"] = this.surveyPhoto4;
        data["surveyPhoto5"] = this.surveyPhoto5;
        if (Array.isArray(this.salesCommitments)) {
            data["salesCommitments"] = [];
            for (let item of this.salesCommitments)
                data["salesCommitments"].push(item.toJSON());
        }
        if (Array.isArray(this.materials)) {
            data["materials"] = [];
            for (let item of this.materials)
                data["materials"].push(item.toJSON());
        }
        return data; 
    }

    clone(): TicketInvestmentRegisterDto {
        const json = this.toJSON();
        let result = new TicketInvestmentRegisterDto();
        result.init(json);
        return result;
    }
}

export interface ITicketInvestmentRegisterDto {
    customerId?: number;
    stockQuantity?: number;
    rewardPackageId?: number;
    pointsForTicket?: number;
    buyBeginDate?: Date;
    buyEndDate?: Date;
    issueTicketBeginDate?: Date;
    operationDate?: Date;
    registerNote?: string | undefined;
    surveyPhoto1?: string | undefined;
    surveyPhoto2?: string | undefined;
    surveyPhoto3?: string | undefined;
    surveyPhoto4?: string | undefined;
    surveyPhoto5?: string | undefined;
    salesCommitments?: TicketInvestmentRegisterSalesCommitmentDto[] | undefined;
    materials?: TicketInvestmentRegisterMaterialDto[] | undefined;
}

export class TicketInvestmentRegisterMaterialDto implements ITicketInvestmentRegisterMaterialDto {
    materialId?: number;
    registerQuantity?: number;
    note?: string | undefined;

    constructor(data?: ITicketInvestmentRegisterMaterialDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.materialId = _data["materialId"];
            this.registerQuantity = _data["registerQuantity"];
            this.note = _data["note"];
        }
    }

    static fromJS(data: any): TicketInvestmentRegisterMaterialDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketInvestmentRegisterMaterialDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["materialId"] = this.materialId;
        data["registerQuantity"] = this.registerQuantity;
        data["note"] = this.note;
        return data; 
    }

    clone(): TicketInvestmentRegisterMaterialDto {
        const json = this.toJSON();
        let result = new TicketInvestmentRegisterMaterialDto();
        result.init(json);
        return result;
    }
}

export interface ITicketInvestmentRegisterMaterialDto {
    materialId?: number;
    registerQuantity?: number;
    note?: string | undefined;
}

export class TicketInvestmentRegisterSalesCommitmentDto implements ITicketInvestmentRegisterSalesCommitmentDto {
    year?: number;
    month?: number;
    amount?: number;

    constructor(data?: ITicketInvestmentRegisterSalesCommitmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.year = _data["year"];
            this.month = _data["month"];
            this.amount = _data["amount"];
        }
    }

    static fromJS(data: any): TicketInvestmentRegisterSalesCommitmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketInvestmentRegisterSalesCommitmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["year"] = this.year;
        data["month"] = this.month;
        data["amount"] = this.amount;
        return data; 
    }

    clone(): TicketInvestmentRegisterSalesCommitmentDto {
        const json = this.toJSON();
        let result = new TicketInvestmentRegisterSalesCommitmentDto();
        result.init(json);
        return result;
    }
}

export interface ITicketInvestmentRegisterSalesCommitmentDto {
    year?: number;
    month?: number;
    amount?: number;
}

export class TicketInvestmentRemarkDto implements ITicketInvestmentRemarkDto {
    id?: number;
    remark?: number;

    constructor(data?: ITicketInvestmentRemarkDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.remark = _data["remark"];
        }
    }

    static fromJS(data: any): TicketInvestmentRemarkDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketInvestmentRemarkDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["remark"] = this.remark;
        return data; 
    }

    clone(): TicketInvestmentRemarkDto {
        const json = this.toJSON();
        let result = new TicketInvestmentRemarkDto();
        result.init(json);
        return result;
    }
}

export interface ITicketInvestmentRemarkDto {
    id?: number;
    remark?: number;
}

export class TicketInvestmentSalesRemarkCommand implements ITicketInvestmentSalesRemarkCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: TicketInvestmentRemarkDto;

    constructor(data?: ITicketInvestmentSalesRemarkCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? TicketInvestmentRemarkDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TicketInvestmentSalesRemarkCommand {
        data = typeof data === 'object' ? data : {};
        let result = new TicketInvestmentSalesRemarkCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data; 
    }

    clone(): TicketInvestmentSalesRemarkCommand {
        const json = this.toJSON();
        let result = new TicketInvestmentSalesRemarkCommand();
        result.init(json);
        return result;
    }
}

export interface ITicketInvestmentSalesRemarkCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: TicketInvestmentRemarkDto;
}

export class TicketInvestmentSummaryDto implements ITicketInvestmentSummaryDto {
    id?: number;
    ticketQuantity?: number;
    printTicketQuantity?: number;
    smsTicketQuantity?: number;
    actualSalesAmount?: number;
    commitmentSalesAmount?: number;
    remarkOfSales?: number | undefined;
    remarkOfCompany?: number | undefined;
    remarkOfCustomerDevelopement?: number | undefined;

    constructor(data?: ITicketInvestmentSummaryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.ticketQuantity = _data["ticketQuantity"];
            this.printTicketQuantity = _data["printTicketQuantity"];
            this.smsTicketQuantity = _data["smsTicketQuantity"];
            this.actualSalesAmount = _data["actualSalesAmount"];
            this.commitmentSalesAmount = _data["commitmentSalesAmount"];
            this.remarkOfSales = _data["remarkOfSales"];
            this.remarkOfCompany = _data["remarkOfCompany"];
            this.remarkOfCustomerDevelopement = _data["remarkOfCustomerDevelopement"];
        }
    }

    static fromJS(data: any): TicketInvestmentSummaryDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketInvestmentSummaryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["ticketQuantity"] = this.ticketQuantity;
        data["printTicketQuantity"] = this.printTicketQuantity;
        data["smsTicketQuantity"] = this.smsTicketQuantity;
        data["actualSalesAmount"] = this.actualSalesAmount;
        data["commitmentSalesAmount"] = this.commitmentSalesAmount;
        data["remarkOfSales"] = this.remarkOfSales;
        data["remarkOfCompany"] = this.remarkOfCompany;
        data["remarkOfCustomerDevelopement"] = this.remarkOfCustomerDevelopement;
        return data; 
    }

    clone(): TicketInvestmentSummaryDto {
        const json = this.toJSON();
        let result = new TicketInvestmentSummaryDto();
        result.init(json);
        return result;
    }
}

export interface ITicketInvestmentSummaryDto {
    id?: number;
    ticketQuantity?: number;
    printTicketQuantity?: number;
    smsTicketQuantity?: number;
    actualSalesAmount?: number;
    commitmentSalesAmount?: number;
    remarkOfSales?: number | undefined;
    remarkOfCompany?: number | undefined;
    remarkOfCustomerDevelopement?: number | undefined;
}

export class TicketInvestmentSummaryDtoApiResultObject implements ITicketInvestmentSummaryDtoApiResultObject {
    result?: TicketInvestmentSummaryDto;
    success?: boolean;

    constructor(data?: ITicketInvestmentSummaryDtoApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? TicketInvestmentSummaryDto.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): TicketInvestmentSummaryDtoApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new TicketInvestmentSummaryDtoApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data; 
    }

    clone(): TicketInvestmentSummaryDtoApiResultObject {
        const json = this.toJSON();
        let result = new TicketInvestmentSummaryDtoApiResultObject();
        result.init(json);
        return result;
    }
}

export interface ITicketInvestmentSummaryDtoApiResultObject {
    result?: TicketInvestmentSummaryDto;
    success?: boolean;
}

export class TicketInvestmentTrackingDto implements ITicketInvestmentTrackingDto {
    id?: number;
    code?: string | undefined;
    buyBeginDate?: Date;
    buyEndDate?: Date;
    issueTicketBeginDate?: Date;
    issueTicketEndDate?: Date;
    operationDate?: Date;
    sentTicketQuantity?: number;
    qrCodeQuantity?: number;
    consumerQuantity?: number;
    tickets?: TicketDto[] | undefined;

    constructor(data?: ITicketInvestmentTrackingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.buyBeginDate = _data["buyBeginDate"] ? new Date(_data["buyBeginDate"].toString()) : <any>undefined;
            this.buyEndDate = _data["buyEndDate"] ? new Date(_data["buyEndDate"].toString()) : <any>undefined;
            this.issueTicketBeginDate = _data["issueTicketBeginDate"] ? new Date(_data["issueTicketBeginDate"].toString()) : <any>undefined;
            this.issueTicketEndDate = _data["issueTicketEndDate"] ? new Date(_data["issueTicketEndDate"].toString()) : <any>undefined;
            this.operationDate = _data["operationDate"] ? new Date(_data["operationDate"].toString()) : <any>undefined;
            this.sentTicketQuantity = _data["sentTicketQuantity"];
            this.qrCodeQuantity = _data["qrCodeQuantity"];
            this.consumerQuantity = _data["consumerQuantity"];
            if (Array.isArray(_data["tickets"])) {
                this.tickets = [] as any;
                for (let item of _data["tickets"])
                    this.tickets!.push(TicketDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TicketInvestmentTrackingDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketInvestmentTrackingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["buyBeginDate"] = this.buyBeginDate ? this.buyBeginDate.toISOString() : <any>undefined;
        data["buyEndDate"] = this.buyEndDate ? this.buyEndDate.toISOString() : <any>undefined;
        data["issueTicketBeginDate"] = this.issueTicketBeginDate ? this.issueTicketBeginDate.toISOString() : <any>undefined;
        data["issueTicketEndDate"] = this.issueTicketEndDate ? this.issueTicketEndDate.toISOString() : <any>undefined;
        data["operationDate"] = this.operationDate ? this.operationDate.toISOString() : <any>undefined;
        data["sentTicketQuantity"] = this.sentTicketQuantity;
        data["qrCodeQuantity"] = this.qrCodeQuantity;
        data["consumerQuantity"] = this.consumerQuantity;
        if (Array.isArray(this.tickets)) {
            data["tickets"] = [];
            for (let item of this.tickets)
                data["tickets"].push(item.toJSON());
        }
        return data; 
    }

    clone(): TicketInvestmentTrackingDto {
        const json = this.toJSON();
        let result = new TicketInvestmentTrackingDto();
        result.init(json);
        return result;
    }
}

export interface ITicketInvestmentTrackingDto {
    id?: number;
    code?: string | undefined;
    buyBeginDate?: Date;
    buyEndDate?: Date;
    issueTicketBeginDate?: Date;
    issueTicketEndDate?: Date;
    operationDate?: Date;
    sentTicketQuantity?: number;
    qrCodeQuantity?: number;
    consumerQuantity?: number;
    tickets?: TicketDto[] | undefined;
}

export class TicketInvestmentTrackingDtoApiResultObject implements ITicketInvestmentTrackingDtoApiResultObject {
    result?: TicketInvestmentTrackingDto;
    success?: boolean;

    constructor(data?: ITicketInvestmentTrackingDtoApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? TicketInvestmentTrackingDto.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): TicketInvestmentTrackingDtoApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new TicketInvestmentTrackingDtoApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data; 
    }

    clone(): TicketInvestmentTrackingDtoApiResultObject {
        const json = this.toJSON();
        let result = new TicketInvestmentTrackingDtoApiResultObject();
        result.init(json);
        return result;
    }
}

export interface ITicketInvestmentTrackingDtoApiResultObject {
    result?: TicketInvestmentTrackingDto;
    success?: boolean;
}

export class TicketInvestmentUpdateCommand implements ITicketInvestmentUpdateCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: TicketInvestmentUpdateDto;

    constructor(data?: ITicketInvestmentUpdateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? TicketInvestmentUpdateDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TicketInvestmentUpdateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new TicketInvestmentUpdateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data; 
    }

    clone(): TicketInvestmentUpdateCommand {
        const json = this.toJSON();
        let result = new TicketInvestmentUpdateCommand();
        result.init(json);
        return result;
    }
}

export interface ITicketInvestmentUpdateCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: TicketInvestmentUpdateDto;
}

export class TicketInvestmentUpdateDto implements ITicketInvestmentUpdateDto {
    id?: number;
    operationDate?: Date;

    constructor(data?: ITicketInvestmentUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.operationDate = _data["operationDate"] ? new Date(_data["operationDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): TicketInvestmentUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketInvestmentUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["operationDate"] = this.operationDate ? this.operationDate.toISOString() : <any>undefined;
        return data; 
    }

    clone(): TicketInvestmentUpdateDto {
        const json = this.toJSON();
        let result = new TicketInvestmentUpdateDto();
        result.init(json);
        return result;
    }
}

export interface ITicketInvestmentUpdateDto {
    id?: number;
    operationDate?: Date;
}

export class TicketInvestmentUpdatePrintTicketQuantityCommand implements ITicketInvestmentUpdatePrintTicketQuantityCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    id?: number;
    data?: number[] | undefined;

    constructor(data?: ITicketInvestmentUpdatePrintTicketQuantityCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.id = _data["id"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(item);
            }
        }
    }

    static fromJS(data: any): TicketInvestmentUpdatePrintTicketQuantityCommand {
        data = typeof data === 'object' ? data : {};
        let result = new TicketInvestmentUpdatePrintTicketQuantityCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["id"] = this.id;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item);
        }
        return data; 
    }

    clone(): TicketInvestmentUpdatePrintTicketQuantityCommand {
        const json = this.toJSON();
        let result = new TicketInvestmentUpdatePrintTicketQuantityCommand();
        result.init(json);
        return result;
    }
}

export interface ITicketInvestmentUpdatePrintTicketQuantityCommand {
    commandId?: string;
    occuredDate?: Date;
    id?: number;
    data?: number[] | undefined;
}

export class TicketInvestmentUpsertAcceptanceCommand implements ITicketInvestmentUpsertAcceptanceCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: TicketInvestmentUpsertAcceptanceDto;
    handleType?: string | undefined;

    constructor(data?: ITicketInvestmentUpsertAcceptanceCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? TicketInvestmentUpsertAcceptanceDto.fromJS(_data["data"]) : <any>undefined;
            this.handleType = _data["handleType"];
        }
    }

    static fromJS(data: any): TicketInvestmentUpsertAcceptanceCommand {
        data = typeof data === 'object' ? data : {};
        let result = new TicketInvestmentUpsertAcceptanceCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["handleType"] = this.handleType;
        return data; 
    }

    clone(): TicketInvestmentUpsertAcceptanceCommand {
        const json = this.toJSON();
        let result = new TicketInvestmentUpsertAcceptanceCommand();
        result.init(json);
        return result;
    }
}

export interface ITicketInvestmentUpsertAcceptanceCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: TicketInvestmentUpsertAcceptanceDto;
    handleType?: string | undefined;
}

export class TicketInvestmentUpsertAcceptanceDto implements ITicketInvestmentUpsertAcceptanceDto {
    id?: number;
    acceptanceDate?: Date;
    note?: string | undefined;
    actualSalesAmount?: number;
    photo1?: string | undefined;
    photo2?: string | undefined;
    photo3?: string | undefined;
    photo4?: string | undefined;
    photo5?: string | undefined;

    constructor(data?: ITicketInvestmentUpsertAcceptanceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.acceptanceDate = _data["acceptanceDate"] ? new Date(_data["acceptanceDate"].toString()) : <any>undefined;
            this.note = _data["note"];
            this.actualSalesAmount = _data["actualSalesAmount"];
            this.photo1 = _data["photo1"];
            this.photo2 = _data["photo2"];
            this.photo3 = _data["photo3"];
            this.photo4 = _data["photo4"];
            this.photo5 = _data["photo5"];
        }
    }

    static fromJS(data: any): TicketInvestmentUpsertAcceptanceDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketInvestmentUpsertAcceptanceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["acceptanceDate"] = this.acceptanceDate ? this.acceptanceDate.toISOString() : <any>undefined;
        data["note"] = this.note;
        data["actualSalesAmount"] = this.actualSalesAmount;
        data["photo1"] = this.photo1;
        data["photo2"] = this.photo2;
        data["photo3"] = this.photo3;
        data["photo4"] = this.photo4;
        data["photo5"] = this.photo5;
        return data; 
    }

    clone(): TicketInvestmentUpsertAcceptanceDto {
        const json = this.toJSON();
        let result = new TicketInvestmentUpsertAcceptanceDto();
        result.init(json);
        return result;
    }
}

export interface ITicketInvestmentUpsertAcceptanceDto {
    id?: number;
    acceptanceDate?: Date;
    note?: string | undefined;
    actualSalesAmount?: number;
    photo1?: string | undefined;
    photo2?: string | undefined;
    photo3?: string | undefined;
    photo4?: string | undefined;
    photo5?: string | undefined;
}

export class TicketInvestmentUpsertConsumerRewardCommand implements ITicketInvestmentUpsertConsumerRewardCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: TicketInvestmentUpsertConsumerRewardDto;
    readonly handleType?: string | undefined;

    constructor(data?: ITicketInvestmentUpsertConsumerRewardCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? TicketInvestmentUpsertConsumerRewardDto.fromJS(_data["data"]) : <any>undefined;
            (<any>this).handleType = _data["handleType"];
        }
    }

    static fromJS(data: any): TicketInvestmentUpsertConsumerRewardCommand {
        data = typeof data === 'object' ? data : {};
        let result = new TicketInvestmentUpsertConsumerRewardCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["handleType"] = this.handleType;
        return data; 
    }

    clone(): TicketInvestmentUpsertConsumerRewardCommand {
        const json = this.toJSON();
        let result = new TicketInvestmentUpsertConsumerRewardCommand();
        result.init(json);
        return result;
    }
}

export interface ITicketInvestmentUpsertConsumerRewardCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: TicketInvestmentUpsertConsumerRewardDto;
    handleType?: string | undefined;
}

export class TicketInvestmentUpsertConsumerRewardDto implements ITicketInvestmentUpsertConsumerRewardDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    rewardItemId?: number;
    quantity?: number;
    photo1?: string | undefined;
    photo2?: string | undefined;
    photo3?: string | undefined;
    photo4?: string | undefined;
    photo5?: string | undefined;
    detailChanges?: ConsumerRewardDetailCrudListDto;

    constructor(data?: ITicketInvestmentUpsertConsumerRewardDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.rewardItemId = _data["rewardItemId"];
            this.quantity = _data["quantity"];
            this.photo1 = _data["photo1"];
            this.photo2 = _data["photo2"];
            this.photo3 = _data["photo3"];
            this.photo4 = _data["photo4"];
            this.photo5 = _data["photo5"];
            this.detailChanges = _data["detailChanges"] ? ConsumerRewardDetailCrudListDto.fromJS(_data["detailChanges"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TicketInvestmentUpsertConsumerRewardDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketInvestmentUpsertConsumerRewardDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["rewardItemId"] = this.rewardItemId;
        data["quantity"] = this.quantity;
        data["photo1"] = this.photo1;
        data["photo2"] = this.photo2;
        data["photo3"] = this.photo3;
        data["photo4"] = this.photo4;
        data["photo5"] = this.photo5;
        data["detailChanges"] = this.detailChanges ? this.detailChanges.toJSON() : <any>undefined;
        return data; 
    }

    clone(): TicketInvestmentUpsertConsumerRewardDto {
        const json = this.toJSON();
        let result = new TicketInvestmentUpsertConsumerRewardDto();
        result.init(json);
        return result;
    }
}

export interface ITicketInvestmentUpsertConsumerRewardDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    rewardItemId?: number;
    quantity?: number;
    photo1?: string | undefined;
    photo2?: string | undefined;
    photo3?: string | undefined;
    photo4?: string | undefined;
    photo5?: string | undefined;
    detailChanges?: ConsumerRewardDetailCrudListDto;
}

export class TicketInvestmentUpsertFinalSettlementCommand implements ITicketInvestmentUpsertFinalSettlementCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: TicketInvestmentUpsertFinalSettlementDto;
    handleType?: string | undefined;

    constructor(data?: ITicketInvestmentUpsertFinalSettlementCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? TicketInvestmentUpsertFinalSettlementDto.fromJS(_data["data"]) : <any>undefined;
            this.handleType = _data["handleType"];
        }
    }

    static fromJS(data: any): TicketInvestmentUpsertFinalSettlementCommand {
        data = typeof data === 'object' ? data : {};
        let result = new TicketInvestmentUpsertFinalSettlementCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["handleType"] = this.handleType;
        return data; 
    }

    clone(): TicketInvestmentUpsertFinalSettlementCommand {
        const json = this.toJSON();
        let result = new TicketInvestmentUpsertFinalSettlementCommand();
        result.init(json);
        return result;
    }
}

export interface ITicketInvestmentUpsertFinalSettlementCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: TicketInvestmentUpsertFinalSettlementDto;
    handleType?: string | undefined;
}

export class TicketInvestmentUpsertFinalSettlementDto implements ITicketInvestmentUpsertFinalSettlementDto {
    id?: number;
    date?: Date;
    note?: string | undefined;
    decideUserId?: number;

    constructor(data?: ITicketInvestmentUpsertFinalSettlementDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.note = _data["note"];
            this.decideUserId = _data["decideUserId"];
        }
    }

    static fromJS(data: any): TicketInvestmentUpsertFinalSettlementDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketInvestmentUpsertFinalSettlementDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["note"] = this.note;
        data["decideUserId"] = this.decideUserId;
        return data; 
    }

    clone(): TicketInvestmentUpsertFinalSettlementDto {
        const json = this.toJSON();
        let result = new TicketInvestmentUpsertFinalSettlementDto();
        result.init(json);
        return result;
    }
}

export interface ITicketInvestmentUpsertFinalSettlementDto {
    id?: number;
    date?: Date;
    note?: string | undefined;
    decideUserId?: number;
}

export class TicketInvestmentUpsertProgressCommand implements ITicketInvestmentUpsertProgressCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: TicketInvestmentUpsertProgressDto;
    readonly handleType?: string | undefined;

    constructor(data?: ITicketInvestmentUpsertProgressCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? TicketInvestmentUpsertProgressDto.fromJS(_data["data"]) : <any>undefined;
            (<any>this).handleType = _data["handleType"];
        }
    }

    static fromJS(data: any): TicketInvestmentUpsertProgressCommand {
        data = typeof data === 'object' ? data : {};
        let result = new TicketInvestmentUpsertProgressCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["handleType"] = this.handleType;
        return data; 
    }

    clone(): TicketInvestmentUpsertProgressCommand {
        const json = this.toJSON();
        let result = new TicketInvestmentUpsertProgressCommand();
        result.init(json);
        return result;
    }
}

export interface ITicketInvestmentUpsertProgressCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: TicketInvestmentUpsertProgressDto;
    handleType?: string | undefined;
}

export class TicketInvestmentUpsertProgressDto implements ITicketInvestmentUpsertProgressDto {
    id?: number;
    progressId?: number;
    documentPhoto1?: string | undefined;
    documentPhoto2?: string | undefined;
    documentPhoto3?: string | undefined;
    documentPhoto4?: string | undefined;
    documentPhoto5?: string | undefined;
    note?: string | undefined;
    upsertRewardItems?: TicketInvestmentUpsertProgressRewardItemDto[] | undefined;
    upsertMaterials?: TicketInvestmentUpsertProgressMaterialDto[] | undefined;

    constructor(data?: ITicketInvestmentUpsertProgressDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.progressId = _data["progressId"];
            this.documentPhoto1 = _data["documentPhoto1"];
            this.documentPhoto2 = _data["documentPhoto2"];
            this.documentPhoto3 = _data["documentPhoto3"];
            this.documentPhoto4 = _data["documentPhoto4"];
            this.documentPhoto5 = _data["documentPhoto5"];
            this.note = _data["note"];
            if (Array.isArray(_data["upsertRewardItems"])) {
                this.upsertRewardItems = [] as any;
                for (let item of _data["upsertRewardItems"])
                    this.upsertRewardItems!.push(TicketInvestmentUpsertProgressRewardItemDto.fromJS(item));
            }
            if (Array.isArray(_data["upsertMaterials"])) {
                this.upsertMaterials = [] as any;
                for (let item of _data["upsertMaterials"])
                    this.upsertMaterials!.push(TicketInvestmentUpsertProgressMaterialDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TicketInvestmentUpsertProgressDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketInvestmentUpsertProgressDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["progressId"] = this.progressId;
        data["documentPhoto1"] = this.documentPhoto1;
        data["documentPhoto2"] = this.documentPhoto2;
        data["documentPhoto3"] = this.documentPhoto3;
        data["documentPhoto4"] = this.documentPhoto4;
        data["documentPhoto5"] = this.documentPhoto5;
        data["note"] = this.note;
        if (Array.isArray(this.upsertRewardItems)) {
            data["upsertRewardItems"] = [];
            for (let item of this.upsertRewardItems)
                data["upsertRewardItems"].push(item.toJSON());
        }
        if (Array.isArray(this.upsertMaterials)) {
            data["upsertMaterials"] = [];
            for (let item of this.upsertMaterials)
                data["upsertMaterials"].push(item.toJSON());
        }
        return data; 
    }

    clone(): TicketInvestmentUpsertProgressDto {
        const json = this.toJSON();
        let result = new TicketInvestmentUpsertProgressDto();
        result.init(json);
        return result;
    }
}

export interface ITicketInvestmentUpsertProgressDto {
    id?: number;
    progressId?: number;
    documentPhoto1?: string | undefined;
    documentPhoto2?: string | undefined;
    documentPhoto3?: string | undefined;
    documentPhoto4?: string | undefined;
    documentPhoto5?: string | undefined;
    note?: string | undefined;
    upsertRewardItems?: TicketInvestmentUpsertProgressRewardItemDto[] | undefined;
    upsertMaterials?: TicketInvestmentUpsertProgressMaterialDto[] | undefined;
}

export class TicketInvestmentUpsertProgressMaterialDto implements ITicketInvestmentUpsertProgressMaterialDto {
    id?: number;
    materialId?: number;
    isReceived?: boolean;
    isSentDesign?: boolean;
    photo1?: string | undefined;
    photo2?: string | undefined;
    photo3?: string | undefined;
    photo4?: string | undefined;
    photo5?: string | undefined;

    constructor(data?: ITicketInvestmentUpsertProgressMaterialDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.materialId = _data["materialId"];
            this.isReceived = _data["isReceived"];
            this.isSentDesign = _data["isSentDesign"];
            this.photo1 = _data["photo1"];
            this.photo2 = _data["photo2"];
            this.photo3 = _data["photo3"];
            this.photo4 = _data["photo4"];
            this.photo5 = _data["photo5"];
        }
    }

    static fromJS(data: any): TicketInvestmentUpsertProgressMaterialDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketInvestmentUpsertProgressMaterialDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["materialId"] = this.materialId;
        data["isReceived"] = this.isReceived;
        data["isSentDesign"] = this.isSentDesign;
        data["photo1"] = this.photo1;
        data["photo2"] = this.photo2;
        data["photo3"] = this.photo3;
        data["photo4"] = this.photo4;
        data["photo5"] = this.photo5;
        return data; 
    }

    clone(): TicketInvestmentUpsertProgressMaterialDto {
        const json = this.toJSON();
        let result = new TicketInvestmentUpsertProgressMaterialDto();
        result.init(json);
        return result;
    }
}

export interface ITicketInvestmentUpsertProgressMaterialDto {
    id?: number;
    materialId?: number;
    isReceived?: boolean;
    isSentDesign?: boolean;
    photo1?: string | undefined;
    photo2?: string | undefined;
    photo3?: string | undefined;
    photo4?: string | undefined;
    photo5?: string | undefined;
}

export class TicketInvestmentUpsertProgressRewardItemDto implements ITicketInvestmentUpsertProgressRewardItemDto {
    id?: number;
    rewardItemId?: number;
    isReceived?: boolean;

    constructor(data?: ITicketInvestmentUpsertProgressRewardItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.rewardItemId = _data["rewardItemId"];
            this.isReceived = _data["isReceived"];
        }
    }

    static fromJS(data: any): TicketInvestmentUpsertProgressRewardItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketInvestmentUpsertProgressRewardItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["rewardItemId"] = this.rewardItemId;
        data["isReceived"] = this.isReceived;
        return data; 
    }

    clone(): TicketInvestmentUpsertProgressRewardItemDto {
        const json = this.toJSON();
        let result = new TicketInvestmentUpsertProgressRewardItemDto();
        result.init(json);
        return result;
    }
}

export interface ITicketInvestmentUpsertProgressRewardItemDto {
    id?: number;
    rewardItemId?: number;
    isReceived?: boolean;
}

export class TicketListDto implements ITicketListDto {
    id?: number;
    isSelected?: boolean;
    code?: string | undefined;
    consumerPhone?: string | undefined;
    consumerName?: string | undefined;
    issueDate?: Date | undefined;
    printDate?: Date | undefined;
    printCount?: number;
    lastPrintUserId?: number | undefined;
    ticketInvestmentId?: number;
    lastPrintUserName?: string | undefined;

    constructor(data?: ITicketListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.isSelected = _data["isSelected"];
            this.code = _data["code"];
            this.consumerPhone = _data["consumerPhone"];
            this.consumerName = _data["consumerName"];
            this.issueDate = _data["issueDate"] ? new Date(_data["issueDate"].toString()) : <any>undefined;
            this.printDate = _data["printDate"] ? new Date(_data["printDate"].toString()) : <any>undefined;
            this.printCount = _data["printCount"];
            this.lastPrintUserId = _data["lastPrintUserId"];
            this.ticketInvestmentId = _data["ticketInvestmentId"];
            this.lastPrintUserName = _data["lastPrintUserName"];
        }
    }

    static fromJS(data: any): TicketListDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["isSelected"] = this.isSelected;
        data["code"] = this.code;
        data["consumerPhone"] = this.consumerPhone;
        data["consumerName"] = this.consumerName;
        data["issueDate"] = this.issueDate ? this.issueDate.toISOString() : <any>undefined;
        data["printDate"] = this.printDate ? this.printDate.toISOString() : <any>undefined;
        data["printCount"] = this.printCount;
        data["lastPrintUserId"] = this.lastPrintUserId;
        data["ticketInvestmentId"] = this.ticketInvestmentId;
        data["lastPrintUserName"] = this.lastPrintUserName;
        return data; 
    }

    clone(): TicketListDto {
        const json = this.toJSON();
        let result = new TicketListDto();
        result.init(json);
        return result;
    }
}

export interface ITicketListDto {
    id?: number;
    isSelected?: boolean;
    code?: string | undefined;
    consumerPhone?: string | undefined;
    consumerName?: string | undefined;
    issueDate?: Date | undefined;
    printDate?: Date | undefined;
    printCount?: number;
    lastPrintUserId?: number | undefined;
    ticketInvestmentId?: number;
    lastPrintUserName?: string | undefined;
}

export class TicketListDtoPagingResult implements ITicketListDtoPagingResult {
    items?: TicketListDto[] | undefined;
    totalCount?: number;

    constructor(data?: ITicketListDtoPagingResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TicketListDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): TicketListDtoPagingResult {
        data = typeof data === 'object' ? data : {};
        let result = new TicketListDtoPagingResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): TicketListDtoPagingResult {
        const json = this.toJSON();
        let result = new TicketListDtoPagingResult();
        result.init(json);
        return result;
    }
}

export interface ITicketListDtoPagingResult {
    items?: TicketListDto[] | undefined;
    totalCount?: number;
}

export class TicketListDtoPagingResultApiResultObject implements ITicketListDtoPagingResultApiResultObject {
    result?: TicketListDtoPagingResult;
    success?: boolean;

    constructor(data?: ITicketListDtoPagingResultApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? TicketListDtoPagingResult.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): TicketListDtoPagingResultApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new TicketListDtoPagingResultApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data; 
    }

    clone(): TicketListDtoPagingResultApiResultObject {
        const json = this.toJSON();
        let result = new TicketListDtoPagingResultApiResultObject();
        result.init(json);
        return result;
    }
}

export interface ITicketListDtoPagingResultApiResultObject {
    result?: TicketListDtoPagingResult;
    success?: boolean;
}

export class TicketMaterialDto implements ITicketMaterialDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    materialId?: number;
    materialCode?: string | undefined;
    materialName?: string | undefined;
    registerQuantity?: number;
    price?: number;
    note?: string | undefined;
    amount?: number;
    isDesign?: boolean;

    constructor(data?: ITicketMaterialDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.materialId = _data["materialId"];
            this.materialCode = _data["materialCode"];
            this.materialName = _data["materialName"];
            this.registerQuantity = _data["registerQuantity"];
            this.price = _data["price"];
            this.note = _data["note"];
            this.amount = _data["amount"];
            this.isDesign = _data["isDesign"];
        }
    }

    static fromJS(data: any): TicketMaterialDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketMaterialDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["materialId"] = this.materialId;
        data["materialCode"] = this.materialCode;
        data["materialName"] = this.materialName;
        data["registerQuantity"] = this.registerQuantity;
        data["price"] = this.price;
        data["note"] = this.note;
        data["amount"] = this.amount;
        data["isDesign"] = this.isDesign;
        return data; 
    }

    clone(): TicketMaterialDto {
        const json = this.toJSON();
        let result = new TicketMaterialDto();
        result.init(json);
        return result;
    }
}

export interface ITicketMaterialDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    materialId?: number;
    materialCode?: string | undefined;
    materialName?: string | undefined;
    registerQuantity?: number;
    price?: number;
    note?: string | undefined;
    amount?: number;
    isDesign?: boolean;
}

export class TicketOperationDto implements ITicketOperationDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    operationDate?: Date;
    note?: string | undefined;
    stockQuantity?: number;
    photo1?: string | undefined;
    photo2?: string | undefined;
    photo3?: string | undefined;
    photo4?: string | undefined;
    photo5?: string | undefined;
    updateUserId?: number | undefined;
    updateUserName?: string | undefined;

    constructor(data?: ITicketOperationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.operationDate = _data["operationDate"] ? new Date(_data["operationDate"].toString()) : <any>undefined;
            this.note = _data["note"];
            this.stockQuantity = _data["stockQuantity"];
            this.photo1 = _data["photo1"];
            this.photo2 = _data["photo2"];
            this.photo3 = _data["photo3"];
            this.photo4 = _data["photo4"];
            this.photo5 = _data["photo5"];
            this.updateUserId = _data["updateUserId"];
            this.updateUserName = _data["updateUserName"];
        }
    }

    static fromJS(data: any): TicketOperationDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketOperationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["operationDate"] = this.operationDate ? this.operationDate.toISOString() : <any>undefined;
        data["note"] = this.note;
        data["stockQuantity"] = this.stockQuantity;
        data["photo1"] = this.photo1;
        data["photo2"] = this.photo2;
        data["photo3"] = this.photo3;
        data["photo4"] = this.photo4;
        data["photo5"] = this.photo5;
        data["updateUserId"] = this.updateUserId;
        data["updateUserName"] = this.updateUserName;
        return data; 
    }

    clone(): TicketOperationDto {
        const json = this.toJSON();
        let result = new TicketOperationDto();
        result.init(json);
        return result;
    }
}

export interface ITicketOperationDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    operationDate?: Date;
    note?: string | undefined;
    stockQuantity?: number;
    photo1?: string | undefined;
    photo2?: string | undefined;
    photo3?: string | undefined;
    photo4?: string | undefined;
    photo5?: string | undefined;
    updateUserId?: number | undefined;
    updateUserName?: string | undefined;
}

export class TicketProgressDto implements ITicketProgressDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    updateTime?: Date;
    documentPhoto1?: string | undefined;
    documentPhoto2?: string | undefined;
    documentPhoto3?: string | undefined;
    documentPhoto4?: string | undefined;
    documentPhoto5?: string | undefined;
    note?: string | undefined;
    materials?: TicketProgressMaterialDto[] | undefined;
    rewardItems?: TicketProgressRewardItemDto[] | undefined;
    updateUserId?: number;
    updateUserName?: string | undefined;

    constructor(data?: ITicketProgressDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.updateTime = _data["updateTime"] ? new Date(_data["updateTime"].toString()) : <any>undefined;
            this.documentPhoto1 = _data["documentPhoto1"];
            this.documentPhoto2 = _data["documentPhoto2"];
            this.documentPhoto3 = _data["documentPhoto3"];
            this.documentPhoto4 = _data["documentPhoto4"];
            this.documentPhoto5 = _data["documentPhoto5"];
            this.note = _data["note"];
            if (Array.isArray(_data["materials"])) {
                this.materials = [] as any;
                for (let item of _data["materials"])
                    this.materials!.push(TicketProgressMaterialDto.fromJS(item));
            }
            if (Array.isArray(_data["rewardItems"])) {
                this.rewardItems = [] as any;
                for (let item of _data["rewardItems"])
                    this.rewardItems!.push(TicketProgressRewardItemDto.fromJS(item));
            }
            this.updateUserId = _data["updateUserId"];
            this.updateUserName = _data["updateUserName"];
        }
    }

    static fromJS(data: any): TicketProgressDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketProgressDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["updateTime"] = this.updateTime ? this.updateTime.toISOString() : <any>undefined;
        data["documentPhoto1"] = this.documentPhoto1;
        data["documentPhoto2"] = this.documentPhoto2;
        data["documentPhoto3"] = this.documentPhoto3;
        data["documentPhoto4"] = this.documentPhoto4;
        data["documentPhoto5"] = this.documentPhoto5;
        data["note"] = this.note;
        if (Array.isArray(this.materials)) {
            data["materials"] = [];
            for (let item of this.materials)
                data["materials"].push(item.toJSON());
        }
        if (Array.isArray(this.rewardItems)) {
            data["rewardItems"] = [];
            for (let item of this.rewardItems)
                data["rewardItems"].push(item.toJSON());
        }
        data["updateUserId"] = this.updateUserId;
        data["updateUserName"] = this.updateUserName;
        return data; 
    }

    clone(): TicketProgressDto {
        const json = this.toJSON();
        let result = new TicketProgressDto();
        result.init(json);
        return result;
    }
}

export interface ITicketProgressDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    updateTime?: Date;
    documentPhoto1?: string | undefined;
    documentPhoto2?: string | undefined;
    documentPhoto3?: string | undefined;
    documentPhoto4?: string | undefined;
    documentPhoto5?: string | undefined;
    note?: string | undefined;
    materials?: TicketProgressMaterialDto[] | undefined;
    rewardItems?: TicketProgressRewardItemDto[] | undefined;
    updateUserId?: number;
    updateUserName?: string | undefined;
}

export class TicketProgressMaterialDto implements ITicketProgressMaterialDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    materialId?: number;
    materialName?: string | undefined;
    materialCode?: string | undefined;
    isReceived?: boolean;
    isSentDesign?: boolean;
    photo1?: string | undefined;
    photo2?: string | undefined;
    photo3?: string | undefined;
    photo4?: string | undefined;
    photo5?: string | undefined;
    price?: number;
    isDesign?: boolean;
    registerQuantity?: number;
    amount?: number;

    constructor(data?: ITicketProgressMaterialDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.materialId = _data["materialId"];
            this.materialName = _data["materialName"];
            this.materialCode = _data["materialCode"];
            this.isReceived = _data["isReceived"];
            this.isSentDesign = _data["isSentDesign"];
            this.photo1 = _data["photo1"];
            this.photo2 = _data["photo2"];
            this.photo3 = _data["photo3"];
            this.photo4 = _data["photo4"];
            this.photo5 = _data["photo5"];
            this.price = _data["price"];
            this.isDesign = _data["isDesign"];
            this.registerQuantity = _data["registerQuantity"];
            this.amount = _data["amount"];
        }
    }

    static fromJS(data: any): TicketProgressMaterialDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketProgressMaterialDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["materialId"] = this.materialId;
        data["materialName"] = this.materialName;
        data["materialCode"] = this.materialCode;
        data["isReceived"] = this.isReceived;
        data["isSentDesign"] = this.isSentDesign;
        data["photo1"] = this.photo1;
        data["photo2"] = this.photo2;
        data["photo3"] = this.photo3;
        data["photo4"] = this.photo4;
        data["photo5"] = this.photo5;
        data["price"] = this.price;
        data["isDesign"] = this.isDesign;
        data["registerQuantity"] = this.registerQuantity;
        data["amount"] = this.amount;
        return data; 
    }

    clone(): TicketProgressMaterialDto {
        const json = this.toJSON();
        let result = new TicketProgressMaterialDto();
        result.init(json);
        return result;
    }
}

export interface ITicketProgressMaterialDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    materialId?: number;
    materialName?: string | undefined;
    materialCode?: string | undefined;
    isReceived?: boolean;
    isSentDesign?: boolean;
    photo1?: string | undefined;
    photo2?: string | undefined;
    photo3?: string | undefined;
    photo4?: string | undefined;
    photo5?: string | undefined;
    price?: number;
    isDesign?: boolean;
    registerQuantity?: number;
    amount?: number;
}

export class TicketProgressRewardItemDto implements ITicketProgressRewardItemDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    rewardItemId?: number;
    rewardItemCode?: string | undefined;
    rewardItemName?: string | undefined;
    isReceived?: boolean;
    documentLink?: string | undefined;
    price?: number;
    quantity?: number;

    constructor(data?: ITicketProgressRewardItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.rewardItemId = _data["rewardItemId"];
            this.rewardItemCode = _data["rewardItemCode"];
            this.rewardItemName = _data["rewardItemName"];
            this.isReceived = _data["isReceived"];
            this.documentLink = _data["documentLink"];
            this.price = _data["price"];
            this.quantity = _data["quantity"];
        }
    }

    static fromJS(data: any): TicketProgressRewardItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketProgressRewardItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["rewardItemId"] = this.rewardItemId;
        data["rewardItemCode"] = this.rewardItemCode;
        data["rewardItemName"] = this.rewardItemName;
        data["isReceived"] = this.isReceived;
        data["documentLink"] = this.documentLink;
        data["price"] = this.price;
        data["quantity"] = this.quantity;
        return data; 
    }

    clone(): TicketProgressRewardItemDto {
        const json = this.toJSON();
        let result = new TicketProgressRewardItemDto();
        result.init(json);
        return result;
    }
}

export interface ITicketProgressRewardItemDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    rewardItemId?: number;
    rewardItemCode?: string | undefined;
    rewardItemName?: string | undefined;
    isReceived?: boolean;
    documentLink?: string | undefined;
    price?: number;
    quantity?: number;
}

export class TicketRewardItemDto implements ITicketRewardItemDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    rewardItemId?: number;
    rewardItemName?: string | undefined;
    quantity?: number;
    price?: number;
    amount?: number;
    documentLink?: string | undefined;
    rewardItemCode?: string | undefined;

    constructor(data?: ITicketRewardItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.rewardItemId = _data["rewardItemId"];
            this.rewardItemName = _data["rewardItemName"];
            this.quantity = _data["quantity"];
            this.price = _data["price"];
            this.amount = _data["amount"];
            this.documentLink = _data["documentLink"];
            this.rewardItemCode = _data["rewardItemCode"];
        }
    }

    static fromJS(data: any): TicketRewardItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketRewardItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["rewardItemId"] = this.rewardItemId;
        data["rewardItemName"] = this.rewardItemName;
        data["quantity"] = this.quantity;
        data["price"] = this.price;
        data["amount"] = this.amount;
        data["documentLink"] = this.documentLink;
        data["rewardItemCode"] = this.rewardItemCode;
        return data; 
    }

    clone(): TicketRewardItemDto {
        const json = this.toJSON();
        let result = new TicketRewardItemDto();
        result.init(json);
        return result;
    }
}

export interface ITicketRewardItemDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    rewardItemId?: number;
    rewardItemName?: string | undefined;
    quantity?: number;
    price?: number;
    amount?: number;
    documentLink?: string | undefined;
    rewardItemCode?: string | undefined;
}

export class TicketSalesCommitmentDto implements ITicketSalesCommitmentDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    year?: number;
    month?: number;
    amount?: number;

    constructor(data?: ITicketSalesCommitmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.year = _data["year"];
            this.month = _data["month"];
            this.amount = _data["amount"];
        }
    }

    static fromJS(data: any): TicketSalesCommitmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketSalesCommitmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["year"] = this.year;
        data["month"] = this.month;
        data["amount"] = this.amount;
        return data; 
    }

    clone(): TicketSalesCommitmentDto {
        const json = this.toJSON();
        let result = new TicketSalesCommitmentDto();
        result.init(json);
        return result;
    }
}

export interface ITicketSalesCommitmentDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    year?: number;
    month?: number;
    amount?: number;
}

export class UpdateProfileCommand implements IUpdateProfileCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: UpdateProfileDto;

    constructor(data?: IUpdateProfileCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? UpdateProfileDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateProfileCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProfileCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data; 
    }

    clone(): UpdateProfileCommand {
        const json = this.toJSON();
        let result = new UpdateProfileCommand();
        result.init(json);
        return result;
    }
}

export interface IUpdateProfileCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: UpdateProfileDto;
}

export class UpdateProfileDto implements IUpdateProfileDto {
    password?: string | undefined;
    name?: string | undefined;
    emailAddress?: string | undefined;
    phoneNumber?: string | undefined;
    birthday?: Date | undefined;

    constructor(data?: IUpdateProfileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.password = _data["password"];
            this.name = _data["name"];
            this.emailAddress = _data["emailAddress"];
            this.phoneNumber = _data["phoneNumber"];
            this.birthday = _data["birthday"] ? new Date(_data["birthday"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateProfileDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProfileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["password"] = this.password;
        data["name"] = this.name;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["birthday"] = this.birthday ? this.birthday.toISOString() : <any>undefined;
        return data; 
    }

    clone(): UpdateProfileDto {
        const json = this.toJSON();
        let result = new UpdateProfileDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateProfileDto {
    password?: string | undefined;
    name?: string | undefined;
    emailAddress?: string | undefined;
    phoneNumber?: string | undefined;
    birthday?: Date | undefined;
}

export class UpsertAppSettingCommand implements IUpsertAppSettingCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: UpsertAppSettingDto;
    readonly handleType?: string | undefined;

    constructor(data?: IUpsertAppSettingCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? UpsertAppSettingDto.fromJS(_data["data"]) : <any>undefined;
            (<any>this).handleType = _data["handleType"];
        }
    }

    static fromJS(data: any): UpsertAppSettingCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpsertAppSettingCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["handleType"] = this.handleType;
        return data; 
    }

    clone(): UpsertAppSettingCommand {
        const json = this.toJSON();
        let result = new UpsertAppSettingCommand();
        result.init(json);
        return result;
    }
}

export interface IUpsertAppSettingCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: UpsertAppSettingDto;
    handleType?: string | undefined;
}

export class UpsertAppSettingDto implements IUpsertAppSettingDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    value?: string | undefined;
    description?: string | undefined;

    constructor(data?: IUpsertAppSettingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.value = _data["value"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): UpsertAppSettingDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpsertAppSettingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["value"] = this.value;
        data["description"] = this.description;
        return data; 
    }

    clone(): UpsertAppSettingDto {
        const json = this.toJSON();
        let result = new UpsertAppSettingDto();
        result.init(json);
        return result;
    }
}

export interface IUpsertAppSettingDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    value?: string | undefined;
    description?: string | undefined;
}

export class UpsertBrandCommand implements IUpsertBrandCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: UpsertBrandDto;
    readonly handleType?: string | undefined;

    constructor(data?: IUpsertBrandCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? UpsertBrandDto.fromJS(_data["data"]) : <any>undefined;
            (<any>this).handleType = _data["handleType"];
        }
    }

    static fromJS(data: any): UpsertBrandCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpsertBrandCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["handleType"] = this.handleType;
        return data; 
    }

    clone(): UpsertBrandCommand {
        const json = this.toJSON();
        let result = new UpsertBrandCommand();
        result.init(json);
        return result;
    }
}

export interface IUpsertBrandCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: UpsertBrandDto;
    handleType?: string | undefined;
}

export class UpsertBrandDto implements IUpsertBrandDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    isActive?: boolean;

    constructor(data?: IUpsertBrandDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): UpsertBrandDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpsertBrandDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): UpsertBrandDto {
        const json = this.toJSON();
        let result = new UpsertBrandDto();
        result.init(json);
        return result;
    }
}

export interface IUpsertBrandDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    isActive?: boolean;
}

export class UpsertCycleCommand implements IUpsertCycleCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: UpsertCycleDto;
    readonly handleType?: string | undefined;

    constructor(data?: IUpsertCycleCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? UpsertCycleDto.fromJS(_data["data"]) : <any>undefined;
            (<any>this).handleType = _data["handleType"];
        }
    }

    static fromJS(data: any): UpsertCycleCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpsertCycleCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["handleType"] = this.handleType;
        return data; 
    }

    clone(): UpsertCycleCommand {
        const json = this.toJSON();
        let result = new UpsertCycleCommand();
        result.init(json);
        return result;
    }
}

export interface IUpsertCycleCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: UpsertCycleDto;
    handleType?: string | undefined;
}

export class UpsertCycleDto implements IUpsertCycleDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    number?: string | undefined;
    year?: number;
    isActive?: boolean;
    fromDate?: Date;
    toDate?: Date;

    constructor(data?: IUpsertCycleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.number = _data["number"];
            this.year = _data["year"];
            this.isActive = _data["isActive"];
            this.fromDate = _data["fromDate"] ? new Date(_data["fromDate"].toString()) : <any>undefined;
            this.toDate = _data["toDate"] ? new Date(_data["toDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UpsertCycleDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpsertCycleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["number"] = this.number;
        data["year"] = this.year;
        data["isActive"] = this.isActive;
        data["fromDate"] = this.fromDate ? this.fromDate.toISOString() : <any>undefined;
        data["toDate"] = this.toDate ? this.toDate.toISOString() : <any>undefined;
        return data; 
    }

    clone(): UpsertCycleDto {
        const json = this.toJSON();
        let result = new UpsertCycleDto();
        result.init(json);
        return result;
    }
}

export interface IUpsertCycleDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    number?: string | undefined;
    year?: number;
    isActive?: boolean;
    fromDate?: Date;
    toDate?: Date;
}

export class UpsertInvestmentBranchSettingDto implements IUpsertInvestmentBranchSettingDto {
    id?: number;
    isEditablePoint?: boolean;
    branchId?: number;

    constructor(data?: IUpsertInvestmentBranchSettingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.isEditablePoint = _data["isEditablePoint"];
            this.branchId = _data["branchId"];
        }
    }

    static fromJS(data: any): UpsertInvestmentBranchSettingDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpsertInvestmentBranchSettingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["isEditablePoint"] = this.isEditablePoint;
        data["branchId"] = this.branchId;
        return data; 
    }

    clone(): UpsertInvestmentBranchSettingDto {
        const json = this.toJSON();
        let result = new UpsertInvestmentBranchSettingDto();
        result.init(json);
        return result;
    }
}

export interface IUpsertInvestmentBranchSettingDto {
    id?: number;
    isEditablePoint?: boolean;
    branchId?: number;
}

export class UpsertInvestmentBranchSettingDtoCrudListDto implements IUpsertInvestmentBranchSettingDtoCrudListDto {
    upsertedItems?: UpsertInvestmentBranchSettingDto[] | undefined;
    deletedItems?: UpsertInvestmentBranchSettingDto[] | undefined;

    constructor(data?: IUpsertInvestmentBranchSettingDtoCrudListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["upsertedItems"])) {
                this.upsertedItems = [] as any;
                for (let item of _data["upsertedItems"])
                    this.upsertedItems!.push(UpsertInvestmentBranchSettingDto.fromJS(item));
            }
            if (Array.isArray(_data["deletedItems"])) {
                this.deletedItems = [] as any;
                for (let item of _data["deletedItems"])
                    this.deletedItems!.push(UpsertInvestmentBranchSettingDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpsertInvestmentBranchSettingDtoCrudListDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpsertInvestmentBranchSettingDtoCrudListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.upsertedItems)) {
            data["upsertedItems"] = [];
            for (let item of this.upsertedItems)
                data["upsertedItems"].push(item.toJSON());
        }
        if (Array.isArray(this.deletedItems)) {
            data["deletedItems"] = [];
            for (let item of this.deletedItems)
                data["deletedItems"].push(item.toJSON());
        }
        return data; 
    }

    clone(): UpsertInvestmentBranchSettingDtoCrudListDto {
        const json = this.toJSON();
        let result = new UpsertInvestmentBranchSettingDtoCrudListDto();
        result.init(json);
        return result;
    }
}

export interface IUpsertInvestmentBranchSettingDtoCrudListDto {
    upsertedItems?: UpsertInvestmentBranchSettingDto[] | undefined;
    deletedItems?: UpsertInvestmentBranchSettingDto[] | undefined;
}

export class UpsertInvestmentSettingCommand implements IUpsertInvestmentSettingCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: UpsertInvestmentSettingDto;
    readonly handleType?: string | undefined;

    constructor(data?: IUpsertInvestmentSettingCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? UpsertInvestmentSettingDto.fromJS(_data["data"]) : <any>undefined;
            (<any>this).handleType = _data["handleType"];
        }
    }

    static fromJS(data: any): UpsertInvestmentSettingCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpsertInvestmentSettingCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["handleType"] = this.handleType;
        return data; 
    }

    clone(): UpsertInvestmentSettingCommand {
        const json = this.toJSON();
        let result = new UpsertInvestmentSettingCommand();
        result.init(json);
        return result;
    }
}

export interface IUpsertInvestmentSettingCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: UpsertInvestmentSettingDto;
    handleType?: string | undefined;
}

export class UpsertInvestmentSettingDto implements IUpsertInvestmentSettingDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    maxInvestAmount?: number;
    amountPerPoint?: number;
    maxInvestmentQueryMonths?: number;
    defaultPointsForTicket?: number;
    checkQrCodeBranch?: boolean;
    beginIssueDaysAfterCurrent?: number;
    endIssueDaysBeforeOperation?: number;
    investmentBranchSettingChanges?: UpsertInvestmentBranchSettingDtoCrudListDto;

    constructor(data?: IUpsertInvestmentSettingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.maxInvestAmount = _data["maxInvestAmount"];
            this.amountPerPoint = _data["amountPerPoint"];
            this.maxInvestmentQueryMonths = _data["maxInvestmentQueryMonths"];
            this.defaultPointsForTicket = _data["defaultPointsForTicket"];
            this.checkQrCodeBranch = _data["checkQrCodeBranch"];
            this.beginIssueDaysAfterCurrent = _data["beginIssueDaysAfterCurrent"];
            this.endIssueDaysBeforeOperation = _data["endIssueDaysBeforeOperation"];
            this.investmentBranchSettingChanges = _data["investmentBranchSettingChanges"] ? UpsertInvestmentBranchSettingDtoCrudListDto.fromJS(_data["investmentBranchSettingChanges"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpsertInvestmentSettingDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpsertInvestmentSettingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["maxInvestAmount"] = this.maxInvestAmount;
        data["amountPerPoint"] = this.amountPerPoint;
        data["maxInvestmentQueryMonths"] = this.maxInvestmentQueryMonths;
        data["defaultPointsForTicket"] = this.defaultPointsForTicket;
        data["checkQrCodeBranch"] = this.checkQrCodeBranch;
        data["beginIssueDaysAfterCurrent"] = this.beginIssueDaysAfterCurrent;
        data["endIssueDaysBeforeOperation"] = this.endIssueDaysBeforeOperation;
        data["investmentBranchSettingChanges"] = this.investmentBranchSettingChanges ? this.investmentBranchSettingChanges.toJSON() : <any>undefined;
        return data; 
    }

    clone(): UpsertInvestmentSettingDto {
        const json = this.toJSON();
        let result = new UpsertInvestmentSettingDto();
        result.init(json);
        return result;
    }
}

export interface IUpsertInvestmentSettingDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    maxInvestAmount?: number;
    amountPerPoint?: number;
    maxInvestmentQueryMonths?: number;
    defaultPointsForTicket?: number;
    checkQrCodeBranch?: boolean;
    beginIssueDaysAfterCurrent?: number;
    endIssueDaysBeforeOperation?: number;
    investmentBranchSettingChanges?: UpsertInvestmentBranchSettingDtoCrudListDto;
}

export class UpsertMaterialDto implements IUpsertMaterialDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    materialTypeId?: number;
    description?: string | undefined;
    value?: number;
    isActive?: boolean;
    isDesign?: boolean;

    constructor(data?: IUpsertMaterialDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.materialTypeId = _data["materialTypeId"];
            this.description = _data["description"];
            this.value = _data["value"];
            this.isActive = _data["isActive"];
            this.isDesign = _data["isDesign"];
        }
    }

    static fromJS(data: any): UpsertMaterialDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpsertMaterialDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["materialTypeId"] = this.materialTypeId;
        data["description"] = this.description;
        data["value"] = this.value;
        data["isActive"] = this.isActive;
        data["isDesign"] = this.isDesign;
        return data; 
    }

    clone(): UpsertMaterialDto {
        const json = this.toJSON();
        let result = new UpsertMaterialDto();
        result.init(json);
        return result;
    }
}

export interface IUpsertMaterialDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    materialTypeId?: number;
    description?: string | undefined;
    value?: number;
    isActive?: boolean;
    isDesign?: boolean;
}

export class UpsertProductClassCommand implements IUpsertProductClassCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: UpsertProductClassDto;
    readonly handleType?: string | undefined;

    constructor(data?: IUpsertProductClassCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? UpsertProductClassDto.fromJS(_data["data"]) : <any>undefined;
            (<any>this).handleType = _data["handleType"];
        }
    }

    static fromJS(data: any): UpsertProductClassCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpsertProductClassCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["handleType"] = this.handleType;
        return data; 
    }

    clone(): UpsertProductClassCommand {
        const json = this.toJSON();
        let result = new UpsertProductClassCommand();
        result.init(json);
        return result;
    }
}

export interface IUpsertProductClassCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: UpsertProductClassDto;
    handleType?: string | undefined;
}

export class UpsertProductClassDto implements IUpsertProductClassDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    rewardCode?: string | undefined;
    isActive?: boolean;

    constructor(data?: IUpsertProductClassDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.rewardCode = _data["rewardCode"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): UpsertProductClassDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpsertProductClassDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["rewardCode"] = this.rewardCode;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): UpsertProductClassDto {
        const json = this.toJSON();
        let result = new UpsertProductClassDto();
        result.init(json);
        return result;
    }
}

export interface IUpsertProductClassDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    rewardCode?: string | undefined;
    isActive?: boolean;
}

export class UpsertProductCommand implements IUpsertProductCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: UpsertProductDto;
    readonly handleType?: string | undefined;

    constructor(data?: IUpsertProductCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? UpsertProductDto.fromJS(_data["data"]) : <any>undefined;
            (<any>this).handleType = _data["handleType"];
        }
    }

    static fromJS(data: any): UpsertProductCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpsertProductCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["handleType"] = this.handleType;
        return data; 
    }

    clone(): UpsertProductCommand {
        const json = this.toJSON();
        let result = new UpsertProductCommand();
        result.init(json);
        return result;
    }
}

export interface IUpsertProductCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: UpsertProductDto;
    handleType?: string | undefined;
}

export class UpsertProductDto implements IUpsertProductDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    isActive?: boolean;
    unit?: string | undefined;
    caseUnit?: string | undefined;
    packSize?: number;
    productClassId?: number | undefined;
    subProductClassId?: number | undefined;
    brandId?: number | undefined;
    updateDate?: Date;
    point?: number;

    constructor(data?: IUpsertProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.isActive = _data["isActive"];
            this.unit = _data["unit"];
            this.caseUnit = _data["caseUnit"];
            this.packSize = _data["packSize"];
            this.productClassId = _data["productClassId"];
            this.subProductClassId = _data["subProductClassId"];
            this.brandId = _data["brandId"];
            this.updateDate = _data["updateDate"] ? new Date(_data["updateDate"].toString()) : <any>undefined;
            this.point = _data["point"];
        }
    }

    static fromJS(data: any): UpsertProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpsertProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["description"] = this.description;
        data["isActive"] = this.isActive;
        data["unit"] = this.unit;
        data["caseUnit"] = this.caseUnit;
        data["packSize"] = this.packSize;
        data["productClassId"] = this.productClassId;
        data["subProductClassId"] = this.subProductClassId;
        data["brandId"] = this.brandId;
        data["updateDate"] = this.updateDate ? this.updateDate.toISOString() : <any>undefined;
        data["point"] = this.point;
        return data; 
    }

    clone(): UpsertProductDto {
        const json = this.toJSON();
        let result = new UpsertProductDto();
        result.init(json);
        return result;
    }
}

export interface IUpsertProductDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    isActive?: boolean;
    unit?: string | undefined;
    caseUnit?: string | undefined;
    packSize?: number;
    productClassId?: number | undefined;
    subProductClassId?: number | undefined;
    brandId?: number | undefined;
    updateDate?: Date;
    point?: number;
}

export class UpsertProductItemCommand implements IUpsertProductItemCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: UpsertProductDto;
    readonly handleType?: string | undefined;

    constructor(data?: IUpsertProductItemCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? UpsertProductDto.fromJS(_data["data"]) : <any>undefined;
            (<any>this).handleType = _data["handleType"];
        }
    }

    static fromJS(data: any): UpsertProductItemCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpsertProductItemCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["handleType"] = this.handleType;
        return data; 
    }

    clone(): UpsertProductItemCommand {
        const json = this.toJSON();
        let result = new UpsertProductItemCommand();
        result.init(json);
        return result;
    }
}

export interface IUpsertProductItemCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: UpsertProductDto;
    handleType?: string | undefined;
}

export class UpsertProductUnitCommand implements IUpsertProductUnitCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: UpsertProductUnitDto;
    readonly handleType?: string | undefined;

    constructor(data?: IUpsertProductUnitCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? UpsertProductUnitDto.fromJS(_data["data"]) : <any>undefined;
            (<any>this).handleType = _data["handleType"];
        }
    }

    static fromJS(data: any): UpsertProductUnitCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpsertProductUnitCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["handleType"] = this.handleType;
        return data; 
    }

    clone(): UpsertProductUnitCommand {
        const json = this.toJSON();
        let result = new UpsertProductUnitCommand();
        result.init(json);
        return result;
    }
}

export interface IUpsertProductUnitCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: UpsertProductUnitDto;
    handleType?: string | undefined;
}

export class UpsertProductUnitDto implements IUpsertProductUnitDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    isActive?: boolean;

    constructor(data?: IUpsertProductUnitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): UpsertProductUnitDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpsertProductUnitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): UpsertProductUnitDto {
        const json = this.toJSON();
        let result = new UpsertProductUnitDto();
        result.init(json);
        return result;
    }
}

export interface IUpsertProductUnitDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    isActive?: boolean;
}

export class UpsertRoleCommand implements IUpsertRoleCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: UpsertRoleDto;
    readonly handleType?: string | undefined;

    constructor(data?: IUpsertRoleCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? UpsertRoleDto.fromJS(_data["data"]) : <any>undefined;
            (<any>this).handleType = _data["handleType"];
        }
    }

    static fromJS(data: any): UpsertRoleCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpsertRoleCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["handleType"] = this.handleType;
        return data; 
    }

    clone(): UpsertRoleCommand {
        const json = this.toJSON();
        let result = new UpsertRoleCommand();
        result.init(json);
        return result;
    }
}

export interface IUpsertRoleCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: UpsertRoleDto;
    handleType?: string | undefined;
}

export class UpsertRoleDto implements IUpsertRoleDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    roleName?: string | undefined;
    displayName?: string | undefined;
    description?: string | undefined;
    isActive?: boolean;
    permissions?: RolePermissionDto[] | undefined;
    permissionChanges?: RolePermissionDtoCrudListDto;

    constructor(data?: IUpsertRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.roleName = _data["roleName"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(RolePermissionDto.fromJS(item));
            }
            this.permissionChanges = _data["permissionChanges"] ? RolePermissionDtoCrudListDto.fromJS(_data["permissionChanges"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpsertRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpsertRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["roleName"] = this.roleName;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        data["permissionChanges"] = this.permissionChanges ? this.permissionChanges.toJSON() : <any>undefined;
        return data; 
    }

    clone(): UpsertRoleDto {
        const json = this.toJSON();
        let result = new UpsertRoleDto();
        result.init(json);
        return result;
    }
}

export interface IUpsertRoleDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    roleName?: string | undefined;
    displayName?: string | undefined;
    description?: string | undefined;
    isActive?: boolean;
    permissions?: RolePermissionDto[] | undefined;
    permissionChanges?: RolePermissionDtoCrudListDto;
}

export class UpsertUserAssignmentDto implements IUpsertUserAssignmentDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    salesOrgId?: number;

    constructor(data?: IUpsertUserAssignmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.salesOrgId = _data["salesOrgId"];
        }
    }

    static fromJS(data: any): UpsertUserAssignmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpsertUserAssignmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["salesOrgId"] = this.salesOrgId;
        return data; 
    }

    clone(): UpsertUserAssignmentDto {
        const json = this.toJSON();
        let result = new UpsertUserAssignmentDto();
        result.init(json);
        return result;
    }
}

export interface IUpsertUserAssignmentDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    salesOrgId?: number;
}

export class UpsertUserAssignmentDtoCrudListDto implements IUpsertUserAssignmentDtoCrudListDto {
    upsertedItems?: UpsertUserAssignmentDto[] | undefined;
    deletedItems?: UpsertUserAssignmentDto[] | undefined;

    constructor(data?: IUpsertUserAssignmentDtoCrudListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["upsertedItems"])) {
                this.upsertedItems = [] as any;
                for (let item of _data["upsertedItems"])
                    this.upsertedItems!.push(UpsertUserAssignmentDto.fromJS(item));
            }
            if (Array.isArray(_data["deletedItems"])) {
                this.deletedItems = [] as any;
                for (let item of _data["deletedItems"])
                    this.deletedItems!.push(UpsertUserAssignmentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpsertUserAssignmentDtoCrudListDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpsertUserAssignmentDtoCrudListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.upsertedItems)) {
            data["upsertedItems"] = [];
            for (let item of this.upsertedItems)
                data["upsertedItems"].push(item.toJSON());
        }
        if (Array.isArray(this.deletedItems)) {
            data["deletedItems"] = [];
            for (let item of this.deletedItems)
                data["deletedItems"].push(item.toJSON());
        }
        return data; 
    }

    clone(): UpsertUserAssignmentDtoCrudListDto {
        const json = this.toJSON();
        let result = new UpsertUserAssignmentDtoCrudListDto();
        result.init(json);
        return result;
    }
}

export interface IUpsertUserAssignmentDtoCrudListDto {
    upsertedItems?: UpsertUserAssignmentDto[] | undefined;
    deletedItems?: UpsertUserAssignmentDto[] | undefined;
}

export class UpsertUserDto implements IUpsertUserDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    userName?: string | undefined;
    name?: string | undefined;
    emailAddress?: string | undefined;
    phoneNumber?: string | undefined;
    isActive?: boolean;
    expireDate?: Date | undefined;
    birthday?: Date | undefined;
    registerDate?: Date;
    roles?: UserRoleDto[] | undefined;
    assignments?: UserAssignmentDto[] | undefined;
    password?: string | undefined;
    roleChanges?: UserRoleDtoCrudListDto;
    assignmentChanges?: UpsertUserAssignmentDtoCrudListDto;

    constructor(data?: IUpsertUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.emailAddress = _data["emailAddress"];
            this.phoneNumber = _data["phoneNumber"];
            this.isActive = _data["isActive"];
            this.expireDate = _data["expireDate"] ? new Date(_data["expireDate"].toString()) : <any>undefined;
            this.birthday = _data["birthday"] ? new Date(_data["birthday"].toString()) : <any>undefined;
            this.registerDate = _data["registerDate"] ? new Date(_data["registerDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(UserRoleDto.fromJS(item));
            }
            if (Array.isArray(_data["assignments"])) {
                this.assignments = [] as any;
                for (let item of _data["assignments"])
                    this.assignments!.push(UserAssignmentDto.fromJS(item));
            }
            this.password = _data["password"];
            this.roleChanges = _data["roleChanges"] ? UserRoleDtoCrudListDto.fromJS(_data["roleChanges"]) : <any>undefined;
            this.assignmentChanges = _data["assignmentChanges"] ? UpsertUserAssignmentDtoCrudListDto.fromJS(_data["assignmentChanges"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpsertUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpsertUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["isActive"] = this.isActive;
        data["expireDate"] = this.expireDate ? this.expireDate.toISOString() : <any>undefined;
        data["birthday"] = this.birthday ? this.birthday.toISOString() : <any>undefined;
        data["registerDate"] = this.registerDate ? this.registerDate.toISOString() : <any>undefined;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        if (Array.isArray(this.assignments)) {
            data["assignments"] = [];
            for (let item of this.assignments)
                data["assignments"].push(item.toJSON());
        }
        data["password"] = this.password;
        data["roleChanges"] = this.roleChanges ? this.roleChanges.toJSON() : <any>undefined;
        data["assignmentChanges"] = this.assignmentChanges ? this.assignmentChanges.toJSON() : <any>undefined;
        return data; 
    }

    clone(): UpsertUserDto {
        const json = this.toJSON();
        let result = new UpsertUserDto();
        result.init(json);
        return result;
    }
}

export interface IUpsertUserDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    userName?: string | undefined;
    name?: string | undefined;
    emailAddress?: string | undefined;
    phoneNumber?: string | undefined;
    isActive?: boolean;
    expireDate?: Date | undefined;
    birthday?: Date | undefined;
    registerDate?: Date;
    roles?: UserRoleDto[] | undefined;
    assignments?: UserAssignmentDto[] | undefined;
    password?: string | undefined;
    roleChanges?: UserRoleDtoCrudListDto;
    assignmentChanges?: UpsertUserAssignmentDtoCrudListDto;
}

export class UpsertUserExtCommand implements IUpsertUserExtCommand {
    readonly commandId?: string;
    readonly occuredDate?: Date;
    data?: UpsertUserDto;
    readonly handleType?: string | undefined;

    constructor(data?: IUpsertUserExtCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).commandId = _data["commandId"];
            (<any>this).occuredDate = _data["occuredDate"] ? new Date(_data["occuredDate"].toString()) : <any>undefined;
            this.data = _data["data"] ? UpsertUserDto.fromJS(_data["data"]) : <any>undefined;
            (<any>this).handleType = _data["handleType"];
        }
    }

    static fromJS(data: any): UpsertUserExtCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpsertUserExtCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["occuredDate"] = this.occuredDate ? this.occuredDate.toISOString() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["handleType"] = this.handleType;
        return data; 
    }

    clone(): UpsertUserExtCommand {
        const json = this.toJSON();
        let result = new UpsertUserExtCommand();
        result.init(json);
        return result;
    }
}

export interface IUpsertUserExtCommand {
    commandId?: string;
    occuredDate?: Date;
    data?: UpsertUserDto;
    handleType?: string | undefined;
}

export class UserAssignmentDto implements IUserAssignmentDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    userId?: number;
    salesOrgId?: number;
    salesOrgName?: string | undefined;

    constructor(data?: IUserAssignmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.userId = _data["userId"];
            this.salesOrgId = _data["salesOrgId"];
            this.salesOrgName = _data["salesOrgName"];
        }
    }

    static fromJS(data: any): UserAssignmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserAssignmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["userId"] = this.userId;
        data["salesOrgId"] = this.salesOrgId;
        data["salesOrgName"] = this.salesOrgName;
        return data; 
    }

    clone(): UserAssignmentDto {
        const json = this.toJSON();
        let result = new UserAssignmentDto();
        result.init(json);
        return result;
    }
}

export interface IUserAssignmentDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    userId?: number;
    salesOrgId?: number;
    salesOrgName?: string | undefined;
}

export class UserDto implements IUserDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    userName?: string | undefined;
    name?: string | undefined;
    emailAddress?: string | undefined;
    phoneNumber?: string | undefined;
    isActive?: boolean;
    expireDate?: Date | undefined;
    birthday?: Date | undefined;
    registerDate?: Date;
    roles?: UserRoleDto[] | undefined;
    assignments?: UserAssignmentDto[] | undefined;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.emailAddress = _data["emailAddress"];
            this.phoneNumber = _data["phoneNumber"];
            this.isActive = _data["isActive"];
            this.expireDate = _data["expireDate"] ? new Date(_data["expireDate"].toString()) : <any>undefined;
            this.birthday = _data["birthday"] ? new Date(_data["birthday"].toString()) : <any>undefined;
            this.registerDate = _data["registerDate"] ? new Date(_data["registerDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(UserRoleDto.fromJS(item));
            }
            if (Array.isArray(_data["assignments"])) {
                this.assignments = [] as any;
                for (let item of _data["assignments"])
                    this.assignments!.push(UserAssignmentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["isActive"] = this.isActive;
        data["expireDate"] = this.expireDate ? this.expireDate.toISOString() : <any>undefined;
        data["birthday"] = this.birthday ? this.birthday.toISOString() : <any>undefined;
        data["registerDate"] = this.registerDate ? this.registerDate.toISOString() : <any>undefined;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        if (Array.isArray(this.assignments)) {
            data["assignments"] = [];
            for (let item of this.assignments)
                data["assignments"].push(item.toJSON());
        }
        return data; 
    }

    clone(): UserDto {
        const json = this.toJSON();
        let result = new UserDto();
        result.init(json);
        return result;
    }
}

export interface IUserDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    userName?: string | undefined;
    name?: string | undefined;
    emailAddress?: string | undefined;
    phoneNumber?: string | undefined;
    isActive?: boolean;
    expireDate?: Date | undefined;
    birthday?: Date | undefined;
    registerDate?: Date;
    roles?: UserRoleDto[] | undefined;
    assignments?: UserAssignmentDto[] | undefined;
}

export class UserDtoApiResultObject implements IUserDtoApiResultObject {
    result?: UserDto;
    success?: boolean;

    constructor(data?: IUserDtoApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? UserDto.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): UserDtoApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new UserDtoApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data; 
    }

    clone(): UserDtoApiResultObject {
        const json = this.toJSON();
        let result = new UserDtoApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IUserDtoApiResultObject {
    result?: UserDto;
    success?: boolean;
}

export class UserListItemDto implements IUserListItemDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    userName?: string | undefined;
    name?: string | undefined;
    emailAddress?: string | undefined;
    phoneNumber?: string | undefined;
    isActive?: boolean;
    expireDate?: Date | undefined;
    birthday?: Date | undefined;
    registerDate?: Date;
    roleName?: string | undefined;

    constructor(data?: IUserListItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.emailAddress = _data["emailAddress"];
            this.phoneNumber = _data["phoneNumber"];
            this.isActive = _data["isActive"];
            this.expireDate = _data["expireDate"] ? new Date(_data["expireDate"].toString()) : <any>undefined;
            this.birthday = _data["birthday"] ? new Date(_data["birthday"].toString()) : <any>undefined;
            this.registerDate = _data["registerDate"] ? new Date(_data["registerDate"].toString()) : <any>undefined;
            this.roleName = _data["roleName"];
        }
    }

    static fromJS(data: any): UserListItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserListItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["isActive"] = this.isActive;
        data["expireDate"] = this.expireDate ? this.expireDate.toISOString() : <any>undefined;
        data["birthday"] = this.birthday ? this.birthday.toISOString() : <any>undefined;
        data["registerDate"] = this.registerDate ? this.registerDate.toISOString() : <any>undefined;
        data["roleName"] = this.roleName;
        return data; 
    }

    clone(): UserListItemDto {
        const json = this.toJSON();
        let result = new UserListItemDto();
        result.init(json);
        return result;
    }
}

export interface IUserListItemDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    userName?: string | undefined;
    name?: string | undefined;
    emailAddress?: string | undefined;
    phoneNumber?: string | undefined;
    isActive?: boolean;
    expireDate?: Date | undefined;
    birthday?: Date | undefined;
    registerDate?: Date;
    roleName?: string | undefined;
}

export class UserListItemDtoPagingResult implements IUserListItemDtoPagingResult {
    items?: UserListItemDto[] | undefined;
    totalCount?: number;

    constructor(data?: IUserListItemDtoPagingResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserListItemDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): UserListItemDtoPagingResult {
        data = typeof data === 'object' ? data : {};
        let result = new UserListItemDtoPagingResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): UserListItemDtoPagingResult {
        const json = this.toJSON();
        let result = new UserListItemDtoPagingResult();
        result.init(json);
        return result;
    }
}

export interface IUserListItemDtoPagingResult {
    items?: UserListItemDto[] | undefined;
    totalCount?: number;
}

export class UserListItemDtoPagingResultApiResultObject implements IUserListItemDtoPagingResultApiResultObject {
    result?: UserListItemDtoPagingResult;
    success?: boolean;

    constructor(data?: IUserListItemDtoPagingResultApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? UserListItemDtoPagingResult.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): UserListItemDtoPagingResultApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new UserListItemDtoPagingResultApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data; 
    }

    clone(): UserListItemDtoPagingResultApiResultObject {
        const json = this.toJSON();
        let result = new UserListItemDtoPagingResultApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IUserListItemDtoPagingResultApiResultObject {
    result?: UserListItemDtoPagingResult;
    success?: boolean;
}

export class UserRoleDto implements IUserRoleDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    roleId?: number;
    roleName?: string | undefined;
    displayName?: string | undefined;
    description?: string | undefined;

    constructor(data?: IUserRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.roleId = _data["roleId"];
            this.roleName = _data["roleName"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): UserRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["roleId"] = this.roleId;
        data["roleName"] = this.roleName;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        return data; 
    }

    clone(): UserRoleDto {
        const json = this.toJSON();
        let result = new UserRoleDto();
        result.init(json);
        return result;
    }
}

export interface IUserRoleDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    roleId?: number;
    roleName?: string | undefined;
    displayName?: string | undefined;
    description?: string | undefined;
}

export class UserRoleDtoCrudListDto implements IUserRoleDtoCrudListDto {
    upsertedItems?: UserRoleDto[] | undefined;
    deletedItems?: UserRoleDto[] | undefined;

    constructor(data?: IUserRoleDtoCrudListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["upsertedItems"])) {
                this.upsertedItems = [] as any;
                for (let item of _data["upsertedItems"])
                    this.upsertedItems!.push(UserRoleDto.fromJS(item));
            }
            if (Array.isArray(_data["deletedItems"])) {
                this.deletedItems = [] as any;
                for (let item of _data["deletedItems"])
                    this.deletedItems!.push(UserRoleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserRoleDtoCrudListDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserRoleDtoCrudListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.upsertedItems)) {
            data["upsertedItems"] = [];
            for (let item of this.upsertedItems)
                data["upsertedItems"].push(item.toJSON());
        }
        if (Array.isArray(this.deletedItems)) {
            data["deletedItems"] = [];
            for (let item of this.deletedItems)
                data["deletedItems"].push(item.toJSON());
        }
        return data; 
    }

    clone(): UserRoleDtoCrudListDto {
        const json = this.toJSON();
        let result = new UserRoleDtoCrudListDto();
        result.init(json);
        return result;
    }
}

export interface IUserRoleDtoCrudListDto {
    upsertedItems?: UserRoleDto[] | undefined;
    deletedItems?: UserRoleDto[] | undefined;
}

export class WardDto implements IWardDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;

    constructor(data?: IWardDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): WardDto {
        data = typeof data === 'object' ? data : {};
        let result = new WardDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["name"] = this.name;
        return data; 
    }

    clone(): WardDto {
        const json = this.toJSON();
        let result = new WardDto();
        result.init(json);
        return result;
    }
}

export interface IWardDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
}

export class WardDtoApiResultObject implements IWardDtoApiResultObject {
    result?: WardDto;
    success?: boolean;

    constructor(data?: IWardDtoApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? WardDto.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): WardDtoApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new WardDtoApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data; 
    }

    clone(): WardDtoApiResultObject {
        const json = this.toJSON();
        let result = new WardDtoApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IWardDtoApiResultObject {
    result?: WardDto;
    success?: boolean;
}

export class WardDtoPagingResult implements IWardDtoPagingResult {
    items?: WardDto[] | undefined;
    totalCount?: number;

    constructor(data?: IWardDtoPagingResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(WardDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): WardDtoPagingResult {
        data = typeof data === 'object' ? data : {};
        let result = new WardDtoPagingResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): WardDtoPagingResult {
        const json = this.toJSON();
        let result = new WardDtoPagingResult();
        result.init(json);
        return result;
    }
}

export interface IWardDtoPagingResult {
    items?: WardDto[] | undefined;
    totalCount?: number;
}

export class WardDtoPagingResultApiResultObject implements IWardDtoPagingResultApiResultObject {
    result?: WardDtoPagingResult;
    success?: boolean;

    constructor(data?: IWardDtoPagingResultApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? WardDtoPagingResult.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): WardDtoPagingResultApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new WardDtoPagingResultApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data; 
    }

    clone(): WardDtoPagingResultApiResultObject {
        const json = this.toJSON();
        let result = new WardDtoPagingResultApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IWardDtoPagingResultApiResultObject {
    result?: WardDtoPagingResult;
    success?: boolean;
}

export class WardNameListDto implements IWardNameListDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    district?: string | undefined;
    province?: string | undefined;

    constructor(data?: IWardNameListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.district = _data["district"];
            this.province = _data["province"];
        }
    }

    static fromJS(data: any): WardNameListDto {
        data = typeof data === 'object' ? data : {};
        let result = new WardNameListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["district"] = this.district;
        data["province"] = this.province;
        return data; 
    }

    clone(): WardNameListDto {
        const json = this.toJSON();
        let result = new WardNameListDto();
        result.init(json);
        return result;
    }
}

export interface IWardNameListDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    district?: string | undefined;
    province?: string | undefined;
}

export class WardNameListDtoPagingResult implements IWardNameListDtoPagingResult {
    items?: WardNameListDto[] | undefined;
    totalCount?: number;

    constructor(data?: IWardNameListDtoPagingResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(WardNameListDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): WardNameListDtoPagingResult {
        data = typeof data === 'object' ? data : {};
        let result = new WardNameListDtoPagingResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): WardNameListDtoPagingResult {
        const json = this.toJSON();
        let result = new WardNameListDtoPagingResult();
        result.init(json);
        return result;
    }
}

export interface IWardNameListDtoPagingResult {
    items?: WardNameListDto[] | undefined;
    totalCount?: number;
}

export class WardNameListDtoPagingResultApiResultObject implements IWardNameListDtoPagingResultApiResultObject {
    result?: WardNameListDtoPagingResult;
    success?: boolean;

    constructor(data?: IWardNameListDtoPagingResultApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? WardNameListDtoPagingResult.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): WardNameListDtoPagingResultApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new WardNameListDtoPagingResultApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data; 
    }

    clone(): WardNameListDtoPagingResultApiResultObject {
        const json = this.toJSON();
        let result = new WardNameListDtoPagingResultApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IWardNameListDtoPagingResultApiResultObject {
    result?: WardNameListDtoPagingResult;
    success?: boolean;
}

export class YearData implements IYearData {
    measure?: string | undefined;
    amount?: number;

    constructor(data?: IYearData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.measure = _data["measure"];
            this.amount = _data["amount"];
        }
    }

    static fromJS(data: any): YearData {
        data = typeof data === 'object' ? data : {};
        let result = new YearData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["measure"] = this.measure;
        data["amount"] = this.amount;
        return data; 
    }

    clone(): YearData {
        const json = this.toJSON();
        let result = new YearData();
        result.init(json);
        return result;
    }
}

export interface IYearData {
    measure?: string | undefined;
    amount?: number;
}

export class ZoneDto implements IZoneDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    salesOrgId?: number;

    constructor(data?: IZoneDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.salesOrgId = _data["salesOrgId"];
        }
    }

    static fromJS(data: any): ZoneDto {
        data = typeof data === 'object' ? data : {};
        let result = new ZoneDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["salesOrgId"] = this.salesOrgId;
        return data; 
    }

    clone(): ZoneDto {
        const json = this.toJSON();
        let result = new ZoneDto();
        result.init(json);
        return result;
    }
}

export interface IZoneDto {
    id?: number;
    creationTime?: Date;
    creatorUserId?: number | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierUserId?: number | undefined;
    code?: string | undefined;
    name?: string | undefined;
    salesOrgId?: number;
}

export class ZoneDtoApiResultObject implements IZoneDtoApiResultObject {
    result?: ZoneDto;
    success?: boolean;

    constructor(data?: IZoneDtoApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? ZoneDto.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): ZoneDtoApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new ZoneDtoApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data; 
    }

    clone(): ZoneDtoApiResultObject {
        const json = this.toJSON();
        let result = new ZoneDtoApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IZoneDtoApiResultObject {
    result?: ZoneDto;
    success?: boolean;
}

export class ZoneDtoPagingResult implements IZoneDtoPagingResult {
    items?: ZoneDto[] | undefined;
    totalCount?: number;

    constructor(data?: IZoneDtoPagingResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ZoneDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ZoneDtoPagingResult {
        data = typeof data === 'object' ? data : {};
        let result = new ZoneDtoPagingResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): ZoneDtoPagingResult {
        const json = this.toJSON();
        let result = new ZoneDtoPagingResult();
        result.init(json);
        return result;
    }
}

export interface IZoneDtoPagingResult {
    items?: ZoneDto[] | undefined;
    totalCount?: number;
}

export class ZoneDtoPagingResultApiResultObject implements IZoneDtoPagingResultApiResultObject {
    result?: ZoneDtoPagingResult;
    success?: boolean;

    constructor(data?: IZoneDtoPagingResultApiResultObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? ZoneDtoPagingResult.fromJS(_data["result"]) : <any>undefined;
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): ZoneDtoPagingResultApiResultObject {
        data = typeof data === 'object' ? data : {};
        let result = new ZoneDtoPagingResultApiResultObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["success"] = this.success;
        return data; 
    }

    clone(): ZoneDtoPagingResultApiResultObject {
        const json = this.toJSON();
        let result = new ZoneDtoPagingResultApiResultObject();
        result.init(json);
        return result;
    }
}

export interface IZoneDtoPagingResultApiResultObject {
    result?: ZoneDtoPagingResult;
    success?: boolean;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}